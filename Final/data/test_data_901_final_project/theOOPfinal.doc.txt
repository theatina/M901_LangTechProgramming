Ευάγγελος Γ.
Ούτσιος (BSc, MSc) Τομέας Υπολογιστικών Τεχνικών και Συστημάτων
Βρόγχοι και αποφάσεις
Βασικά στοιχεία συναρτήσεων..
Κλήση συναρτήσεων από συναρτήσεις
Δείκτες και συναρτήσεις.
Private και public.
Κλήση συναρτήσεων-μελών.
Απόδοση τιμών μέσω παραμέτρων.
Συναρτήσεις εγκατάστασης (constructors)
Συναρτήσεις εγκατάστασης με υπερφόρτωση.
Αντικείμενα σαν ορίσματα συναρτήσεων
Επιστροφή αντικειμένων από συναρτήσεις
Συναρτήσεις-μέλη ορισμένες έξω από την
Στατικά δεδομένα κλάσεων
Βασικές έννοιες πινάκων
Πίνακες σαν δεδομένα κλάσεων..
Υπερφόρτωση αριθμητικών τελεστών
Υπερφόρτωση τελεστών σύγκρισης..
Μετατροπή μεταξύ αντικειμένων και
Μετατροπή μεταξύ αντικειμένων
Συναρτήσεις εγκατάστασης της παράγωγης
Υπερφόρτωση συναρτήσεων-μελών...
Δείκτες και δομές
Δείκτες εντός δομών
Δείκτες για void...
Δείκτες και συναρτήσεις
Διαχείριση μνήμης: new και delete.
Δείκτες για αντικείμενα.
Πίνακες δεικτών προς αντικείμενα
Αρχεία και αντικείμενα
Πίνακας 2-1.
Τύποι δεδομένωνΠίνακας 2-2.
Ιεραρχία τύπων..
Πίνακας 2-3.
Λογικές πράξεις..
Πίνακας 7-1.
Πίνακας προσπελασιμότητας.
Πίνακας 8-1.
Πράξεις με δείκτες..
Ο αντικειμενοστραφής προγραμματισμός γεννήθηκε και άρχισε να αναπτύσσεται όταν πλέον ήταν φανερό ότι οι παραδοσιακές προσεγγίσεις στον προγραμματισμό δεν μπορούσαν να ανταποκριθούν στις νέες απαιτήσεις ανάπτυξης προγραμμάτων.
Επιπλέον, καθώς τα προγράμματα μεγάλωναν, γίνονταν υπερβολικά πολύπλοκα.
Διαπιστώθηκε ότι υπήρχαν αδυναμίες με τη χρήση διαδικαστικών γλωσσών προγραμματισμού (PASCAL, C, κλπ.).
Η κυριότερη αιτία είναι ότι οι διαδικαστικές γλώσσες δίνουν έμφαση στις ενέργειες που πρέπει να εκτελέσει ένα πρόγραμμα.
Η αντικειμενοστραφής σχεδίαση εκλαμβάνει σαν πρωτεύοντα δομικά στοιχεία ενός προγράμματος τα δεδομένα από τα οποία δημιουργούνται με κατάλληλη μορφοποίηση τα αντικείμενα (objects).
Αυτή η σχεδίαση αποδείχθηκε ότι επιφέρει καλύτερα αποτελέσματα, αφού τα προγράμματα που δημιουργούνται είναι περισσότερο ευέλικτα, επαναχρησιμοποιήσιμα και φιλικά.
Οι συναρτήσεις ενός αντικειμένου, που στη C++ ονομάζονται συναρτήσεις-μέλη (member functions), αποτελούν συνήθως το μόνο τρόπο για να προσπελάσουμε τα δεδομένα ενός αντικειμένου.
Τα δεδομένα είναι κρυμμένα και έτσι είναι ασφαλή από κάποια τυχαία αλλοίωσή τους.
Τα δεδομένα και οι συναρτήσεις τους θεωρούνται ενθυλακωμένα (encapsulated) σε μία ανεξάρτητη οντότητα.
Βασικά στοιχεία του αντικειμενοστραφούς προγραμματισμού αποτελούν τα αντικείμενα.
Το περιβάλλον στο οποίο ζούμε αποτελείται από αντικείμενα τα οποία μπορούμε εύκολα να αντιληφθούμε και να χειριστούμε.
Π.χ. ένα αυτοκίνητο, ένα σπίτι, ένας άνθρωπος κλπ.
Κάθε αντικείμενο έχει ένα σύνολο χαρακτηριστικών που προσδιορίζουν τη φυσική του υπόσταση.
Π.χ. ο άνθρωπος έχει όνομα, ύψος, χρώμα ματιών κλπ.
Τα χαρακτηριστικά ενός αντικειμένου καθορίζονται από τις τιμές των επιμέρους ιδιοτήτων τους, π.χ. το χρώμα του αυτοκινήτου είναι κόκκινο, το χρώμα των ματιών του ανθρώπου είναι καστανό κλπ.
Θα μπορούσαμε, επίσης, να ισχυριστούμε ότι κάθε αντικείμενο περιέχει και κανόνες συμπεριφοράς, ‘γνωρίζει’ δηλαδή πώς να αντιδράσει όταν μία ενέργεια ασκηθεί πάνω του, π.χ. όταν πατήσουμε το φρένο του αυτοκινήτου, αυτό σταματά, αν πατήσουμε το γκάζι επιταχύνει.
Στα προγράμματα, ένα αντικείμενο είναι η ομαδοποίηση κώδικα και δεδομένων, τα οποία χειριζόμαστε ενιαία.
Τα δεδομένα αποτελούν τα χαρακτηριστικά και οι ενέργειες καθορίζουν τη συμπεριφορά ενός αντικειμένου.
Οι ενέργειες αναφέρονται και ως μέθοδοι (methods).
Η ανάπτυξη μίας αντικειμενοστραφούς εφαρμογής συνίσταται από τη δημιουργία και το χειρισμό αντικειμένων.
Σε κάποια αντικειμενοστραφή περιβάλλοντα τα αντικείμενα της εφαρμογής μπορούν να δημιουργούνται είτε μέσω κώδικα, είτε με τη βοήθεια κατάλληλων γραφικών εργαλείων, ενώ σε άλλα περιβάλλοντα δημιουργούνται μόνο μέσω κώδικα.
Όλες οι γλώσσες προγραμματισμού έχουν ενσωματωμένους τύπους δεδομένων.
Π.χ. ο τύπος δεδομένων int (ακέραιος) είναι ήδη προκαθορισμένος στη C++ και στα προγράμματά μας μπορούμε να δηλώνουμε μεταβλητές αυτού του τύπου:
Με παρόμοιο τρόπο μπορούμε να ορίσουμε αντικείμενα της ίδιας κλάσης.
Η κλάση αποτελεί το πρότυπο και καθορίζει τα δεδομένα (ιδιότητες) και τις συναρτήσεις (συμπεριφορά) που θα περιληφθούν στα αντικείμενα αυτής της κλάσης.
Θα πρέπει να τονισθεί ότι ο ορισμός της κλάσης δε δημιουργεί κανένα αντικείμενο, όπως η απλή ύπαρξη ενός τύπου int δε δημιουργεί καμία μεταβλητή.
Συνεπώς, σε ένα αντικειμενοστραφές προγραμματιστικό περιβάλλον η υποστήριξη κλάσεων αποτελεί κυρίαρχο στοιχείο.
Η κλάση είναι η στατική περιγραφή ενός συνόλου παρόμοιων αντικειμένων.
Όλα τα αντικείμενα δημιουργούνται ως ακριβή αντίγραφα της κλάσης τους.
Η έννοια των κλάσεων οδηγεί στην έννοια της κληρονομικότητας.
Στην καθημερινή μας ζωή χρησιμοποιούμε την έννοια των κλάσεων που υποδιαιρούνται σε άλλες κλάσεις (υποκατηγορίες).
Για παράδειγμα, η κλάση των ζώων διαιρείται στα θηλαστικά, πτηνά, κλπ.
Η κλάση των τροχοφόρων διαιρείται σε επιβατικά, φορτηγά, λεωφορεία, κλπ.
Η βασική αρχή σ’ αυτή τη διαίρεση είναι ότι κάθε υποκατηγορία έχει κοινά χαρακτηριστικά με την κλάση από την οποία προέρχεται.
Για παράδειγμα, τα επιβατικά, τα φορτηγά, τα λεωφορεία έχουν όλα τροχούς και κινητήρα.
Αυτά είναι τα βασικά χαρακτηριστικά που καθορίζουν τα τροχοφόρα.
Εκτός απ’ αυτά τα χαρακτηριστικά, που είναι κοινά για όλα τα μέλη της αρχικής κλάσης, κάθε υποκατηγορία έχει και δικά της ιδιαίτερα χαρακτηριστικά.
Για παράδειγμα, τα λεωφορεία έχουν καθίσματα για πολλά άτομα, ενώ τα φορτηγά έχουν χώρο για μεταφορά φορτίων.
Με παρόμοιο τρόπο, σε μία αντικειμενοστραφή εφαρμογή, μία κλάση μπορεί να διαιρεθεί σε άλλες κλάσεις (υποκατηγορίες).
Στη C++ η αρχική κλάση ονομάζεται βασική κλάση (base class).
Απ’ αυτήν μπορούν να ορισθούν άλλες κλάσεις που έχουν κοινά χαρακτηριστικά μ’ αυτήν, αλλά έχουν επίσης και πρόσθετα δικά τους χαρακτηριστικά και ονομάζονται παράγωγες κλάσεις (derived classes).
Μία κλάση, αφού δημιουργηθεί, μπορεί να διανεμηθεί για να χρησιμοποιηθεί σε πολλά προγράμματα.
Αυτό καλείται επαναχρησιμοποίηση (reusability) και είναι σαν τις βιβλιοθήκες συναρτήσεων που χρησιμοποιούν οι διαδικαστικές γλώσσες.
Ωστόσο, στον αντικειμενοστραφή προγραμματισμό, με την έννοια της κληρονομικότητας δίνεται η δυνατότητα να επεκταθεί η έννοια της επαναχρησιμοποίησης.
Μπορούμε να πάρουμε μία υπάρχουσα κλάση και χωρίς να την τροποποιήσουμε, να προσθέσουμε σ’ αυτήν επιπλέον χαρακτηριστικά και δυνατότητες.
Η νέα κλάση θα κληρονομήσει τις δυνατότητες της παλιάς, αλλά μπορεί να χρησιμοποιήσει και τα νέα δικά της χαρακτηριστικά.
Γενικά, η ευκολία με την οποία το υπάρχον λογισμικό μπορεί να επαναχρησιμοποιηθεί είναι ένα μεγάλο πλεονέκτημα του αντικειμενοστραφούς προγραμματισμού.
Με το χαρακτηριστικό του πολυμορφισμού (polymorphism) δίνεται η δυνατότητα στο ίδιο αντικείμενο, όταν εκτελείται η εφαρμογή, να αναφέρεται σε διαφορετικές κλάσεις και να επιδρά διαφορετικά, σε διαφορετικά αντικείμενα.
Διαφορετικές κλάσεις μπορούν να έχουν συναρτήσεις (συμπεριφορές) με κοινό όνομα και ίδιο βασικό σκοπό, αλλά με διαφορετική εφαρμογή.
Για παράδειγμα, σε ένα αυτοκίνητο τα πεντάλ του γκαζιού και του φρένου υποστηρίζουν τη συνάρτηση πάτησε.
Η εφαρμογή όμως αυτής της λειτουργίας είναι διαφορετική σε κάθε πεντάλ.
Όταν ο οδηγός πατήσει το γκάζι, το αυτοκίνητο αναπτύσσει ταχύτητα, ενώ αν πατήσει το φρένο, το αυτοκίνητο σταματά.
Η C++ προέρχεται από τη γλώσσα C.
Για την ακρίβεια είναι ένα υπερσύνολο της C.
Κάθε σωστή πρόταση της C, είναι και πρόταση της C++.
Τα επιπλέον στοιχεία που προστέθηκαν στην C για να προκύψει η C++, είναι οι κλάσεις και τα αντικείμενα και γενικά ο αντικειμενοστραφής προγραμματισμός.
Επιπρόσθετα, η C++ έχει πολλά νέα χαρακτηριστικά που περιλαμβάνουν, κυρίως, μία βελτιωμένη προσέγγιση της εισόδου/εξόδου δεδομένων.
Ας εξετάσουμε το παρακάτω πρόγραμμα:
Το πρόγραμμα αποτελείται από μία συνάρτηση, τη main().
Η λέξη void υποδηλώνει ότι αυτή η συγκεκριμένη συνάρτηση δεν έχει επιστρεφόμενη τιμή.
Ένα πρόγραμμα C++ μπορεί να αποτελείται από πολλές συναρτήσεις, κλάσεις και άλλα στοιχεία προγράμματος, αλλά όταν εκτελείται, ο έλεγχος πάντα μεταβιβάζεται στη main().
Η συνάρτηση main() με τη σειρά της, μπορεί να περιέχει κλήσεις προς άλλες ανεξάρτητες συναρτήσεις.
Η πρώτη γραμμή του προγράμματος είναι μία οδηγία προ-επεξεργαστή (preprocessor directive), δηλαδή μία εντολή προς το μεταγλωττιστή και του λέει να παρεμβάλλει ένα άλλο αρχείο στο πηγαίο πρόγραμμα.
Το αναγνωριστικό cout είναι στην ουσία ένα αντικείμενο.
Έχει προκαθορισθεί να αντιστοιχεί στο ρεύμα καθιερωμένης εξόδου (standard output stream).
Το ρεύμα αναφέρεται στη ροή δεδομένων.
Το ρεύμα καθιερωμένης εξόδου κανονικά κατευθύνεται στην οθόνη, αν και μπορεί να κατευθυνθεί και προς άλλες συσκευές εξόδου.
Ο τελεστής << ονομάζεται τελεστής παρεμβολής (insertion) ή τοποθέτησης (put to).
Κατευθύνει τα περιεχόμενα της μεταβλητής που είναι στα δεξιά του, προς το αντικείμενο που είναι στα αριστερά του.
Μπορούν να χρησιμοποιηθούν σχόλια σε ένα πρόγραμμα με δύο τρόπους: // σχόλια μίας γραμμής
Ας εξετάσουμε πώς ένα πρόγραμμα πραγματοποιεί την είσοδο δεδομένων.
Το επόμενο πρόγραμμα ζητά από το χρήστη την ποσότητα και την τιμή μονάδος ενός προϊόντος, υπολογίζει και εμφανίζει την αξία αυτού του προϊόντος: cout << “Δώσε ποσότητα:”; cout << “Δώσε τιμή μονάδος:”; cout << “Η αξία του προϊόντος είναι:” << value;
Η πρόταση cin >> qty αναγκάζει το πρόγραμμα να περιμένει από το χρήστη να πληκτρολογήσει έναν αριθμό.
Ο αριθμός που δίνεται τοποθετείται στη μεταβλητή qty.
Η δεσμευμένη λέξη cin είναι ένα αντικείμενο, προκαθορισμένο στη C++ να αντιστοιχεί στο ρεύμα καθιερωμένης εισόδου.
Αυτό το ρεύμα αναπαριστά δεδομένα που έρχονται συνήθως από το πληκτρολόγιο.
Το >> είναι ο τελεστής που φέρνει την τιμή που βρίσκεται αριστερά του και την τοποθετεί στη μεταβλητή δεξιά του.
Είναι τελεστές που χρησιμοποιούνται με τον τελεστή << για να τροποποιούν ή να χειρίζονται τα δεδομένα ως προς τον τρόπο που θα εμφανιστούν.
Ας εξετάσουμε το παρακάτω πρόγραμμα που διαβάζει την ακτίνα, υπολογίζει και εμφανίζει την περίμετρο και το εμβαδόν ενός κύκλου: cout << “Δώσε την ακτίνα κύκλου:”; cout <<setw(12)<<“Περίμετρος:”<<setw(5)<<setprecision(2)<< perim << endl; cout << setw(12)<<“Εμβαδόν:” <<setw(5) <<setprecision(2) << area << endl;
Ο χειριστής setw καθορίζει το πλήθος των θέσεων στις οποίες θα εμφανιστεί η τιμή της μεταβλητής που ακολουθεί.
Ο χειριστής setprecision καθορίζει το πλήθος των δεκαδικών ψηφίων μετά την υποδιαστολή.
Ο χειριστής endl είναι ένας χειριστής που χρησιμοποιείται με τον τελεστή τοποθέτησης << και προκαλεί την αλλαγή γραμμής.
Πίνακας 2-1.
Τύποι δεδομένων
Η C++ είναι μία «επιεικής» γλώσσα προγραμματισμού, σε σχέση με άλλες, όταν χειρίζεται παραστάσεις που περιέχουν πολλούς διαφορετικούς τύπους δεδομένων.
Όταν δύο τελεσταίοι διαφορετικού τύπου εμφανίζονται στην ίδια παράσταση, η μεταβλητή κατώτερου τύπου μετατρέπεται στον τύπο της μεταβλητής ανώτερου τύπου.
Πίνακας 2-2.
Ιεραρχία τύπων Οι μετατροπές γίνονται χωρίς να φαίνονται και συνήθως δεν χρειάζεται να μας απασχολούν και πολύ, αφού η C++ κάνει αυτόματα αυτό που θέλουμε.
Όταν όμως αρχίσουμε να χρησιμοποιούμε αντικείμενα, όπου θα ορίζουμε δικούς μας τύπους δεδομένων στην ουσία, ίσως θέλουμε να χρησιμοποιήσουμε αυτούς τους νέους τύπους δεδομένων σε μικτές παραστάσεις, όπως ακριβώς χρησιμοποιούμε τις απλές μεταβλητές σε μικτές παραστάσεις.
Σε τέτοιες περιπτώσεις, θα πρέπει να δημιουργήσουμε τις δικές μας ρουτίνες μετατροπής, για να αλλάξουμε αντικείμενα του ενός τύπου σε αντικείμενα άλλου τύπου, γιατί ο μεταγλωττιστής δε θα το κάνει αυτόματα, όπως με τους ενσωματωμένους τύπους δεδομένων.
Προσαρμογές τύπων (casting) Αναφέρεται στις μετατροπές δεδομένων που καθορίζονται από τον προγραμματιστή, σε αντίθεση με τις αυτόματες μετατροπές δεδομένων που έχουν περιγραφεί.
x = (long(x) * 10) / 10 ; // προσαρμογή σε τύπο long
Η έξοδος του προγράμματος θα είναι:
Στην πρώτη παράσταση, χωρίς προσαρμογή, το γινόμενο x*10 είναι μεγάλο για να χωρέσει σε μεταβλητή τύπου int.
Στη δεύτερη παράσταση, ο τύπος της μεταβλητής μετατρέπεται σε long και έτσι το γινόμενο250000 χωράει στη μεταβλητή.
Βρόγχοι και αποφάσεις
Στην πραγματικότητα λίγα προβλήματα μπορούν να επιλυθούν με τον τρόπο της σειριακής/ακολουθιακής δομής ενεργειών.
Συνήθως τα προβλήματα έχουν κάποιες ιδιαιτερότητες και δεν ισχύουν τα ίδια βήματα για κάθε περίπτωση.
Η πλέον συνηθισμένη περίπτωση είναι να λαμβάνονται κάποιες αποφάσεις με βάση κάποια δεδομένα κριτήρια που μπορεί να είναι διαφορετικά για κάθε διαφορετικό στιγμιότυπο ενός προβλήματος.
Γενικά η διαδικασία της επιλογής περιλαμβάνει τον έλεγχο κάποιας συνθήκης που μπορεί να έχει δύο τιμές (Αληθής ή Ψευδής) και ακολουθεί η απόφαση εκτέλεσης κάποιας ενέργειας με βάση την τιμή της λογικής αυτής συνθήκης. 2η έκδοση (με την εντολή switch)
Σε πολλές περιπτώσεις η συνθήκη εμπεριέχει αποφάσεις που πιθανόν βασίζονται σε περισσότερα από ένα κριτήρια.
Ο συνδυασμός των κριτηρίων αυτών καθορίζει και τις ‘λογικές’ πράξεις που μπορούν να γίνουν μεταξύ διαφορετικών συνθηκών.
Πολύ συχνά στην καθημερινή ζωή κάποιες αποφάσεις βασίζονται σε συνδυασμούς κριτηρίων και λογικών πράξεων.
Η λογική πράξη ή είναι αληθής όταν οποιαδήποτε από δύο προτάσεις είναι αληθής.
Η λογική πράξη και είναι αληθής όταν και οι δύο προτάσεις είναι αληθείς, ενώ η λογική πράξη όχι είναι αληθής όταν η πρόταση που την ακολουθεί είναι ψευδής.
Ο επόμενος πίνακας δίνει τις τιμές των τριών λογικών πράξεων για όλους τους συνδυασμούς τιμών:
Πίνακας 2-3.
Λογικές πράξεις Η διαδικασία της επανάληψης είναι ιδιαίτερα συχνή, αφού πλήθος προβλημάτων μπορούν να επιλυθούν με κατάλληλες επαναληπτικές διαδικασίες.
Η λογική των επαναληπτικών διαδικασιών εφαρμόζεται στις περιπτώσεις όπου μια ακολουθία εντολών πρέπει να εφαρμοσθεί σε ένα σύνολο περιπτώσεων, που έχουν κάτι κοινό.
Οι επαναληπτικές διαδικασίες μπορεί να έχουν διάφορες μορφές και συνήθως εμπεριέχουν και συνθήκες επιλογών.
Γενικά υπάρχουν τρία σχήματα δομών επανάληψης, που υποστηρίζονται από τις περισσότερες γλώσσες προγραμματισμού.
Επαναληπτικό σχήμα με έλεγχο επανάληψης στην αρχή
Επαναληπτικό σχήμα με έλεγχο επανάληψης στο τέλος cout << “1.
ΕΙΣΑΓΩΓΗ” << endl; cout << “2.
ΔΙΑΓΡΑΦΗ” << endl; cout << “3.
ΕΜΦΑΝΙΣΗ” << endl; cout << “4.
ΕΞΟΔΟΣ” << endl; cout << “Δώσε επιλογή:”; case 1: cout << “ΕΙΣΑΓΩΓΗ”; case 2: cout << “ΔΙΑΓΡΑΦΗ”; case 3: cout << “ΕΜΦΑΝΙΣΗ”;
Επαναληπτικό σχήμα ορισμένων φορών επανάληψης
Το πρώτο σχήμα επαναληπτικής δομής (while) είναι το πιο γενικό και μπορεί να εκτελεσθεί από καθόλου μέχρι όσες φορές θέλουμε.
Το δεύτερο σχήμα της επαναληπτικής δομής (do-while) έχει το χαρακτηριστικό να εκτελείται οπωσδήποτε μία φορά, επειδή ο έλεγχος της συνθήκης τερματισμού γίνεται στο τέλος, γι’ αυτό και δεν χρησιμοποιείται πολύ.
Το τρίτο σχήμα επαναληπτικής δομής (for) χρησιμοποιείται όταν το πλήθος των επαναλήψεων είναι εκ των προτέρων γνωστό.
Βασικά στοιχεία συναρτήσεων Μία συνάρτηση είναι ένα αυτόνομο τμήμα προγράμματος που εκτελεί μία συγκεκριμένη λειτουργία.
Ένα πρόγραμμα στη C++ περιλαμβάνει κλάσεις οι οποίες περιέχουν διάφορες συναρτήσεις.
Το πρόγραμμα μπορεί να περιέχει κι άλλες συναρτήσεις, εκ των οποίων μία από αυτές πρέπει να είναι η main, γιατί η εκτέλεση ενός προγράμματος αρχίζει πάντοτε από αυτήν τη συνάρτηση.
Η χρήση μιας συνάρτησης σ’ ένα πρόγραμμα περιλαμβάνει τρεις φάσεις:
Στη φάση της δήλωσης μίας συνάρτησης, λέμε στο μεταγλωττιστή ότι θα χρησιμοποιήσουμε στο πρόγραμμά μας τη συνάρτηση.
Στη φάση του ορισμού περιγράφουμε τη λειτουργία της συνάρτησης (δηλ. γράφουμε τον κώδικά της).
Στη φάση της κλήσης χρησιμοποιούμε τη συνάρτηση (δηλ. εκτελούμε τον κώδικά της).
Ο ορισμός μιας συνάρτησης έχει τη γενική μορφή:
Όλες οι συναρτήσεις τελειώνουν και επιστρέφουν αυτόματα στη διαδικασία, από την οποία κλήθηκαν, όταν συναντήσουν το τελευταίο τους άγκιστρο.
Μαζί τους επιστρέφουν – συνήθως – και μία τιμή η οποία περικλείεται στην εντολή return.
Όταν όμως δεν επιθυμούμε μία συνάρτηση να επιστρέφει τιμή, τότε πρέπει να γράψουμε τη δεσμευμένη λέξη void αντί για τον τύπο δεδομένων επιστροφής.
Παράδειγμα συνάρτησης με επιστροφή τιμής Στο παρακάτω πρόγραμμα διαβάζονται δύο ακέραιοι και μεταβιβάζονται σε μία συνάρτηση, όπου αυτή με τη σειρά της υπολογίζει και επιστρέφει, με την εντολή return, το άθροισμά τους. cout << “Δώσε τον 1ο αριθμό:”; c = athroisma(a,b); // κλήση συνάρτησης cout << “Το άθροισμα των << a << “ και “ << b << “ είναι “ << c; int z; // τοπική μεταβλητή
Παρατηρούμε ότι όταν καλούμε τη συνάρτηση, γράφουμε το όνομά της και σε παρένθεση παραθέτουμε τα ονόματα των μεταβλητών, τις τιμές των οποίων θέλουμε να μεταβιβάσουμε στη συνάρτηση.
Επιπλέον, παρατηρούμε ότι η κλήση της συνάρτησης λαμβάνει χώρο στο δεξιό σκέλος μιας εντολής εκχώρησης
Αυτό είναι απαραίτητο κάθε φορά που μία συνάρτηση θα επιστρέφει τιμή με την εντολή return.
Στην επικεφαλίδα της συνάρτησης, μέσα σε παρένθεση, υπάρχουν οι παράμετροι x και y.
Αυτές είναι στην ουσία δύο αντίγραφα των μεταβλητών a και b και χρησιμοποιούνται για να υπολογιστεί το άθροισμα των a και b.
Άρα, οποιαδήποτε αλλαγή συμβεί στις τιμές των x και y, δεν επηρεάζει τις αρχικές τιμές των a και b.
Ο τρόπος αυτός κλήσης συνάρτησης – περνώντας δηλ. ως παραμέτρους τις τιμές των μεταβλητών με τις οποίες καλείται – ονομάζεται κλήση με τιμή (call by value).
Παράδειγμα συνάρτησης χωρίς επιστροφή τιμής Στο παρακάτω πρόγραμμα, η συνάρτηση athroisma δέχεται σε παραμέτρους τις τιμές δύο μεταβλητών, υπολογίζει το άθροισμά τους, αλλά δεν το επιστρέφει (το εμφανίζει η ίδια στον κώδικά της). athroisma(a,b); // κλήση συνάρτησης cout << “Το άθροισμα των << x << “ και “ << y << “ είναι “ << z;
Κλήσεις συναρτήσεων από συναρτήσεις Κατά την υλοποίηση της ιεραρχικής σχεδίασης ενός προγράμματος με τον τμηματικό προγραμματισμό, προκύπτει ένα πρόγραμμα με αυτόνομες λειτουργικές μονάδες (modules) σε διάφορα επίπεδα.
Κάθε λειτουργική μονάδα, υλοποιείται με μία συνάρτηση.
Κάθε φορά που ολοκληρώνεται η εκτέλεση μίας συνάρτησης, εκτελείται η αμέσως επόμενη συνάρτηση προς τα δεξιά, εφόσον δεν ξεκινά μία διαδρομή προς τα κάτω προς κάποιο άλλο επίπεδο.
Αν αυτό συμβαίνει, τότε εκτελούνται πρώτα οι συναρτήσεις του κατώτερου επιπέδου.
Η κλήση αυτών των συναρτήσεων πραγματοποιείται μέσα στον κώδικα της συνάρτησης του ανώτερου επιπέδου.
Για παράδειγμα, πρώτη εκτελείται η συνάρτηση Εισαγωγή δεδομένων.
Αυτή με τη σειρά της καλεί τη συνάρτηση Υπολογισμός μισθού και μετά εκτελείται η συνάρτηση Εμφάνισε αποτελέσματα.
Το παρακάτω πρόγραμμα υλοποιεί την προηγούμενη σχεδίαση.
Αναδρομή είναι η μέθοδος κατά την οποία, σε μία γλώσσα προγραμματισμού, μία διαδικασία ή συνάρτηση έχει την δυνατότητα να καλεί τον εαυτό της.
Η υλοποίηση της αναδρομής βασίζεται στη έννοια της στοίβας.
Σε κάθε κλήση μίας υπορουτίνας πρέπει να φυλάγονται οι διευθύνσεις επιστροφής.
Όταν μία υπορουτίνα καλεί τον εαυτό της θα πρέπει επίσης να φυλάγονται οι προηγούμενες τιμές των μεταβλητών και να χρησιμοποιούνται όταν τελειώσει η αναδρομική κλήση.
Η χρήση της αναδρομής διευκολύνει πολύ τον προγραμματιστή στην ανάπτυξη και τον έλεγχο ενός προγράμματος.
Θα πρέπει όμως να χρησιμοποιείται με μέτρο, γιατί η εκτέλεση ενός αναδρομικού προγράμματος έχει χρονικό κόστος.
Γενικά, ανάμεσα σε ένα επαναληπτικό και ένα αναδρομικό πρόγραμμα θα πρέπει να προτιμάμε το πρώτο, εκτός και αν η ανάπτυξή του μας δυσκολεύει ιδιαίτερα.
Η αναδρομή ενδείκνυται σε προβλήματα κάποιας σχετικής πολυπλοκότητας, που εξ’ ορισμού τα εκφράζουμε αναδρομικά.
Ας παρακολουθήσουμε τις τιμές των μεταβλητών κατά την κλήση των δύο συναρτήσεων , π.χ. για n = 4:
Ακολούθως, η τελευταία τιμή 1 μεταβιβάζεται στην προηγούμενη κλήση και έτσι υπολογίζεται το factorial(1) = 1.
Κατά τον ίδιο τρόπο έχουμε
Δείκτες και συναρτήσεις Επειδή η C μεταβιβάζει την τιμή των ορισμάτων, η καλούμενη συνάρτηση δεν έχει άμεσο τρόπο για να αλλάξει μια μεταβλητή στην καλούσα συνάρτηση.
Για παράδειγμα, μία μέθοδος ταξινόμησης μπορεί να εναλλάξει δύο στοιχεία, που δεν είναι στη σειρά τους, με μία συνάρτηση που λέγεται swap.
όπου η συνάρτηση swap ορίζεται ως εξής η συνάρτηση δεν μπορεί να εναλλάξει τις τιμές των ορισμάτων a και b, αλλά εναλλάσσει μόνο τα αντίγραφά τους x και y, λόγω της κλήσης με τιμή (call by value).
Για να πετύχουμε την εναλλαγή των τιμών των a και b, θα πρέπει κατά την κλήση της συνάρτησης να μεταβιβάσουμε δείκτες για τις τιμές που θα αλλαχθούν:
Αφού ο τελεστής & δίνει τη διεύθυνση μιας μεταβλητής, τότε οι &a και &b αποδίδονται σε παραμέτρους, που έχουν δηλωθεί στη συνάρτηση σαν δείκτες και η προσπέλαση των τιμών των μεταβλητών a και b γίνεται μέσω αυτών των δεικτών.
Η προηγούμενη μέθοδος κλήσης συνάρτησης με χρήση δεικτών αν και είναι αποτελεσματική, πολλές φορές είναι ιδιαίτερα πολύπλοκη.
Η C++ μας προσφέρει έναν εναλλακτικό τρόπο όταν θέλουμε να αλλάξουμε τις αρχικές μεταβλητές στο πρόγραμμα που κάλεσε την συνάρτηση.
Η νέα μέθοδος είναι η κλήση με αναφορά.
Η αναφορά δίνει ένα ψευδώνυμο –διαφορετικό όνομα- σε μία μεταβλητή.
Έτσι, όταν καλείται μία συνάρτηση, αντί να μεταβιβάζεται στη συνάρτηση μία τιμή ή η διεύθυνσή της, μεταβιβάζεται η αναφορά στην αρχική μεταβλητή του καλούντος προγράμματος.
Το κύριο πλεονέκτημα της μεταβίβασης με αναφορά είναι ότι η συνάρτηση μπορεί να προσπελάσει τις πραγματικές μεταβλητές στο καλούν πρόγραμμα.
Μεταξύ άλλων, ο τρόπος αυτός παρέχει ένα μηχανισμό για την επιστροφή πολλών τιμών από τη συνάρτηση προς το πρόγραμμα. // τα x και y είναι αναφορές στις αρχικές μεταβλητές a και b.
Δεν θα πρέπει να υπάρχει σύγχυση με το σύμβολο & που σημαίνει αναφορά στη μεταβλητή με το ίδιο σύμβολο που σημαίνει διεύθυνση της μεταβλητής.
Οι δύο αυτές χρήσεις είναι διαφορετικές, όπως μας δείχνει και το παρακάτω παράδειγμα: int a, &x=a, *d; // το x είναι αναφορά στην μεταβλητή a // το d είναι δείκτης σε ακέραιο d = &a; // η διεύθυνση του a αποδίδεται στο d
Μία συνάρτηση με υπερφόρτωση (overloading) φαίνεται ότι εκτελεί διαφορετικές δραστηριότητες ανάλογα με τα δεδομένα που της στέλνονται.
Έστω ότι θέλουμε να έχουμε σε κάποιο πρόγραμμα τις εξής συναρτήσεις:
Η συνάρτηση αυτή όταν καλείται τυπώνει σε μία γραμμή 45 αστερίσκους.
Η συνάρτηση αυτή τυπώνει 45 χαρακτήρες σε μία γραμμή.
Ο χαρακτήρας που θα τυπωθεί καθορίζεται στην κλήση της συνάρτησης.
Η συνάρτηση αυτή τυπώνει χαρακτήρες σε μία γραμμή.
Ο χαρακτήρας που θα τυπωθεί αλλά και το πλήθος του καθορίζονται στην κλήση της συνάρτησης.
Αυτές οι τρεις συναρτήσεις φαίνεται να εκτελούν παρόμοιες δραστηριότητες, αλλά έχουν διαφορετικά ονόματα.
Αυτό σημαίνει ότι αν χρησιμοποιηθούν και οι τρεις σε ένα πρόγραμμα, οι προγραμματιστές πρέπει να θυμούνται και τα τρία ονόματα.
Θα ήταν ίσως πιο εξυπηρετικό αν χρησιμοποιούσαμε και για τις τρεις το ίδιο όνομα.
Αυτό φαίνεται στο παρακάτω πρόγραμμα:
Η έξοδος του προγράμματος είναι:
Το πρόγραμμα περιλαμβάνει τρεις συναρτήσεις με το ίδιο όνομα.
Υπάρχουν τρεις δηλώσεις, τρεις ορισμοί και τρεις κλήσεις των συναρτήσεων αυτών με το ίδιο όνομα.
Ο μεταγλωττιστής χρησιμοποιεί το πλήθος των ορισμάτων και τον τύπο δεδομένων τους για να τις διακρίνει τη μία από την άλλη.
Ο μεταγλωττιστής μπορεί επίσης να διακρίνει μεταξύ συναρτήσεων με υπερφόρτωση με το ίδιο πλήθος ορισμάτων, αρκεί ο τύπος τους να είναι διαφορετικός. cout << “Οι χαρακτήρες είναι:” << endl; cout << “Οι ακέραιοι είναι:” << endl;
Εδώ έχουμε δύο συναρτήσεις με το ίδιο όνομα και το ίδιο πλήθος ορισμάτων, αλλά διαφορετικού τύπου.
Ποια από τις δύο συναρτήσεις θα εκτελεσθεί εξαρτάται από τον τύπο δεδομένων των ορισμάτων όταν καλείται η συνάρτηση.
Σαν συμπέρασμα μπορούμε να πούμε ότι οι συναρτήσεις με υπερφόρτωση απλοποιούν τη ζωή του προγραμματιστή, μειώνοντας τον αριθμό των ονομάτων των συναρτήσεων που πρέπει να θυμάται.
Αργότερα θα δούμε ότι τέτοιες συναρτήσεις είναι επίσης χρήσιμες για το χειρισμό για το χειρισμό αντικειμένων διαφορετικών τύπων.
Μία συνάρτηση μπορεί να κληθεί χωρίς να καθοριστούν όλα της τα ορίσματα.
Θα πρέπει όμως η δήλωση της συνάρτησης να παρέχει προεπιλεγμένες τιμές για εκείνα τα ορίσματα που δεν καθορίζονται.
Σαν παράδειγμα ας εξετάσουμε μία διαφορετική εκδοχή του προηγούμενου προγράμματος:
Η συνάρτηση, όπως βλέπουμε, έχει δύο ορίσματα με προεπιλεγμένες τιμές και καλείται τρεις φορές, την πρώτη χωρίς τιμές στα ορίσματα, τη δεύτερη με μία τιμή και την τρίτη με δύο τιμές.
Έτσι, όταν καλείται η συνάρτηση, αν λείπει κάποιο όρισμα, τότε θεωρείται ότι είναι το τελευταίο (η συνάρτηση αποδίδει το χαρακτήρα ‘+’ στην παράμετρο ch και χρησιμοποιεί την προεπιλεγμένη τιμή 45 για την παράμετρο n).
Αν λείπουν και τα δύο ορίσματα, οι συνάρτηση αποδίδει και τις δύο προεπιλεγμένες τιμές στις παραμέτρους.
Θα πρέπει να τονισθεί ότι τα ορίσματα που λείπουν πρέπει να είναι τα τελευταία στη λίστα και ούτε μπορούμε να παραλείψουμε ενδιάμεσα ορίσματα.
Το παρακάτω πρόγραμμα περιέχει μία κλάση και δύο αντικείμενα αυτής της κλάσης.
Αν και απλό, το πρόγραμμα δείχνει τη βασική δομή και τα γενικά χαρακτηριστικά των κλάσεων της C++.
Person p1, p2; // δήλωση δύο αντικειμένων p1.readData(); // κλήση συνάρτησης-μέλους για ορισμό δεδομένων p1.printData(); // κλήση συνάρτησης μέλους για εμφάνιση δεδομένων
Η κλάση Person περιέχει δύο στοιχεία δεδομένων και δύο συναρτήσεις μέλη.
Αυτές οι δύο συναρτήσεις παρέχουν μοναδική πρόσβαση στα στοιχεία δεδομένων έξω από την κλάση.
Η πρώτη συνάρτηση-μέλος μας δίνει τη δυνατότητα να πληκτρολογήσουμε δύο τιμές και να τις αποδώσουμε άμεσα στα στοιχεία δεδομένων και η δεύτερη συνάρτηση-μέλος εμφανίζει αυτές τις τιμές.
Η τοποθέτηση των δεδομένων και των συναρτήσεων μαζί, σε μία ενότητα, είναι η κεντρική ιδέα του αντικειμενοστραφούς προγραμματισμού.
Private και public Το σώμα της κλάσης περιέχει δύο άγνωστες δεσμευμένες λέξεις: private και public.
Ένα βασικό χαρακτηριστικό του αντικειμενοστραφούς προγραμματισμού, όπως προαναφέρθηκε, είναι η απόκρυψη δεδομένων (data hiding).
Αυτό έχει σαν σκοπό τα δεδομένα να είναι κρυμμένα μέσα σε μία κλάση, έτσι ώστε να μην είναι προσπελάσιμα από συναρτήσεις που είναι έξω από την κλάση.
Ο κύριος μηχανισμός είναι να βάλουμε τα δεδομένα κάτω από την ένδειξη private (ιδιωτικά).
Τα ιδιωτικά δεδομένα ή συναρτήσεις προσπελάζονται μόνο μέσα από την κλάση.
Αντιθέτως, τα δημόσια (public) δεδομένα, προσπελάζονται και έξω από τις κλάσεις.
Συνήθως, τα δεδομένα μέσα σε μία κλάση είναι ιδιωτικά και οι συναρτήσεις είναι δημόσιες.
Η πρόταση στη main() ορίζει δύο αντικείμενα της κλάσης Person.
Να τονίσουμε ότι όπως σε μία δομή, όταν την ορίζουμε, δε δημιουργούμε καμία μεταβλητή δομής, έτσι και με την κλάση, όταν την ορίζουμε, δε δημιουργούμε αντικείμενα, απλά περιγράφουμε πως θα είναι αυτά όταν δημιουργηθούν.
Τα αντικείμενα πραγματικά δημιουργούνται όταν ορίζονται σύμφωνα με την παραπάνω πρόταση.
Κλήση συναρτήσεων-μελών Οι επόμενες προτάσεις καλούν τη συνάρτηση-μέλος readData():
Για να καλέσουμε μία συνάρτηση-μέλος μίας κλάσης, τη συνδέουμε με μία τελεία με κάποιο αντικείμενο.
Αντικείμενο.συνάρτηση-μέλος Η σύνταξη είναι παρόμοια με τον τρόπο που αναφερόμαστε στα μέλη μίας δομής, με τις παρενθέσεις να υποδηλώνουν όμως ότι αναφερόμαστε σε συνάρτηση-μέλος και όχι σε στοιχείο δεδομένων.
Η πρώτη κλήση στη readData() εκτελεί τη συνάρτηση-μέλος readData() του αντικειμένου p1.
Ακολούθως, εκτελείται ο κώδικας της συνάρτησης όπου πληκτρολογούνται, από το χρήστη, τιμές για το όνομα και την ηλικία του ατόμου και αποδίδονται στα δεδομένα του αντικειμένου name και age αντίστοιχα. εκτελεί τη συνάρτηση-μέλος για το αντικείμενο p2.
Αντικείμενα της κλάσης Person Παρόμοια, οι δύο επόμενες κλήσεις της συνάρτησης printData() υποχρεώνουν τα δύο αντικείμενα να εμφανίσουν τις τιμές τους:
Απόδοση τιμών μέσω παραμέτρων Στο προηγούμενο πρόγραμμα, η απόδοση τιμών στα δεδομένα των αντικειμένων γίνεται με την πληκτρολόγησή τους από το χρήστη.
Ένας εναλλακτικός τρόπος απόδοσης τιμών είναι να δοθούν οι τιμές σε παραμέτρους, κατά την κλήση της συνάρτησης-μέλους.
Ας εξετάσουμε το παρακάτω πρόγραμμα:
Στο πρόγραμμα αυτό ορίζεται ένα αντικείμενο p.
Ακολούθως, με την πρόταση καλείται η συνάρτηση-μέλος setData(), στην οποία μεταβιβάζονται οι τιμές “PAPADOPOULOS “ και 25 στις παραμέτρους name1 και age1 της συνάρτησης αντίστοιχα.
Τέλος, όταν εκτελείται ο κώδικας της συνάρτησης, οι τιμές αυτών των παραμέτρων αποδίδονται στα δεδομένα του αντικειμένου.
Συναρτήσεις εγκατάστασης (constructors) Μέχρι στιγμής έχουμε δει δύο τρόπους για να δίνουμε τιμές σε στοιχεία δεδομένων ενός αντικειμένου.
Μερικές φορές, ωστόσο, είναι πιο βολικό για ένα αντικείμενο να παίρνει αρχικές τιμές άμεσα, την πρώτη φορά που δημιουργείται, χωρίς να χρειάζεται να καλέσουμε μία ξεχωριστή συνάρτηση-μέλος.
Η αυτόματη απόδοση αρχικών τιμών πραγματοποιείται με τη χρήση μίας ειδικής συνάρτησης-μέλους που λέγεται συνάρτηση εγκατάστασης ή κατασκευαστής (constructor).
Η συνάρτηση εγκατάστασης είναι μία συνάρτηση-μέλος που εκτελείται αυτόματα, όποτε δημιουργείται ένα αντικείμενο.
Στο πρόγραμμα που ακολουθεί, ορίζεται μία κλάση Account με ένα στοιχείο δεδομένων balance, που αναφέρεται στο τρέχον ποσό ενός λογαριασμού.
Ορίζονται, επίσης, δύο συναρτήσεις-μέλη για την ανάληψη και την κατάθεση χρημάτων στο λογαριασμό και μία συνάρτηση-μέλος που επιστρέφει, κατά την κλήση της, το τρέχον ποσό λογαριασμού.
Είναι εξυπηρετικό, για την εφαρμογή, το τρέχον ποσό λογαριασμού να αρχικοποιηθεί στο 0.
Αυτό επιτυγχάνεται, κατά τη δημιουργία ενός αντικειμένου, με τη συνάρτηση εγκατάστασης Account(), η οποία εκτελείται αυτόματα. cout << “Το ποσό ανάληψης υπερβαίνει το τρέχον!” << endl; cout << “Τρέχον ποσό λογαριασμού:” << ac.getBalance() << endl;
Παρατηρούμε ότι οι συναρτήσεις εγκατάστασης έχουν το ίδιο όνομα με την κλάση της οποίας είναι μέλη.
Επίσης, δε χρησιμοποιείται τύπος επιστροφής.
Συναρτήσεις αποσύνδεσης (destructors) Μία συνάρτηση εγκατάστασης, όπως είδαμε, καλείται αυτόματα όταν δημιουργείται ένα αντικείμενο.
Μπορούμε, αντίστοιχα, να ορίσουμε μία συνάρτηση αποσύνδεσης ή καταστροφέα (destructor), η οποία θα καλείται αυτόματα όταν ένα αντικείμενο καταστρέφεται.
Η συνάρτηση αποσύνδεσης έχει το ίδιο όνομα με την κλάση, έχοντας μπροστά μία περισπωμένη ~.
Η πιο συνηθισμένη χρήση των συναρτήσεων αποσύνδεσης είναι η αποδέσμευση της μνήμης που είχε δεσμευτεί για ένα αντικείμενο από τη συνάρτηση εγκατάστασης.
Συναρτήσεις εγκατάστασης με υπερφόρτωση
Μερικές φορές είναι βολικό να δίνουμε αρχικές τιμές στα δεδομένα ενός αντικειμένου όταν δημιουργείται, μέσω όμως παραμέτρων των συναρτήσεων εγκατάστασης. // συνάρτηση εγκατάστασης χωρίς ορίσματα
Account(float balance1) // συνάρτηση εγκατάστασης με όρισμα cout << “Τρέχον ποσό λογαριασμού ac1:” << ac1.getBalance() << endl;
Στο προηγούμενο παράδειγμα ορίζονται δύο συναρτήσεις εγκατάστασης, μία με ορίσματα και μία χωρίς όρισμα.
Κατά τη δήλωση δημιουργούνται τρία αντικείμενα.
Στο πρώτο γίνεται χρήση της συνάρτηση εγκατάστασης χωρίς όρισμα και που ουσιαστικά δεν κάνει τίποτε.
Στα δύο επόμενα αντικείμενα γίνεται χρήση της συνάρτηση εγκατάστασης με το όρισμα balance1, στο οποίο μεταβιβάζονται οι τιμές 50.0 και 100.0 αντίστοιχα και αποδίδονται στα στοιχεία δεδομένων των δύο αντικειμένων.
Θα πρέπει να τονισθεί ότι όταν ορισθεί μία συνάρτηση εγκατάστασης με ορίσματα, θα πρέπει απαραιτήτως να ορισθεί και μία συνάρτηση εγκατάστασης χωρίς ορίσματα.
Οι δύο συναρτήσεις έχουν το ίδιο όνομα – το όνομα της κλάσης – και θεωρούμε ότι η συνάρτηση εγκατάστασης έχει υποστεί υπερφόρτωση (overloading).
Το ποια συνάρτηση εγκατάστασης εκτελείται όταν δημιουργείται ένα αντικείμενο, εξαρτάται από τον αριθμό των ορισμάτων που χρησιμοποιούνται στον ορισμό του αντικειμένου.
Αντικείμενα σαν ορίσματα συναρτήσεων Στο πρόγραμμα που ακολουθεί, ορίζεται μία συνάρτηση-μέλος addBalance(), η οποία έχει σα στόχο να προσθέσει τα ποσά δύο διαφορετικών λογαριασμών.
cout << “Συνολικό ποσό λογαριασμών:” << ac3.getBalance() << endl;
Η κλήση συνάρτησης μέσα στη main() μεταβιβάζει τα αντικείμενα ac1 και ac2 στις παραμέτρους της συνάρτησης x και y αντίστοιχα.
Στον κώδικα της συνάρτησης γίνεται αναφορά στα δεδομένα των αντικειμένων x.balance και y.balance.
Αυτό είναι εφικτό, γιατί, αν και τα δεδομένα είναι ιδιωτικά, εντούτοις είναι προσπελάσιμα γιατί η συνάρτηση είναι μέλος της κλάσης.
Τα δεδομένα προστίθενται και το αποτέλεσμα αποδίδεται στο δεδομένο του αντικειμένου το οποίο καλεί τη συνάρτηση-μέλος, που είναι το ac3.
Οι συναρτήσεις-μέλη του ac3 μπορούν να αναφέρονται άμεσα στα δεδομένα του
Η αναφορά στα δεδομένα των αντικειμένων που μεταβιβάζονται σαν ορίσματα γίνεται με τον τελεστή της τελείας
Επιστροφή αντικειμένων από συναρτήσεις Στο προηγούμενο παράδειγμα είδαμε πώς αντικείμενα μεταβιβάζονται σαν ορίσματα σε συναρτήσεις.
Στο παράδειγμα που ακολουθεί θα δούμε μία συνάρτηση που επιστρέφει ένα αντικείμενο.
Το παραπάνω πρόγραμμα πετυχαίνει ότι ακριβώς και το προηγούμενο, δηλαδή προσθέτει δύο λογαριασμούς και το συνολικό ποσό αποδίδεται σε ένα τρίτο αντικείμενο, μόνο που χρησιμοποιεί μία διαφορετική προσέγγιση.
Στο τελευταίο πρόγραμμα, στη συνάρτηση addBalance() μεταβιβάζεται μόνο το ένα αντικείμενο σαν όρισμα, π.χ το ac2 μεταβιβάζεται στην παράμετρο ac.
Η τιμή του δεδομένου αυτού του αντικειμένου προστίθεται στην τιμή του δεδομένου του αντικειμένου στο οποίο η συνάρτηση είναι μέλος – δηλαδή του αντικειμένου με το οποίο καλείται η συνάρτηση – που είναι το ac1.
Το αποτέλεσμα αποδίδεται σε ένα προσωρινό αντικείμενο temp, που ορίζεται μέσα στη συνάρτηση.
Τέλος, με την εντολή return, το προσωρινό αντικείμενο επιστρέφεται από τη συνάρτηση στο καλούν πρόγραμμα και αποδίδεται στο αντικείμενο ac3.
Η κλήση της συνάρτησης πραγματοποιείται στην πρόταση
Τα δεδομένα στο temp αποδίδονται στο ac3 με χρήση της πρότασης return temp;
Συναρτήσεις-μέλη ορισμένες έξω από την κλάση Στα παραδείγματα που εξετάσαμε μέχρι στιγμής είδαμε ότι όλες οι συναρτήσεις-μέλη είχαν οριστεί μέσα στην κλάση.
Εναλλακτικά, όμως, μπορούμε να διατηρήσουμε μέσα στην κλάση τις δηλώσεις όλων των συναρτήσεων μελών και να τις ορίσουμε έξω από την κλάση.
Αυτό θα ήταν, ίσως, προτιμότερο σε μία εφαρμογή που ο αριθμός των συναρτήσεων-μελών είναι μεγάλος, γιατί θα μας βοηθούσε να ελέγχουμε καλύτερα την κλάση.
Σε μια τέτοια, όμως, περίπτωση θα πρέπει στον ορισμό της συνάρτησης να αναφέρουμε και την κλάση στην οποία ανήκει:
Account::Account(float balance1) // συνάρτηση εγκατάστασης με όρισμα
Στον ορισμό αυτό μίας συνάρτησης παρεμβάλλεται το όνομα της κλάσης και το σύμβολο ::, που ονομάζεται τελεστής διάκρισης εμβέλειας (scope resolution operator), που είναι ένας τρόπος για να καθορίζουμε σε ποια κλάση ανήκει μία συνάρτηση.
Στατικά δεδομένα κλάσης Όταν τα δεδομένα μίας κλάσης ορίζονται ιδιωτικά (private), τότε κάθε νέο αντικείμενο που δημιουργείται έχει ένα ξεχωριστό αντίγραφο που περιέχει τα δικά του δεδομένα.
Αν όμως κάποιο στοιχείο δεδομένων ορισθεί σαν στατικό (static), τότε δημιουργείται ένα μόνο αντίγραφο για όλη την κλάση, άσχετα από τον αριθμό των αντικειμένων που υπάρχουν. ΄Ένα στατικό στοιχείο δεδομένων είναι χρήσιμο όταν όλα τα αντικείμενα της ίδιας κλάσης μοιράζονται μία κοινή πληροφορία.
Για παράδειγμα, στο πρόγραμμα με τους λογαριασμούς μπορούμε να ορίσουμε ένα στατικό στοιχείο δεδομένων count στην κλάση Account, έτσι ώστε κάθε αντικείμενο να δύναται να γνωρίζει πόσα άλλα αντικείμενα υπάρχουν.
Όλα τα αντικείμενα θα έχουν πρόσβαση στο δεδομένο αυτό και θα βλέπουν την ίδια μέτρηση.
cout << “Αριθμός πελατών:” << ac1.getCount() << endl;
Οι συναρτήσεις εγκατάστασης της κλάσης Account προκαλούν αύξηση του στατικού στοιχείου δεδομένων count.
Στη main() ορίζονται τρία αντικείμενα και κατά συνέπεια η count αυξάνεται τρεις φορές.
Καλώντας τη συνάρτηση getCount() και από τα τρία αντικείμενα που δημιουργούνται, παίρνουμε την τιμή της count, που είναι 3 για όλα τα αντικείμενα.
Αν χρησιμοποιούσαμε την count σαν κοινή μεταβλητή, τότε κάθε συνάρτηση εγκατάστασης θα την αύξανε κατά 1 στο δικό της αντίγραφο και θα παίρναμε αυτή την τιμή για κάθε ξεχωριστό αντικείμενο.
Βασικές έννοιες πινάκων Οι πίνακες κατατάσσονται στις στατικές δομές δεδομένων.
Με τον όρο στατική δομή δεδομένων εννοείται ότι το ακριβές μέγεθος της απαιτούμενης κύριας μνήμης καθορίζεται κατά τη στιγμή του προγραμματισμού τους, και κατά συνέπεια κατά τη στιγμή της μετάφρασης του προγράμματος και όχι κατά τη στιγμή της εκτέλεσής του.
Ένα άλλο χαρακτηριστικό των πινάκων είναι ότι τα στοιχεία τους αποθηκεύονται σε συνεχόμενες θέσεις μνήμης.
Μπορούμε να ορίσουμε τον πίνακα ως μια δομή που περιέχει στοιχεία του ίδιου τύπου (δηλαδή ακέραιους, πραγματικούς κλπ.).
Η δήλωση των στοιχείων ενός πίνακα και η μέθοδος αναφοράς τους εξαρτάται από τη συγκεκριμένη γλώσσα υψηλού επιπέδου που χρησιμοποιείται.
Όμως γενικά η αναφορά στα στοιχεία ενός πίνακα γίνεται με τη χρήση του συμβολικού ονόματος του πίνακα ακολουθούμενου από την τιμή ενός ή περισσοτέρων δεικτών (indexes) σε παρένθεση ή αγκύλη.
Ένας πίνακας μπορεί να είναι μονοδιάστατος, αλλά γενικά μπορεί να είναι δισδιάστατος, τρισδιάστατος και γενικά ν-διάστατος πίνακας.
Στη C++ επιτρέπεται ο ορισμός πινάκων οποιασδήποτε διάστασης, αλλά πέραν της δεύτερης, η χρήση τους ενέχει τέτοια ποικιλία προβλημάτων, ώστε να είναι αποτρεπτική.
Για το λόγο αυτό, κυρίως θα ασχοληθούμε με μονοδιάστατους (one-dimensional) πίνακες και δισδιάστατους (two-dimensional) πίνακες.
Ορισμός μονοδιάστατου πίνακα ακεραίων
Διάβασμα μονοδιάστατου πίνακα.
Εμφάνιση μονοδιάστατου πίνακα.
Άθροισμα στοιχείων μονοδιάστατου πίνακα.
Το παρακάτω πρόγραμμα διαβάζει δέκα ακέραιους από το πληκτρολόγιο και εμφανίζει το πλήθος των άρτιων και το πλήθος των περιττών. cout << “Πλήθος άρτιων = ” << art << endl; cout << “Πλήθος περιττών = ” << per << endl;
Μπορούμε να φανταστούμε ένα δισδιάστατο πίνακα σαν ένα μονοδιάστατο πίνακα, όπου σε κάθε θέση του περιέχεται ένας νέος μονοδιάστατος πίνακας.
Προτιμότερο όμως είναι να τον φανταστούμε σαν ένα σύνολο από μονοδιάστατους πίνακες, τοποθετημένοι ο ένας πάνω στον άλλο, συνθέτοντας ένα πίνακα από γραμμές και στήλες.
Για την επεξεργασία ενός δισδιάστατου πίνακα χρησιμοποιούμε το όνομα του πίνακα και δύο ακέραιους δείκτες, έναν για τις γραμμές και έναν για τις στήλες.
Ορισμός δισδιάστατου πίνακα ακεραίων
Διάβασμα δισδιάστατου πίνακα.
Εμφάνιση δισδιάστατου πίνακα.
Άθροισμα στοιχείων δισδιάστατου πίνακα.
Άθροισμα στοιχείων δισδιάστατου πίνακα κατά γραμμή.
Άθροισμα στοιχείων δισδιάστατου πίνακα κατά στήλη.
Το παρακάτω πρόγραμμα χρησιμοποιεί τρεις πίνακες ως εξής: · Ένα μονοδιάστατο πίνακα 5 θέσεων όπου βρίσκονται καταχωρημένα τα ονόματα 5 πόλεων · Ένα μονοδιάστατο πίνακα 12 θέσεων όπου βρίσκονται καταχωρημένα τα ονόματα των 12 μηνών · Ένα δισδιάστατο πίνακα 5x12 όπου βρίσκονται καταχωρημένοι οι μέσοι όροι θερμοκρασίας που καταγράφηκαν σε κάθε πόλη για κάθε μήνα.
Κατόπιν, το πρόγραμμα εμφανίζει τις θερμοκρασίες όλων των πόλεων για κάθε μήνα, και βρίσκει και εμφανίζει την ελάχιστη θερμοκρασία, τη μέγιστη θερμοκρασία, σε ποια πόλη καταγράφηκαν και ποιο μήνα.
Πίνακες σαν δεδομένα κλάσεων Οι πίνακες μπορούν να χρησιμοποιηθούν σαν στοιχεία δεδομένων στις κλάσεις.
Ας εξετάσουμε ένα παράδειγμα, όπου ορίζεται μία κλάση με το όνομα Student και δεδομένα τον αριθμό μητρώου ενός σπουδαστή και έναν πίνακα όπου αποθηκεύονται 8 βαθμολογίες του για 8 αντίστοιχα μαθήματα.
cout << “Δώσε βαθμούς:”; cout << “Μέσος όρος βαθμολογίας = ” << s1.getAvg() << endl; cout << “Μεγαλύτερη βαθμολογία = ” << s1.getMax() << endl; cout << “Μικρότερη βαθμολογία = ” << s1.getMin() << endl;
Όπως ένα αντικείμενο μπορεί να περιέχει έναν πίνακα, μπορεί να ισχύει και το αντίστροφο, δηλαδή να έχουμε έναν πίνακα που να περιέχει αντικείμενα. cout << “Δώσε όνομα:”; cout << “Δώσε μισθό:”; cout << “Όνομα: “ << name << endl; cout << “Μισθός: “ << misthos << endl; cout << “Δώσε πληροφορίες για “ << N << “ εργαζόμενους:” << endl; cout << endl << “Εργαζόμενος ” << i+1 << “:” << endl; cout << “Δώσε Α.Μ. για αναζήτηση:”; cout << “Ο συγκεκριμένος εργαζόμενος δεν υπάρχει.” << endl;
Στο προηγούμενο πρόγραμμα ορίζεται ένας πίνακας αντικειμένων emp τύπου Employee.
Ύστερα, με μία δομή επανάληψης for, πληκτρολογούνται πληροφορίες για κάθε ένα από τα 10 αντικείμενα του πίνακα, με την κλήση της συνάρτησης readData().
Τέλος, πληκτρολογείται ένας τυχαίος αριθμός μητρώου και αναζητείται στον πίνακα αντικειμένων.
Αν υπάρχει, εμφανίζονται οι πληροφορίες για το συγκεκριμένο εργαζόμενο.
Η υπερφόρτωση τελεστών (operator overloading) είναι ένα από τα πιο συναρπαστικά χαρακτηριστικά του αντικειμενοστραφούς προγραμματισμού.
Αναφέρεται στην πρόσθετη χρήση των συνηθισμένων τελεστών, όπως π.χ. +, -, *, >, <, ==, σε τύπους δεδομένων ορισμένους από το χρήστη.
Μέχρι τώρα, προτάσεις όπως έχουμε δει να χρησιμοποιούνται μόνο σε βασικούς τύπους δεδομένων, όπως οι int και float.
Με την υπερφόρτωση τελεστών θα δούμε πώς μπορούμε να εκτελέσουμε τέτοιες προτάσεις, όταν τα a, b και c είναι αντικείμενα μίας κλάσης.
Επίσης, μία άλλη λειτουργία που θα δούμε είναι η μετατροπή τύπων δεδομένων (data type conversion), την οποία έχουμε δει να εφαρμόζεται αυτόματα σε απλούς τύπους όπως οι int και float.
Εδώ, θα δούμε πώς μπορεί να επιτευχθεί μετατροπή τύπου σε αντικείμενα.
Υπερφόρτωση αριθμητικών τελεστών Είδαμε σε προηγούμενο παράδειγμα πώς δύο αντικείμενα Account μπορούν να προστεθούν, χρησιμοποιώντας μία συνάρτηση-μέλος:
Αν χρησιμοποιηθεί ο τελεστής + με υπερφόρτωση, τότε μπορούμε να έχουμε την εξής πρόταση:
Το πρόγραμμα που ακολουθεί, υλοποιεί αυτή την περίπτωση:
Για να «αναγκάσουμε» τον τελεστή + να ενεργήσει πάνω σε ένα αντικείμενο, χρησιμοποιούμε τη δεσμευμένη λέξη operator.
Συγκεκριμένα, γράφουμε μία συνάρτηση όπου ο τύπος επιστρεφόμενης τιμής μπαίνει πρώτος, ακολουθούμενος από τη δεσμευμένη λέξη operator και αμέσως μετά τον ίδιο τον τελεστή.
Τέλος, μέσα σε παρενθέσεις γράφουμε τη λίστα των ορισμάτων.
Όταν στη main() εκτελείται η πρόταση τότε γίνεται υπερφόρτωση του τελεστή + (επειδή τα ac1 και ac2 έχουν ορισθεί ως αντικείμενα), προστίθενται τα αντικείμενα ac1 και ac2 και το αποτέλεσμα αποδίδεται στο αντικείμενο ac3.
Να διευκρινίσουμε, επίσης, ότι η συνάρτηση χρησιμοποιεί ως όρισμα το αντικείμενο που βρίσκεται δεξιά του τελεστή (π.χ. το ac2).
Ακόμα, η συνάρτηση είναι μέλος στο αντικείμενο που βρίσκεται αριστερά του τελεστή (π.χ. στο ac1) και έτσι η αναφορά στα δεδομένα αυτού του αντικειμένου είναι άμεση.
Γενικά, ένας τελεστής με υπερφόρτωση απαιτεί πάντα ένα όρισμα λιγότερο από τον αριθμό των τελεστέων του, αφού ο ένας τελεστέος είναι το αντικείμενο του οποίου μέλος είναι η συνάρτηση του τελεστή.
Υπερφόρτωση τελεστών σύγκρισης Με παρόμοιο τρόπο μπορούμε να υλοποιήσουμε την υπερφόρτωση τελεστών σύγκρισης.
Για παράδειγμα, στο επόμενο πρόγραμμα θα χρησιμοποιήσουμε τον τελεστή > (μεγαλύτερο από) με υπερφόρτωση, στην κλάση Account, για να μπορούμε να συγκρίνουμε δύο λογαριασμούς:
cout << “Το ποσό του λογαριασμού ac1 είναι μεγαλύτερο.” << endl; cout << “Το ποσό του ac2 είναι μεγαλύτερο ή είναι ίσοι.” << endl;
Γνωρίζουμε από πριν ότι προτάσεις όπως όπου x και y είναι π.χ. ακέραιου τύπου, αποδίδουν την τιμή μίας μεταβλητής σε μία άλλη. όπου τα a1, a2, a3 είναι αντικείμενα, αποδίδει την τιμή ενός αντικειμένου σε ένα άλλο.
Έτσι, οι αποδόσεις τιμών μεταξύ μεταβλητών βασικών τύπων και τύπων ορισμένων από το χρήστη, αναλαμβάνονται από το μεταγλωττιστή, αρκεί να είναι ο ίδιος τύπος δεδομένων και από τις δύο πλευρές του σημείου ίσον.
Όταν οι μεταβλητές είναι διαφορετικού τύπου, τότε, αν είναι και οι δύο βασικού τύπου, η μετατροπή γίνεται αυτόματα από το μεταγλωττιστή (casting).
Σε διαφορετικές περιπτώσεις πρέπει εμείς να του πούμε τι να κάνει.
Μετατροπές μεταξύ αντικειμένων και βασικών
Στο επόμενο παράδειγμα θα δούμε πώς γίνεται η μετατροπή ανάμεσα σε ένα βασικό τύπο δεδομένων και σε ένα τύπο ορισμένο από το χρήστη.
EngDist(float meters) // συνάρτηση εγκατάστασης για μετατροπή από // βασικό τύπο, σε τύπο ορισμένο από το χρήστη d1 = 1.95; // χρήση συνάρτησης εγκατάστασης για μετατροπή από cout << “d1 = “; // μέτρα σε EngDist metr = d2 ; // χρήση συνάρτησης μετατροπής για μετατροπή από cout << “d2 = ” << metr << “ μέτρα.” << endl;
Συνοψίζοντας, για να μετατρέψουμε ένα βασικό τύπο –όπως π.χ. float- σε τύπο ορισμένο από το χρήστη – π.χ.
EngDist- χρησιμοποιούμε μία συνάρτηση εγκατάστασης με ένα όρισμα τύπου float.
EngDist(float meters) // συνάρτηση εγκατάστασης για μετατροπή από
Αυτή η συνάρτηση εκτελείται όταν εκτελείται η πρόταση
Όταν, τώρα, μετατρέπουμε ένα τύπο ορισμένο από το χρήστη σε βασικό, χρησιμοποιούμε τη συνάρτηση μετατροπής:
Η συνάρτηση καλείται όταν εκτελείται η πρόταση
Κανονικά, μόλις ο μεταγλωττιστής αντιληφθεί ότι προσπαθούμε να μετατρέψουμε από ένα τύπο ορισμένο από το χρήστη, σε ένα βασικό τύπο, αναζητά ένα τελεστή με υπερφόρτωση =.
Όταν δε βρει κανέναν, συνεχίζει την αναζήτηση, βρίσκει τη συνάρτηση μετατροπής και τη χρησιμοποιεί.
Μετατροπές μεταξύ αντικειμένων διαφορετικών
Όταν έχουμε να μετατρέψουμε αντικείμενα μεταξύ τους, που είναι ορισμένα σε διαφορετικές κλάσεις, ακολουθούμε μία παρόμοια διαδικασία.
Χρησιμοποιούμε μία συνάρτηση εγκατάστασης με ένα όρισμα, αν θέλουμε η ρουτίνα μετατροπής να βρίσκεται στην κλάση του αντικειμένου προορισμού (δηλ. αριστερά από το =), ενώ χρησιμοποιούμε μία συνάρτηση μετατροπής, αν θέλουμε η ρουτίνα μετατροπής να βρίσκεται στην κλάση του αντικειμένου προέλευσης (δηλ. δεξιά από το =).
Τα δύο επόμενα παραδείγματα υλοποιούν και τις δύο αυτές περιπτώσεις, για τη μετατροπή μίας «Αγγλικής» απόστασης (πόδια και ίντσες) σε μία «Ελληνική» απόσταση (μέτρα και εκατοστά).
Ρουτίνα στο αντικείμενο προορισμού
Ρουτίνα στο αντικείμενο προέλευσης
Η κληρονομικότητα είναι ένα από τα πιο ισχυρά χαρακτηριστικά του αντικειμενοστραφούς προγραμματισμού.
Είναι ο μηχανισμός που επιτρέπει σε μία κλάση να κληρονομεί όλη τη συμπεριφορά και τις ιδιότητες μιας άλλης κλάσης.
Η κλάση που κληρονομεί ονομάζεται παράγωγη κλάση (derived class), ενώ η κλάση που παρέχει την κληρονομικότητα ονομάζεται βασική κλάση (base class).
Ένα από τα πλεονεκτήματα της κληρονομικότητας είναι ότι επιτρέπει την επαναχρησιμοποίηση του κώδικα.
Αφού γραφεί μία βασική κλάση και γίνει εκσφαλμάτωση, δε χρειάζεται να την ξαναπειράξουμε.
Μπορούμε να την προσαρμόσουμε να λειτουργεί σε διάφορες συνθήκες.
Η επαναχρησιμοποίηση υπάρχοντα κώδικα εξοικονομεί χρόνο, χρήμα και αυξάνει την αξιοπιστία του προγράμματος.
Το βέλος σημαίνει προκύπτει από
Ορίζεται στην παράγωγη κλάση
Ορίζονται στη βασική κλάση, αλλά είναι προσπελάσιμα από την cout << “Τρέχον ποσό λογαριασμού a1 = “ << a1.getBalance();
Στο προηγούμενο παράδειγμα ορίζονται δύο κλάσεις, η Account και η AccInter.
Η πρόταση καθορίζει τη σχέση της κληρονομικότητας.
Η AccInter είναι η παράγωγη κλάση και κληρονομεί όλες τις δυνατότητες της βασικής κλάσης Account.
Στη main() δημιουργούμε ένα αντικείμενο της κλάσης AccInter:
Στο αντικείμενο δίνεται αρχική τιμή 0, αν και δεν υπάρχει συνάρτηση εγκατάστασης στην κλάση AccInter.
Όταν δεν υπάρχει συνάρτηση εγκατάστασης στην παράγωγη κλάση, χρησιμοποιείται η συνάρτηση εγκατάστασης από τη βασική κλάση.
Το αντικείμενο a1 της κλάσης AccInter χρησιμοποιεί επίσης τις συναρτήσεις deposit() και getBalance() της κλάσης Account.
Κατά τον ίδιο τρόπο, ο μεταγλωττιστής, όταν δε βρίσκει κάποια συνάρτηση στην παράγωγη κλάση -δηλαδή την κλάση στην οποία το a1 είναι μέλος- αναζητά τη συνάρτηση αυτή στη βασική κλάση.
Το δεδομένο balance στην κλάση Account έχει δηλωθεί ως protected.
Αυτό σημαίνει ότι το δεδομένο μπορεί να προσπελασθεί από συναρτήσεις-μέλη μέσα στην δική του κλάση ή σε οποιαδήποτε κλάση που κληρονομεί τη δική του κλάση.
Δεν μπορεί να προσπελασθεί από συναρτήσεις έξω απ’ αυτές τις κλάσεις, όπως π.χ. η main().
Προσπελάσιμο από τη δική του κλάση Προσπελάσιμο από την παράγωγη κλάση Προσπελάσιμο από αντικείμενα έξω από την κλάση
Πίνακας 7-1.
Πίνακας προσπελασιμότητας Θα πρέπει να τονισθεί ότι η κληρονομικότητα δεν λειτουργεί αντίστροφα.
Η βασική κλάση δεν κληρονομεί τις δυνατότητες της παράγωγης κλάσης.
Αν, για παράδειγμα, δηλώσουμε στη main() το αντικείμενο αυτό μπορεί να χρησιμοποιήσει τις συναρτήσεις-μέλη της δικής του κλάσης, αλλά δεν μπορεί για παράδειγμα να χρησιμοποιήσει τη συνάρτηση interest() της κλάσης AccInter.
Στο προηγούμενο πρόγραμμα, αν θελήσουμε να αποδώσουμε αρχική τιμή στο αντικείμενο a1 της παράγωγης κλάσης, αυτό δεν θα είναι εφικτό.
Αυτό συμβαίνει γιατί, ενώ ο μεταγλωττιστής χρησιμοποιεί μία συνάρτηση εγκατάστασης από τη βασική κλάση όταν είναι χωρίς ορίσματα, δεν μπορεί να το κάνει για συναρτήσεις με ορίσματα.
Για να το πετύχουμε αυτό, πρέπει να γράψουμε συναρτήσεις εγκατάστασης για την παράγωγη κλάση.
Οπότε τώρα μπορούμε να δημιουργήσουμε αντικείμενα της παράγωγης κλάσης και να τους αποδώσουμε αρχικές τιμές:
Όταν δημιουργούμε αντικείμενα στη main(), τότε καλούνται οι ανάλογες συναρτήσεις εγκατάστασης για να αποδώσουν αρχικές τιμές.
Με την δήλωση όπου η συνάρτηση εγκατάστασης AccInter() καλεί την αντίστοιχη συνάρτηση εγκατάστασης Account() για την αρχικοποίηση του αντικειμένου. όπου καλείται η συνάρτηση εγκατάστασης AccInter() με ένα όρισμα και αυτή με τη σειρά της καλεί την αντίστοιχη συνάρτηση Account() με ένα όρισμα και της μεταβιβάζει το όρισμα για να αποδοθεί σαν αρχική τιμή στο αντικείμενο.
Υπερφόρτωση συναρτήσεων-μελών Σε μία παράγωγη κλάση μπορούμε να γράψουμε συναρτήσεις-μέλη που έχουν το ίδιο όνομα με κάποιες συναρτήσεις της βασικής κλάσης.
Στο παράδειγμα που εξετάζουμε, οι συναρτήσεις deposit() και withdraw() δέχονται σαν όρισμα ένα χρηματικό ποσό και το προσθέτουν ή το αφαιρούν αντίστοιχα από το τρέχον ποσό του λογαριασμού.
Δεν εξετάζεται, όμως, η περίπτωση όπου το ποσό που περνά σαν όρισμα να είναι αρνητικό.
Θα μπορούσε, βέβαια, ο έλεγχος αυτός να προστεθεί κατευθείαν στις συναρτήσεις στη βασική κλάση.
Για να μην «αλλοιώσουμε>, όμως, τον κώδικα της βασικής κλάσης, θα βάλλουμε τον έλεγχο αυτό στην παράγωγη κλάση:
cout << “Το ποσό δεν είναι έγκυρο.”;
Όταν εκτελείται η πρόταση καλείται η συνάρτηση deposit(), την οποία ο μεταγλωττιστής αναζητά στην παράγωγη κλάση, τη βρίσκει και την εκτελεί.
Εκεί γίνεται ο έλεγχος αν το όρισμα είναι θετικό ποσό και εφόσον είναι, εκτελείται η πρόταση όπου καλείται η συνάρτηση deposit() της βασικής κλάσης και της μεταβιβάζεται το ποσό σαν όρισμα.
Κάτι ανάλογο ισχύει και για τη συνάρτηση withdraw().
Γενικά, μπορούμε να πούμε ότι όταν υπάρχει η ίδια συνάρτηση στη βασική και στην παράγωγη κλάση, τότε εκτελείται η συνάρτηση στην παράγωγη κλάση (για αντικείμενα της παράγωγης κλάσης).
Επίσης, να τονίσουμε, ότι για να γίνει η κλήση των συναρτήσεων deposit() και withdraw() της βασικής κλάσης μέσα από τις αντίστοιχες συναρτήσεις της παράγωγης κλάσης, χρησιμοποιείται ο τελεστής διάκρισης εμβέλειας ::, αλλιώς οι συναρτήσεις θα καλούσαν τον εαυτό τους και αυτό θα οδηγούσε το πρόγραμμα σε αποτυχία.
Υπάρχουν πολλές δυνατότητες προσπέλασης.
Στο πρόγραμμα που ακολουθεί, μπορούμε να δούμε διάφορους συνδυασμούς προσπέλασης, για να κατανοήσουμε ποιοι συνδυασμοί είναι έγκυροι και θα λειτουργήσουν: class A // βασική κλάση class B : public A // κλάση που παράγεται δημόσια class C : private A // κλάση που παράγεται ιδιωτικά a = privdataA; // λάθος: μη προσπελάσιμο a = objB.privdataA; // λάθος: μη προσπελάσιμο a = objB.protdataA; // λάθος: μη προσπελάσιμο a = objB.pubdataA; // σωστό a = objC.privdataA; // λάθος: μη προσπελάσιμο a = objC.protdataA; // λάθος: μη προσπελάσιμο a = objC.pubdataA; // λάθος: μη προσπελάσιμο Στο πρόγραμμα ορίζεται μία βασική κλάση A όπου δηλώνονται ιδιωτικά, προστατευμένα και δημόσια δεδομένα.
Επίσης, με βάση την κληρονομικότητα, ορίζονται δύο παράγωγες κλάσεις, η B που παράγεται δημόσια και η C που παράγεται ιδιωτικά.
Είδαμε πριν, ότι οι συναρτήσεις-μέλη των παράγωγων κλάσεων μπορούν να προσπελάσουν προστατευμένα και δημόσια δεδομένα της βασικής κλάσης.
Επίσης, αντικείμενα της παράγωγης κλάσης δεν μπορούν να προσπελάσουν προστατευμένα και ιδιωτικά δεδομένα της βασικής κλάσης.
Αντικείμενα της παράγωγης κλάσης μπορούν να προσπελάσουν δημόσια δεδομένα της βασικής κλάσης, μόνον εφόσον η κλάση παράγεται δημόσια (π.χ. η B).
Αντικείμενα παράγωγης κλάσης που παράγεται ιδιωτικά (π.χ. η C) δεν μπορούν να προσπελάσουν ούτε δημόσια δεδομένα της βασικής κλάσης.
Αν δεν δώσουμε κάποιο καθοριστή προσπέλασης όταν δημιουργούμε μία κλάση, υποτίθεται ότι είναι ιδιωτικός (private).
Μία κλάση μπορεί να παραχθεί από μία άλλη κλάση που κι’ αυτή είναι παράγωγη.
Μία κλάση μπορεί να παραχθεί από περισσότερες από μία κλάσεις.
Εδώ ορίζονται δύο βασικές κλάσεις, οι A και B και μία τρίτη κλάση η C, η οποία παράγεται και από την Α και από την Β.
Η κληρονομικότητα μας δίνει τη δυνατότητα να ορίσουμε μία σχέση ανάμεσα σε δύο κλάσεις Α και Β.
Μία άλλη σχέση που μπορεί να ορισθεί λέγεται περιεκτικότητα.
Εδώ έχουμε την περίπτωση όπου ένα αντικείμενο της κλάσης Β περιέχεται μέσα στην κλάση Α. cout << “Δώσε ποσό ανάληψης:”; cout << “Δώσε ποσό κατάθεσης:”; cout << “Τρέχον ποσό λογαριασμού = “ << a.getBalance();
Δείκτης είναι μία μεταβλητή που περιέχει τη διεύθυνση μιας άλλης μεταβλητής.
Η χρήση δεικτών είναι αρκετά συνηθισμένη σε αρκετές γλώσσες προγραμματισμού όπως και στην C++.
Αν και πολλές λειτουργίες μπορούν να υλοποιηθούν και με άλλους τρόπους, εν τούτοις σε αρκετές περιπτώσεις οι δείκτες γίνονται ένα προγραμματιστικό εργαλείο για αύξηση της δύναμης της γλώσσας προγραμματισμού, όπως είναι κάποιες δομές δεδομένων, π.χ. οι συνδεδεμένες λίστες και τα δυαδικά δένδρα.
Μερικές από τις πλέον συνηθισμένες χρήσεις τους είναι: · Προσπέλαση στοιχείων πίνακα · Μεταβίβαση ορισμάτων σε συνάρτηση, όταν η συνάρτηση πρέπει να αλλάξει το αρχικό όρισμα · Μεταβίβαση πινάκων και αλφαριθμητικών σε συναρτήσεις · Απόκτηση μνήμης από το σύστημα · Δημιουργία δομών δεδομένων όπως οι συνδεδεμένες λίστες Οι δείκτες λειτουργούν με βάση την έννοια της εμμεσότητας.
Ένας δείκτης είναι μία μεταβλητή, στην οποία έχει αποθηκευτεί ως τιμή μια διεύθυνση της μνήμης του υπολογιστή.
Στη διεύθυνση αυτή αντιστοιχεί ένα ορισμένο περιεχόμενο της μνήμης, που είναι η τιμή ενός ορισμένου δεδομένου.
Τότε, ο δείκτης αυτός έχει δυνατότητα έμμεσης πρόσβασης στην τιμή αυτού του δεδομένου.
Οι δύο τελεστές δείκτη (pointer operators) είναι · ο τελεστής διεύθυνσης (address operator) & · ο τελεστής έμμεσης αναφοράς (indirection operaror) * Ο τελεστής & είναι ένας μοναδιαίος τελεστής, ο οποίος επιστρέφει ως τιμή τη διεύθυνση μνήμης της τιμής του τελεσταίου του.
Ο τελεστής * είναι το συμπλήρωμα του &, δηλ. είναι ένας μοναδιαίος τελεστής, ο οποίος επιστρέφει ως τιμή την τιμή της μεταβλητής, η οποία είναι τοποθετημένη στη διεύθυνση μνήμης, την οποία έχει ως τιμή ο τελεσταίος του.
Πίνακας 8-1.
Πράξεις με δείκτες
Υλοποίηση παραδείγματος στη C: int *p; // ο p είναι δείκτης σε ακέραιο p = &i; // στον p εκχωρείται ως τιμή η διεύθυνση της i j = *p; // στη j εκχωρείται ως τιμή το περιεχόμενο της μεταβλητής, της } // οποίας τη διεύθυνση έχει ως τιμή ο p (δηλ. το περιεχόμενο της i) a) p = &i; // εκχώρηση της διεύθυνσης της μεταβλητής i στον δείκτη p, q = &j; // εκχώρηση της διεύθυνσης της μεταβλητής j στον δείκτη q, b) p = q; // εκχώρηση της τιμής του δείκτη q στο δείκτη p, // ή εκεί που δείχνει ο q να δείχνει και ο p . c) *p = *q; // το περιεχόμενο της μεταβλητής όπου δείχνει ο q, εκχωρείται // ως περιεχόμενο στη μεταβλητή που δείχνει ο p.
Δείκτες και Δομές
Τότε μπορούμε να έχουμε δηλώσεις όπως
Η μεταβλητή simera ορίζεται ως μία μεταβλητή δομής τύπου struct imerominia.
Η μεταβλητή imp ορίζεται ως ένας δείκτης προς μία μεταβλητή δομής τύπου struct imerominia.
Επομένως, με την εντολή αποκτούμε τη δυνατότητα έμμεσης πρόσβασης στις τιμές των μελών της δομής simera, μέσω του δείκτη imp. εκχωρεί την τιμή 15 στο μέλος mera της δομής simera.
Οι παρενθέσεις είναι απαραίτητες γιατί ο τελεστής μέλους δομής “.” έχει υψηλότερη προτεραιότητα από τον τελεστή έμμεσης αναφοράς “*”.
Για απλοποίηση ορίστηκε ένας ειδικός τελεστής, ο “->”, o οποίος λέγεται τελεστής δείκτη δομής (structure pointer operator).
Έτσι, μπορούμε να έχουμε τις εξής εκφράσεις // αντί (*imp).mera = 15; // αντί (*imp).minas = 2; // αντί (*imp).etos = 2003;
Δείκτες εντός δομών Ένας δείκτης είναι δυνατόν να αποτελεί μέλος δομής, για παράδειγμα x.d1 = &i; // η διεύθυνση της μεταβλητής i εκχωρείται στο δείκτη x.d1 x.d2 = &j; // η διεύθυνση της μεταβλητής j εκχωρείται στο δείκτη x.d2 *x.d2 = -8; // η τιμή –8 εκχωρείται ως περιεχόμενο στη μεταβλητή } // που δείχνει ο δείκτης x.d2 Στην τελευταία εντολή x.d2 = -8, ο τελεστής “.” έχει υψηλότερη προτεραιότητα από τον τελεστή “*”.
Θα ήταν προτιμότερο στην εντολή να χρησιμοποιούσαμε παρενθέσεις, όπως για παράδειγμα για να αποφεύγονται σφάλματα.
Οι έννοιες των δεικτών προς δομές και των δεικτών εντός δομών, μας επιτρέπουν τη δημιουργία περίτεχνων δομών δεδομένων, όπως είναι οι συνδεδεμένες λίστες (linked lists).
Για παράδειγμα
Η προηγούμενη δήλωση δομής περιλαμβάνει ως πρώτο μέλος την ακέραια μεταβλητή data και ως δεύτερο μέλος τον δείκτη next.
Αυτή η αναδρομική δήλωση ενός κόμβου, μπορεί να φαίνεται λίγο παρακινδυνευμένη, είναι όμως σωστή.
Δεν επιτρέπεται σε μία δομή να περιέχει μία περίπτωση του εαυτού της, αλλά η δηλώνει ότι ο next είναι δείκτης για μία node και όχι η ίδια η δομή node.
Τέτοιες δομές ονομάζονται αυτο-αναφορικές δομές και χρησιμοποιούνται πάρα πολύ σε προγράμματα σύνθετων δομών δεδομένων, όπως είναι οι συνδεδεμένες λίστες και τα δένδρα. x.next = &y; // ο δείκτης x.next δείχνει στη δομή y y.next = &z; // ο δείκτης y.next δείχνει στη δομή z j = x.next->data; // το περιεχόμενο του μέλους data της δομής όπου δείχνει // ο δείκτης x.next εκχωρείται στη μεταβλητή j.
Θα // μπορούσαμε ισοδύναμα να πούμε j = y.data
Δείκτες για void Συνήθως, η διεύθυνση που τοποθετείται σε ένα δείκτη, πρέπει να είναι του ίδιου τύπου όπως ο δείκτης.
Π.χ. δεν μπορούμε να αποδώσουμε τη διεύθυνση μίας μεταβλητής float σε ένα δείκτη int.
Ωστόσο, υπάρχει ένα είδος δείκτη γενικής χρήσης που μπορεί να δείχνει οποιονδήποτε τύπο δεδομένων.
// δείκτες για τύπο void int *ptrint; // ορισμός δείκτη για int float *ptrflo; // ορισμός δείκτη για float void *ptrvoid; // ορισμός δείκτη για void ptrint = &intvar; // σωστό, απόδοση int* σε int* // ptrint = &flovar; // λάθος, απόδοση float* σε int* // ptrflo = &intvar; // λάθος, απόδοση int* σε float* ptrflo = &flovar; // σωστό, απόδοση float* σε float* ptrvoid = &intvar; // σωστό, απόδοση int* σε void* ptrvoid = &flovar; // σωστό, απόδοση int* σε void*
Όπως είδαμε και σε προηγούμενο κεφάλαιο, υπάρχουν τρεις τρόποι για να μεταβιβάζουμε ορίσματα σε συναρτήσεις, όταν τις καλούμε:
Όταν η συνάρτηση δεν πρόκειται να τροποποιήσει τις μεταβλητές που της μεταβιβάζονται όταν γίνεται η κλήση της, τότε έχουμε κλήση με τιμή και η συνάρτηση ενεργεί σε αντίγραφα των αρχικών μεταβλητών sum = athroisma(a, b); // μεταβιβάζονται οι τιμές των μεταβλητών
Η δήλωση int &s σημαίνει ότι το όρισμα s αναφέρεται στη μεταβλητή sum.
Στην ουσία το s και το sum είναι διαφορετικά ονόματα για την ίδια μεταβλητή.
Επομένως, οποιαδήποτε αλλαγή στην s αυτόματα επιδρά στη sum.
Το ίδιο συμβαίνει και με τις d και diff.
Εδώ η συνάρτηση έχει σαν ορίσματα δύο δείκτες για int:
Επομένως, στην κλήση της συνάρτησης μεταβιβάζουμε τις διευθύνσεις των μεταβλητών sum και diff.
Έτσι, για να γίνει προσπέλαση στο περιεχόμενο αυτών των μεταβλητών, χρησιμοποιείται ο τελεστής έμμεσης αναφοράς:
Οι δύο τελευταίοι τρόποι –κλήση με αναφορά και κλήση με δείκτες- δίνουν τη δυνατότητα σε μια συνάρτηση να τροποποιήσει τις μεταβλητές στο καλούν πρόγραμμα, με διαφορετική όμως προσέγγιση.
Η αναφορά είναι ένα ψευδώνυμο για την αρχική μεταβλητή, ενώ ο δείκτης είναι η διεύθυνση μεταβλητής.
Διαχείριση μνήμης: new και delete Όταν χρειαζόμαστε μνήμη για την αποθήκευση πολλών στοιχείων, συνήθως χρησιμοποιούμε πίνακες.
Οι πίνακες όμως έχουν το μειονέκτημα ότι πρέπει να καθορίσουμε το μέγεθός τους και μάλιστα πριν την εκτέλεση του προγράμματος.
Σε πολλές, όμως, περιπτώσεις δε γνωρίζουμε πόση μνήμη θα χρειαστούμε εκ των προτέρων.
Η C++ μας παρέχει, μέσω νέων τελεστών, τη δυνατότητα να αποκτήσουμε και να αποδεσμεύσουμε τμήματα μνήμης, πέραν των μεθόδων που έχουμε μάθει.
Οι τελεστές αυτοί είναι οι new και delete.
cout << “Δώσε κωδικό:”; cout << “Δώσε ένα όνομα:”;
Η χρήση του τελεστή new είναι παρόμοια με τη χρήση της συνάρτησης malloc() της C.
Η νέα προσέγγιση με τον new είναι καλύτερη γιατί επιστρέφει ένα δείκτη για τον κατάλληλο τύπο δεδομένων, ενώ ο δείκτης της malloc() πρέπει να προσαρμοσθεί (casting) στον κατάλληλο τύπο.
Για την αποδέσμευση χώρου μνήμης –που έχει δεσμευθεί με τον new- χρησιμοποιείται ο τελεστής delete.
Αν και όταν τελειώσει ένα πρόγραμμα, η μνήμη επιστρέφεται αυτόματα στο σύστημα, εν τούτοις, είναι σωστή πρακτική να γίνεται χρήση του τελεστή delete σε τμήματα μνήμης που δε χρειαζόμαστε πλέον.
Αυτό συνιστάται γιατί υπάρχει περίπτωση να καταρρεύσει το σύστημα, για παράδειγμα, αν χρησιμοποιούμε τον new με τοπικούς δείκτες μέσα σε συναρτήσεις.
Σε μια τέτοια περίπτωση, όταν η συνάρτηση τελειώσει την εκτέλεσή της, οι δείκτες καταστρέφονται, όμως, η μνήμη που δεσμεύτηκε δεν απελευθερώνεται και δεν μπορεί να προσπελασθεί από το υπόλοιπο πρόγραμμα.
Δείκτες για αντικείμενα Οι δείκτες, πέρα από τους συνήθεις τύπους δεδομένων, μπορούν να δείχνουν και σε αντικείμενα.
Αν κατά τη στιγμή που γράφουμε ένα πρόγραμμα, δε γνωρίζουμε πόσα αντικείμενα θα δημιουργήσουμε, τότε μπορούμε να χρησιμοποιήσουμε τον τελεστή new.
Ο new επιστρέφει ένα δείκτη σε ένα ανώνυμο αντικείμενο και μπορούμε έτσι να δημιουργήσουμε αντικείμενα κατά τη διάρκεια εκτέλεσης του προγράμματος.
cout << “Δώσε ένα όνομα:”; cout << “Κωδικός: “ << id << endl;
Στο προηγούμενο παράδειγμα, δηλώνεται ένας δείκτης p σε ένα αντικείμενο τύπου Person και με τον τελεστή new δεσμεύεται μνήμη για το αντικείμενο και ορίζεται ο δείκτης p να δείχνει στο συγκεκριμένο αντικείμενο.
Για να αναφερθούμε στις συναρτήσεις-μέλη του αντικειμένου χρησιμοποιούμε τον τελεστή προσπέλασης μέλους ->.
Πίνακας δεικτών προς αντικείμενα Όταν σε ένα πρόγραμμα δημιουργούμε πολλά αντικείμενα, είναι πιο ευέλικτο αντί να τοποθετήσουμε τα ίδια τα αντικείμενα στον πίνακα, να χρησιμοποιούμε ένα πίνακα δεικτών προς αυτά:
Οι συναρτήσεις-μέλη κάθε αντικειμένου έχουν πρόσβαση σε έναν «αόρατο» δείκτη που ονομάζεται this.
Έτσι κάθε συνάρτηση-μέλος μπορεί να ανακαλύψει τη διεύθυνση του αντικειμένου στο οποίο ανήκει.
Επιπλέον, ο δείκτης this μπορεί να χρησιμοποιηθεί όπως κάθε άλλος δείκτης για κάποιο αντικείμενο και έτσι μπορεί να προσπελάσει δεδομένα στο αντικείμενο που αναφέρεται.
Βέβαια, για λόγους ευκολίας, συνήθως η αναφορά στα δεδομένα αυτά γίνεται άμεσα, παραλείποντας το δείκτη this.
Μία πιο πρακτική, όμως, χρήση του this γίνεται όταν μία συνάρτηση-μέλος ενός αντικειμένου θέλει να επιστρέψει το αντικείμενο που την έχει καλέσει.
Γενικά, μπορούμε να ισχυριστούμε ότι, για λόγους κατανόησης είναι σωστό να γίνεται η χρήση του δείκτη this.
Για λόγους όμως οικονομίας είναι προτιμότερο να παραλείπεται και η αναφορά στα δεδομένα του αντικειμένου να γίνεται άμεσα.
Το παρακάτω παράδειγμα δείχνει πώς μπορεί να γίνει η χρήση του this:
Εικονικές συναρτήσεις (virtual functions) Εικονική είναι μία συνάρτηση που στην πραγματικότητα δεν υπάρχει, αλλά εμφανίζεται σαν πραγματική σε ορισμένα τμήματα ενός προγράμματος.
Μία τέτοια συνάρτηση θα ήταν χρήσιμη αν είχαμε ένα πλήθος αντικειμένων από διαφορετικές κλάσεις και θέλαμε να τα βάλλουμε όλα σε μία λίστα και να εκτελέσουμε κάποια συγκεκριμένη λειτουργία, χρησιμοποιώντας την ίδια κλήση συνάρτησης.
cout << "Βασική κλάση."; cout << "1η παράγωγη κλάση.";
Η έξοδος του προγράμματος θα ήταν:
Όπως βλέπουμε, η βασική κλάση A και οι δύο παράγωγες της Α, Par1 και Par2 έχουν μία συνάρτηση με το ίδιο όνομα, display() και θέλουμε να προσπελάσουμε αυτές τις συναρτήσεις χρησιμοποιώντας δείκτες.
Υπάρχει μία λεπτομέρεια.
Στη βασική κλάση, μπροστά από το δηλωτικό της συνάρτησης έχει προστεθεί η δεσμευτική λέξη virtual.
Εξ αιτίας αυτού του χαρακτηριστικού, όταν εκτελείται η πρόταση καλείται η συνάρτηση της παράγωγης κλάσης, ενώ αν παραλείπαμε τη λέξη virtual, θα καλούνταν η συνάρτηση display() της βασικής κλάσης.
Με λίγα λόγια, όταν μία συνάρτηση δηλωθεί virtual, ο μεταγλωττιστής επιλέγει τη συνάρτηση με βάση το περιεχόμενο του δείκτη και όχι τον τύπο του δείκτη.
Οι έννοιες της ενθυλάκωσης και της απόκρυψης δεδομένων υπαγορεύουν ότι οι συναρτήσεις-μη-μέλη δε θα πρέπει να μπορούν να προσπελάζουν τα ιδιωτικά ή προστατευμένα δεδομένα ενός αντικειμένου.
Ωστόσο, υπάρχουν καταστάσεις όπου αυτές οι αυστηρές διακρίσεις μπορεί να οδηγήσουν σε σημαντική δυσχέρεια.
Για παράδειγμα, έστω ότι θέλουμε μία συνάρτηση να επενεργεί πάνω σε αντικείμενα δύο διαφορετικών κλάσεων.
Θα μπορούσε, ίσως, η συνάρτηση να δέχεται τα δύο αντικείμενα σαν ορίσματα και να επενεργεί στα ιδιωτικά τους δεδομένα.
Αν οι κλάσεις των δύο αντικειμένων κληρονομούνται από την ίδια βασική κλάση, θα μπορούσαμε να βάλλουμε τη συνάρτηση στη βασική κλάση.
Αν όμως δε συμβαίνει αυτή η περίπτωση, τότε η καλύτερη εναλλακτική λύση είναι η χρήση μίας συνάρτησης friend, η οποία θα λειτουργήσει σαν γέφυρα ανάμεσα στις κλάσεις των δύο αντικειμένων.
Στο πρόγραμμα αυτό, η φίλη συνάρτηση ff() έχει πρόσβαση στα ιδιωτικά δεδομένα και των δύο κλάσεων Α και Β.
Η συνάρτηση δηλώνεται και στις δύο κλάσεις με τη δεσμευμένη λέξη friend.
Επίσης, επειδή δεν μπορούμε να αναφερθούμε σε μία κλάση πριν τη δηλώσουμε, γι’ αυτό δηλώνουμε στην αρχή την κλάση Β.
Αρχεία και αντικείμενα Στις περισσότερες σοβαρές εφαρμογές, τα προγράμματα χρειάζεται να διαβάζουν και να γράφουν δεδομένα σε αρχεία δίσκου.
Η C++, σαν αντικειμενοστραφής γλώσσα, μας παρέχει τη δυνατότητα να γράφουμε αντικείμενα στο δίσκο και να τα διαβάζουμε απ’ αυτόν.
Γράψιμο ενός αντικειμένου σε αρχείο
Στο πρόγραμμα αυτό πληκτρολογούνται δεδομένα –αριθμός μητρώου και όνομα- για διάφορα άτομα, μέχρι να δοθεί αριθμός μητρώου 0.
Τα δεδομένα προωθούνται σε αντικείμενα με τη συνάρτηση setData() και ακολούθως καταχωρούνται σε αρχείο εξόδου με τη συνάρτηση fwrite().
Διάβασμα αντικειμένου από αρχείο
Στο πρόγραμμα αυτό διαβάζονται οι πληροφορίες ατόμων, με χρήση της συνάρτησης fread(), ένα αντικείμενο τη φορά, και εμφανίζονται στην οθόνη με τη συνάρτηση printData().
Σε όλα σχεδόν τα προγράμματά μας, υπάρχουν οδηγίες προεπεξεργαστή #include που λένε στον μεταγλωττιστή να προσθέσει κάποια πηγαία αρχεία (προέκταση .h) στο πρόγραμμά μας.
Αυτά τα αρχεία ονομάζονται αρχεία κεφαλίδας (header files) ή αρχεία ενσωμάτωσης (include files) και περιέχουν δηλώσεις που είναι απαραίτητες για το πρόγραμμά μας.
Για παράδειγμα, το αρχείο κεφαλίδας iostream.h περιέχει δηλώσεις που χρειάζονται στο αναγνωριστικό cout και τον τελεστή <<.
Μπορούμε να δημιουργούμε και δικά μας αρχεία κεφαλίδας και να τα ενσωματώνουμε στα προγράμματά μας.
Για παράδειγμα, το παρακάτω είναι ένα αρχείο κεφαλίδας που ονομάζεται myheader.h και περιέχει τις δηλώσεις για μία κλάση.
Αρχείο κεφαλίδας myheader.h
Ακολούθως, στο επόμενο πρόγραμμα ενσωματώνουμε το αρχείο κεφαλίδας, και μπορούμε πλέον να χρησιμοποιήσουμε την προηγούμενη κλάση ΑΑΑ σαν να υπάρχει ορισμένη στο τρέχον πρόγραμμα:
Παρατηρούμε ότι η ενσωμάτωση του αρχείου κεφαλίδας γίνεται με την εντολή
Περικλείοντας το όνομα του αρχείου μέσα σε εισαγωγικά καθοδηγούμε το μεταγλωττιστή να το αναζητήσει στον τρέχοντα κατάλογο, όπου βρίσκεται και το πηγαίο πρόγραμμα.
Αν χρησιμοποιούσαμε γωνιακές αγκύλες <> αντί για εισαγωγικά, θα υποδηλώναμε ότι ο μεταγλωττιστής πρέπει να το αναζητήσει στον καθιερωμένο κατάλογο INCLUDE.
