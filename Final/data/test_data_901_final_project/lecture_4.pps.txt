Προγραμματισμός II
Διάρκεια μεταβλητών (duration)
Η διάρκεια ορίζει το χρόνο κατά τον οποίο το όνομα της μεταβλητής είναι συνδεδεμένο με τη θέση μνήμης που περιέχει την τιμή της μεταβλητής.
Ορίζονται ως χρόνοι δέσμευσης και αποδέσμευσης οι χρόνοι που το όνομα συνδέεται με και αποσυνδέεται από τη μνήμη, αντίστοιχα.
Για τις καθολικές μεταβλητές δεσμεύεται χώρος με την έναρξη εκτέλεσης του προγράμματος και η μεταβλητή συσχετίζεται με την ίδια θέση μνήμης έως το τέλος του προγράμματος.
Είναι πλήρους διάρκειας.
Οι τοπικές μεταβλητές είναι περιορισμένης διάρκειας.
Η ανάθεση της μνήμης σε τοπική μεταβλητή γίνεται με τη είσοδο στο χώρο εμβέλειάς της και η αποδέσμευσή της με την έξοδο από αυτόν.
Δηλαδή η τοπική μεταβλητή δε διατηρεί την τιμή της από τη μία κλήση της συνάρτησης στην επόμενη.
Εάν όμως προστεθεί στη δήλωση μίας τοπικής μεταβλητής η λέξη static, διατηρεί την τιμή της και καθίσταται πλήρους διάρκειας.
Παράδειγμα:
H μεταβλητή num είναι τοπική αλλά έχει διάρκεια προγράμματος, σε αντίθεση με την temp, η οποία έχει διάρκεια συνάρτησης.
Προσοχή πρέπει να δοθεί στην αρχικοποίηση των τοπικών μεταβλητών.
Μία τοπική μεταβλητή περιορισμένης διάρκειας αρχικοποιείται, εφόσον βέβαια κάτι τέτοιο έχει ορισθεί, με κάθε είσοδο στο μπλοκ που αυτή ορίζεται.
Αντίθετα, μία τοπική μεταβλητή πλήρους διάρκειας αρχικοποιείται μόνο με την ενεργοποίηση του προγράμματος.
α) Να περιγραφεί η επίδραση της λέξης κλειδί static στις δύο δηλώσεις του ακόλουθου πηγαίου κώδικα: β) Πότε αρχικοποιείται η count και πότε η num; static int num;
Λύση:
α) Η static στη δήλωση της καθολικής μεταβλητής num περιορίζει την ορατότητά της μόνο στο αρχείο που δηλώνεται.
Αντίθετα η static στη δήλωση της τοπικής μεταβλητής count ορίζει γι’ αυτήν διάρκεια προγράμματος.
β) Η count ως τοπική μεταβλητή αρχικοποείται μία φορά με την είσοδο στο πρόγραμμα.
Αντίθετα η num ως τοπική μεταβλητή περιορισμένης διάρκειας αρχικοποιείται σε κάθε ενεργοποίηση της συνάρτησης func().
Παράδειγμα στατικών μεταβλητών:
float get_average(float newdata); // δήλωση συνάρτησης
} // τέλος της main, συνέχεια στην επόμενη διαφάνεια
Αποτέλεσμα:
Παράδειγμα με επιστροφή μεταβλητών δομής
Distance addeng1(Distance dd1, Distance dd2); // δήλωση addeng1
void eng1disp(Distance dd); // δήλωση eng1disp
} // τέλος της main
Παράδειγμα
Τιμές στη μεταβλητή pers
Τιμές τουλάχιστον στο μέλος prsn.addr
Αναδρομικότητα (recursion)
Μία συνάρτηση ονομάζεται αναδρομική όταν μία εντολή του σώματος της συνάρτησης καλεί τον ίδιο της τον εαυτό.
Η αναδρομή είναι μία διαδικασία με την οποία ορίζουμε κάτι μέσω του ίδιου του οριζόμενου.
Επεξηγήσεις:
Εάν το n είναι ίσο με 1, τότε το άθροισμα ταυτίζεται με το n (οριακή περίπτωση). Στη γενική περίπτωση, θεωρούμε ότι ο υπολογισμός του αθροίσματος n μπορεί να θεωρηθεί ως υπολογισμός του αθροίσματος των αριθμών από το 1 έως το n-1 συν το n.
Αντίστοιχα, ο υπολογισμός του αθροίσματος n-1 μπορεί να θεωρηθεί ως υπολογισμός του αθροίσματος των αριθμών από το 1 έως το n-2 συν το n-1. Ακολουθώντας την παραπάνω διαδικασία, μπορούμε να ορίσουμε τα εξής:
κ.ο.κ.
Από τα παραπάνω προκύπτει ότι κάθε σχέση είναι ίδια με την προηγούμενη, με απλή αλλαγή των ορισμάτων.
Τι σημαίνει όμως αυτό;
Την πρώτη φορά καλείται η συνάρτηση sum() με όρισμα n.
Με την πρόταση return(sum(n-1)+n) η sum() καλεί τον ίδιο της τον εαυτό με διαφορετικό όμως όρισμα (n-1). Η ενεργοποίηση αυτή θα προκαλέσει με τη σειρά της νέα ενεργοποίηση και αυτό θα συνεχισθεί έως ότου προκληθεί διακοπή.
Η διακοπή είναι αποκλειστική ευθύνη του προγραμματιστή.
Στο συγκεκριμένο παράδειγμα η διακοπή προκαλείται με την πρόταση if (n<=1) return(n) ,που σημαίνει ότι όταν το n φθάσει να γίνει 1 υπάρχει πλέον αποτέλεσμα.
Έτσι οι διαδοχικές κλήσεις για n=4 είναι:
sum(4) καλεί τη sum(3)
sum(3) καλεί τη sum(2)
sum(2) καλεί τη sum(1)
η sum(1) δίνει αποτέλεσμα 1 και το επιστρέφει στη sum(2)
η sum(2) δίνει αποτέλεσμα 1+2=3 και το επιστρέφει στη sum(3)
η sum(3) δίνει αποτέλεσμα 3+3=6 και το επιστρέφει στη sum(4)
η sum(4) δίνει αποτέλεσμα 6+4=10, το οποίο είναι και το τελικό
Το πλήρες πρόγραμμα έχει την ακόλουθη μορφή:
int sum(int n); // δήλωση της συνάρτησης sum
int n=4; // ανάθεση n=4
int sum(int n){ // ορισμός της συνάρτησης sum
} // τέλος της sum
Μειονεκτήματα αναδρομικών συναρτήσεων
Οι περισσότερες αναδρομικές συναρτήσεις δεν εξοικονομούν σημαντικό μέγεθος κώδικα ή μνήμης για τις μεταβλητές.
Οι αναδρομικές εκδοχές των περισσότερων συναρτήσεων μπορεί να εκτελούνται κάπως πιο αργά από τα επαναληπτικά τους ισοδύναμα εξαιτίας των πρόσθετων κλήσεων σε συναρτήσεις.
Η πιθανή μείωση όμως δεν είναι αξιοσημείωτη.
Υπάρχει μικρή πιθανότητα οι πολλές αναδρομικές κλήσεις μίας συνάρτησης να προκαλέσουν υπερχείλιση της στοίβας (stack overflow), επειδή ο χώρος αποθήκευσης των παραμέτρων και των τοπικών μεταβλητών της συνάρτησης είναι στη στοίβα και κάθε νέα κλήση παράγει ένα νέο αντίγραφο αυτών των μεταβλητών.
Ωστόσο, εφόσον διατηρείται ο έλεγχος της αναδρομικής συνάρτησης και υπάρχει συνθήκη διακοπής, το ζήτημα είναι ήσσονος σημασίας.
Πλεονεκτήματα αναδρομικών συναρτήσεων
Το βασικότερο πλεονέκτημα των αναδρομικών συναρτήσεων είναι ότι μπορούν να χρησιμοποιηθούν για να δημιουργηθούν καθαρότερες και απλούστερες εκδοχές πολλών αλγορίθμων.
Δημιουργείται συμπαγέστερος κώδικας και είναι ιδιαίτερα χρήσιμες σε αναδρομικώς οριζόμενα δεδομένα όπως οι λίστες και τα δένδρα.
Άσκηση: Να καταστρωθεί πρόγραμμα, με χρήση αναδρομικής συνάρτησης, το οποίο δέχεται ως είσοδο από το πληκτρολογίο έναν ακέραιο αριθμό n και επιστρέφει στην οθόνη το παραγοντικό του.
Λύση: Το πρόβλημα είναι απολύτως αντίστοιχο με εκείνο του προηγούμενου παραδείγματος.
Οι μόνες διαφορές είναι ότι πρέπει να διαβάζεται ο n και ότι πολλαπλασιάζονται ακέραιοι και δεν αθροίζονται.
Κατά συνέπεια, μία πιθανή λύση είναι η εξής:
} // τέλος της fact
