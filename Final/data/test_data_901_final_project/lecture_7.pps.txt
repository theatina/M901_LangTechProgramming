Προγραμματισμός II
Ορίσματα γραμμής διαταγής
Όπως κάθε συνάρτηση, έτσι κι η main μπορεί να δεχθεί παραμέτρους, οι οποίες επιτρέπουν να δίνουμε στο καλούμενο πρόγραμμα ένα σύνολο από εισόδους, που καλούνται ορίσματα γραμμής διαταγής.
Ο μηχανισμός περάσματος ορισμάτων βασίζεται στην ακόλουθη δήλωση της main:
argc (argument count): ο αριθμός των ορισμάτων της γραμμής διαταγής, συμπεριλαμβανομένου και του ονόματος του προγράμματος.
argv (argument vector): δείκτης σε πίνακα από δείκτες, που δείχνουν στα ορίσματα της γραμμής διαταγής, τα οποία αποθηκεύονται με τη μορφή αλφαριθμητικών.
Ο πίνακας στον οποίο δείχνει ο argv έχει ένα επιπλέον στοιχείο, το argv[argc], το οποίο έχει τιμή NULL (είναι δείκτης που δε δείχνει πουθενά).
Παράδειγμα: Να καταστρωθεί πρόγραμμα που θα τυπώνει τα ορίσματα της γραμμής διαταγής
Λύση: Έστω echo το όνομα του προγράμματος.
Όταν το καλούμε με την εντολή
θα πρέπει να εκτελείται και να τυπώνει στην οθόνη one two three.
To σώμα της main έχει πρόσβαση στις μεταβλητές argc και argv όπως παριστάνονται από το ακόλουθο σχήμα:
με βάση το προηγούμενο σχήμα, η διαμόρφωση του σώματος της main είναι απλή:
Η printf( “%s%s”,argv[i],” “ ); τυπώνει μετά από κάθε όρισμα ένα κενό.
Εάν θέλουμε να μην τυπώνεται το κενό μετά το τελευταίο όρισμα, η πρόταση πρέπει να διαμορφωθεί όπως παρακάτω:
Εάν χρησιμοποιήσουμε τη σημειολογία των δεικτών αντί αυτής του πίνακα, η πρόταση μπορεί να γραφεί ως εξής:
Εναλλακτικά, θα μπορούσαμε να γράψουμε:
Δυσνόητο; δοκιμάστε το!!
Ένας πίνακας ελέγχει ένα συγκεκριμένο μπλοκ μνήμης.
Το μέγεθος ενός πίνακα είναι σταθερό: καθορισμένο όταν το πρόγραμμα έχει γραφεί.
Οι δείκτες μπορούν να δείξουν σε μπλοκ μνήμης αλλά . . .
πώς μπορούν να ελέγξουν τα δικά τους μπλοκ μνήμης;
Τι συμβαίνει όταν πρέπει να μεταβάλλεται το μέγεθος του πίνακα, ή θέλουμε να επιλέγεται το μέγεθος του πίνακα μετά την έναρξη εκτέλεσης του προγράμματος; (‘run time’)
Απάντηση: δυναμική εκχώρηση μνήμης (memory allocation) = εκχώρηση μνήμης κατά τη διάρκεια της εκτέλεσης του προγράμματος.
Επιτρέπει:
Τον καθορισμό του μεγέθους κατά την εκτέλεση (συνάρτηση: malloc())
Αλλαγή του μεγέθους κατά την εκτέλεση (συνάρτηση: realloc())
Οι malloc και free ορίζονται στο stdlib.h
Δείκτης σε int
Ακέραια μεταβλητή
Θεωρούμε ότι ο χρήστης ορίζει το μέγεθος ίσο με 3
H malloc αναζητά ένα συνεχές μπλοκ 12 bytes και, όταν το βρει, επιστρέφει ένα δείκτη στην αρχή του μπλοκ.
Δηλαδή, επιστρέφει τη διεύθυνση του πρώτου byte σ’ αυτό το μπλοκ.
Η διεύθυνση αυτή ανατίθεται στο δείκτη start.
Η sizeof δέχεται ως είσοδο ένα όνομα τύπου και επιστρέφει το μέγεθος του τύπου αυτού , π.χ. ένας ακέραιος έχει μέγεθος 4 bytes.
Απελευθερώνει το μπλοκ μνήμης, το οποίο που αρχίζει από τη διεύθυνση που καθορίζεται στην αρχή
Τι ΔΕΝ πρέπει να κάνετε:
ΛΑΘΟΣ!!!
Χαμένη μετατροπή τύπου
Αν και μερικοί μεταγλωττιστές μπορεί να «καταλάβουν» τι συμβαίνει, πρέπει πάντοτε να θεωρείται ότι δεν μπορούν
Συγκεκριμένος αριθμός bytes.
Δεν ξεκαθαρίζει πώς πολλοί ακέραιοι θα ενταχθούν σ’ αυτό το μπλοκ.
Επειδή δεν εκχωρούν όλα τα μηχανήματα 4 bytes για int, μην κάνετε υποθέσεις.
Γιατί η malloc δεν μπορεί να βρει τη ζητηθείσα μνήμη;
Επιστρέφει NULL.
Το NULL είναι η διεύθυνση 0.
Είναι έγκυρη διεύθυνση, που εγγυημένα δεν περιέχει ποτέ έγκυρα δεδομένα.
Καλή προγραμματιστική πρακτική: Να ελέγχετε πάντοτε κατά πόσον η malloc επιστρέφει NULL:
Η free() δέχεται ως όρισμα ένα δείκτη, ο οποίος δείχνει στην αρχή του μπλοκ που απελευθερώνεται.
Δε χρειάζεται να είναι ο ίδιος δείκτης που χρησιμοποιήθηκε στη malloc.
Το ακόλουθο είναι σωστό:
msg = pmessage; /* πλέον και οι δύο δείχνουν στην ίδια θέση */
pmessage = &aLetter; /* πλέον ο pmessage δείχνει στο aLetter */
ΠΡΟΣΟΧΗ: Μην προσπαθήσετε να απελευθερώσετε την ίδια μνήμη δύο φορές!!
Το ακόλουθο είναι ΛΑΘΟΣ:
free(pmessage); /* ΛΑΘΟΣ: Το μπλοκ έχει ήδη απελευθερωθεί!! */
Παρατηρήσεις για malloc(), free()
Το free(ptr) είναι επικίνδυνο εάν ο ptr δεν είναι έγκυρος!! Το αποτέλεσμα είναι απρόβλεπτο: μπορεί να μη συμβεί τίποτε είτε να υπάρξει κάποιο σφάλμα είτε ακόμη και να κολλήσει το πρόγραμμα.
Όταν σε ένα πρόγραμμα έχουμε επαναλαμβανόμενες εκχωρήσεις μνήμης χωρίς τις αντίστοιχες απελευθερώσεις, συμβαίνουν ‘διαρροές μνήμης’
Το πρόγραμμα αυξάνει συνεχώς καθώς εκτελείται
Τελικά, το πρόγραμμα είτε θα πρέπει να σταματήσει είτε θα κολλήσει.
Για την αποφυγή των ανωτέρω θα πρέπει:
Βέλτιστη λύση: Κρατείστε τα ζεύγη malloc/free στο ίδιο τμήμα κώδικα
Καλή λύση: Δημιουργείστε μία κεντρική συνάρτηση, λειτουργούσα ως “δοχείο απορριμάτων”.
Κακή λύση: Διασκορπισμένες malloc() και free()
