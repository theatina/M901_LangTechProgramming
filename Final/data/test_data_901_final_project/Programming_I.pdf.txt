∆ρ.
Πάρις Αστ.
Μαστοροκώστας
Τοµέας Υπολογιστικών Τεχνικών & Συστηµάτων © ∆ρ.
Πάρις Μαστοροκώστας ΑΤΕΙ Σερρών
Προγραµµατισµός Ι i Τµήµα Πληροφορικής & Επικοινωνιών
Κατηγορίες εκφράσεων της C - προτεραιότητα
Έλεγχος ροής - προτάσεις υπό συνθήκη
Κανόνες για τη χρήση των προτάσεων ροής του ελέγχου . 5-20
Πίνακας 2-1.
Μη εκτυπούµενοι χαρακτήρες και αντίστοιχες ακολουθίες
Βασικά στοιχεία προγράµµατος Αντικείµενο του παρόντος συγγράµατος είναι η εισαγωγή του αναγνώστη στη λογική του προγραµµατισµού Η/Υ.
Το ενδιαφέρον εστιάζεται στον καλούµενο διαδικαστικό προγραµµατισµό (procedural programming), βασικά στοιχεία του οποίου είναι η δόµηση του προγράµµατος και η επαναλαµβανόµενη χρήση υποπρογραµµάτων, τα οποία είτε επιτελούν εργασίες γενικής φύσης είτε απευθύνονται σε ένα τµήµα του συνολικού προβλήµατος.
Στόχος είναι η κατανόηση των αρχών του προγραµµατισµού και η εµπέδωση της φιλοσοφίας του, έτσι ώστε ο αναγνώστης να µπορεί χωρίς δυσχέρειες να προχωρήσει σε άλλες µορφές προγραµµατισµού, όπως ο αντικειµενοστραφής προγραµµατισµός (object–oriented
Στην προσπάθεια αυτή θα χρησιµοποιηθεί ως πλατφόρµα µία γλώσσα προγραµµατισµού υψηλού επιπέδου, η γλώσσα C.
Ο όρος γλώσσα υψηλού επιπέδου υποδηλώνει ότι δεν είναι κατασκευασµένη για να λειτουργεί σε συγκεκριµένη αρχιτεκτονική υπολογιστή αλλά δύναται να λειτουργήσει σε πληθώρα αρχιτεκτονικών, γεγονός που σηµαίνει ότι: Οι διάφορες αρχιτεκτονικές υπολογιστών για να λειτουργήσουν χρησιµοποιούν ένα σύνολο εντολών, το οποίο χρησιµοποιεί τη γλώσσα µηχανής της εκάστοτε αρχιτεκτονικής.
Εποµένως, έαν κάποιος προγραµµατίσει κάνοντας χρήση της γλώσσας µηχανής µίας αρχιτεκτονικής, τα προγράµµατά του δε θα είναι συµβατά µε άλλες αρχιτεκτονικές.
Το αντιστάθµισµα αυτού του µειονεκτήµατος είναι ότι στο παρελθόν, που οι υπολογιστές είχαν λίγη µνήµη και χαµηλή ταχύτητα, ο προγραµµατισµός σε γλώσσα µηχανής χειριζόταν αποδοτικότερα τους πόρους του Για να είναι µία γλώσσα συµβατή µε τις γλώσσες µηχανής διαφόρων αρχιτεκτονικών, θα πρέπει να λαµβάνει χώρα µεταγλώττιση από τη γλώσσα προγραµµατισµού στην εκάστοτε γλώσσα µηχανής.
Όντως αυτό συµβαίνει και το λογισµικό που επιτελεί τη συγκεκριµένη εργασία ονοµάζεται µεταγλωττιστής
Με βάση τα παραπάνω, οι γλώσσες προγραµµατισµού υψηλού επιπέδου είναι µεταγλωττισµένες γλώσσες, αποσκοπώντας στο να είναι ευανάγνωστες και Σε ό,τι αφορά τη C, παρουσιάζει µία σειρά από ενδιαφέροντα και χρήσιµα Μπορεί να χρησιµοποιηθεί και ως γλώσσα προγραµµατισµού χαµηλού επιπέδου, επιτρέποντας άµεση πρόσβαση στους πόρους του υπολογιστή.
Είναι σχετικά µικρή και εύκολη στην εκµάθηση.
Υποστηρίζει δοµηµένο προγραµµατισµό.
Είναι αποτελεσµατική, παράγοντας συµπαγή και γρήγορα στην εκτέλεση Αποτελεί µαζί µε τη C++ τις ευρύτερα χρησιµοποιούµενες γλώσσες σε ερευνητικά και αναπτυξιακά προγράµµατα, γεγονός που έχει δηµιουργήσει µία πολλή µεγάλη εγκατεστηµένη βάση εφαρµογών που αναπτύχθηκαν µε αυτές τις γλώσσες και πρέπει να συντηρούνται και να εξελίσσονται.
Η C επινοήθηκε το 1972 από τον Dennis Ritchie, στα εργαστήρια Bell.
∆ηµιουργήθηκε για να εξυπηρετήσει το λειτουργικό σύστηµα Unix, το οποίο έως τότε ήταν γραµµένο σε assembly.
Ο δηµιουργός του Unix, Ken Thompson, φίλος και συνεργάτης του Ritchie, είχε δηµιουργήσει την πρόγονο της C, τη γλώσσα B.
Και οι δύο γλώσσες έχουν κοινή καταγωγή από τη γλώσσα BCPL, η οποία είχε αναπτυχθεί από τον Martin Richards κατά το πέρασµά του απο το Τεχνολογικό Ινστιτούτο της Μασσαχουσέττης (MIT) το 1967, στηριζόµενη στη γλώσσα CPL (Cambridge Programming Language) του πανεπιστηµίου του Cambridge.
Και οι τρεις γλώσσες κατασκευάστηκαν στα πλαίσια του προγράµµατος MAC και του απόγονού του Multics, τα οποία στόχευαν στην κατανοµή των πόρων των υπολογιστών σε πολλούς χρήστες.
Τα δύο αυτά προγράµµατα, στα οποία συνέπραξαν το ΜΙΤ, η General Electric και τα εργαστήρια Bell, απετέλεσαν τη θερµοκοιτίδα πολλών προγραµµάτων λογισµικού, που κυριαρχούν από τη δεκαετία του 1960 έως σήµερα.
Για ενδελεχή µελέτη της ιστορίας του λογισµικού, ο αναγνώστης µπορεί να ανατρέξει στην
Η C, ούσα ευέλικτη και αποδοτική χρησιµοποιήθηκε αρχικά για τον προγραµµατισµό συστηµάτων στο Unix.
To 1974 εµφανίσθηκε από τον Brian Kernighan το πρώτο γραπτό κείµενο για τη γλώσσα, υπό τον τίτλο “Programming in C: A Tutorial”.
Το 1977 έγινε η πρώτη επίσηµη τεκµηρίωση της γλώσσας µε το βιβλίο “The C Programming Language” από τους Kernighan και Ritchie.
Το βιβλίο αυτό απετέλεσε το «ευαγγέλιο» των προγραµµατιστών της C, αποκαλούµενο «Λευκή
Με την πάροδο του χρόνου η γλώσσα C άρχισε να χρησιµοποιείται και σε άλλα πεδία εφαρµογών, πέραν του προγραµµατισµού συστηµάτων.
Η εµφάνιση των µεταγλωττιστών της γλώσσας στο MS–DOS και ο µεγάλος αριθµός προγραµµάτων βιβλιοθήκης που κατασκευάστηκαν, οδήγησαν τη γλώσσα στο απόγειό της στα τέλη της δεκαετίας του 1980.
Βέβαια η γλώσσα γνώρισε πολλές αλλαγές, οδηγούµενη τελικά στην επονοµαζόµενη ANSI έκδοση.
Η τελευταία ενηµέρωση της γλώσσας
Τα τελευταία χρόνια τα ηνία έχει λάβει ο αντικειµενοστρεφής προγραµµατισµός και στην κατεύθυνση αυτή συνέβαλλε η γλώσσα C++, που επινοήθηκε το 1983 από το ∆ανό Bjarne Stroustrup στα εργαστήρια της ΑΤ&Τ (το τµήµα των εργαστήρια Bell που πήγαν στην AT&T όταν η εταιρεία διασπάσθηκε το 1995).
H C++ – ή C µε τάξεις – µπορεί να θεωρηθεί απόγονος της C, αν και έχει αρκετές διαφορές.
Γεγονός είναι ότι αντικατέστησε τη C σε πολύ µεγάλο ποσοστό και αποτελεί σήµερα µία από τις κυρίαρχες γλώσσες προγραµµατισµού.
Εργαλεία ανάλυσης προβληµάτων Για την ανάλυση ενός προβλήµατος και την κατάρτιση του µοντέλου που θα υλοποιηθεί σε κώδικα υπάρχουν τρία εργαλεία:
Η φυσική γλώσσα (natural language), σύµφωνα µε την οποία το πρόβληµα αναλύεται σε απλές προτάσεις της καθοµιλουµένης γλώσσας, χρησιµοποιώντας το
Το διάγραµµα ροής (flow chart), σύµφωνα µε το οποίο απεικονίζεται γραφικά η εξέλιξη του προβλήµατος, µε χρήση ειδικών συµβόλων.
Ο ψευδοκώδικας (pseudocode), ο οποίος µετασχηµατίζει τη φυσική γλώσσα σε µία σειρά προτάσεων που χρησιµοποιούν το συντακτικό γλώσσας προγραµµατισµού, χωρίς να ακολουθούν επακριβώς το φορµαλισµό συγκεκριµένης γλώσσας.
∆εν υπάρχουν γενικοί κανόνες για την υιοθέτηση κάποιου από τα τρία εργαλεία.
Η χρήση καθενός εκ των τριών εξαρτάται από τον εκάστοτε προγραµµατιστή και το συγκεκριµένο πρόβληµα.
Μία ενδεικτική περιγραφή της λειτουργίας των ανωτέρω εργαλείων θα γίνει µε τη βοήθεια του ακόλουθου παραδείγµατος:
Να µετατραπούν οι βαθµοί Farenheit σε βαθµούς Κελσίου, χρησιµοποιώντας την
Με χρήση φυσικής γλώσσας Ζήτησε από το χρήστη τη θερµοκρασία σε βαθµούς F ∆ιάβασε την τιµή που δίνει ο χρήστης Αποθήκευσε την τιµή σε θέση αποθήκευσης που ονοµάζεται degF Υπολόγισε τους βαθµούς C µε χρήση µαθηµατικής σχέσης Αποθήκευσε το αποτέλεσµα σε θέση αποθήκευσης που ονοµάζεται degC Τύπωσε το περιεχόµενο της degC
Με χρήση διαγράµµατος ροής
Στάδια υλοποίησης προγράµµατος Το υπολογιστικό πρόγραµµα είναι µία ακολουθία εντολών, µε τις οποίες ο υπολογιστής εκτελεί µία συγκεκριµένη εργασία και επιλύει ένα δοθέν πρόβληµα.
Η υλοποίηση ενός προγράµµατος περιλαµβάνει τέσσερα στάδια:
Η συγγραφή του πηγαίου κώδικα (source code).
Στο βήµα αυτό χρησιµοποιείται ένας συντάκτης προγράµµατος (text editor) για τη συγγραφή του κώδικα.
Συνήθως χρησιµοποιείται ο ενσωµατωµένος συντάκτης της C.
Το αποτέλεσµα είναι ένα αρχείο κειµένου, αναγνώσιµο από οποιονδήποτε συντάκτη (DOS editor, notepad, wordpad, πρόγραµµα επεξεργασίας κειµένου), το οποίο έχει κατάληξη .c (ή .cpp εάν χρησιµοποιείται η C++).
H µεταγλώττιση του πηγαίου κώδικα (compilation).
Η διαδικασία της µεταγλώττισης εκτελείται αυτόµατα από το µεταγλωττιστή (compiler) και παράγεται ο τελικός ή αντικείµενος κώδικας (object code), που είναι ο κώδικας σε γλώσσα µηχανής.
Στο στάδιο αυτό ανιχνεύονται τα συντακτικά σφάλµατα (syntax errors), τα οποία είναι σφάλµατα που οφείλονται σε παραβίαση των συντακτικών κανόνων, και αναφέρονται υπό µορφή λίστας (οπότε µπορούν να διορθωθούν προτού εκτελεσθεί το πρόγραµµα).
Εάν δεν υπάρχουν συντακτικά σφάλµατα, το αρχείο που προκύπτει ονοµάζεται έχει το όνοµα του αρχείου του πηγαίου κώδικα και κατάληξη .obj.
Η σύνδεση του αντικείµενου κώδικα.
Στο τρίτο στάδιο επιτελείται η διεργασία της σύνδεσης (linking), η οποία είναι πλήρως αυτοµατοποιηµένη και γίνεται µε χρήση του συνδέτη (linker).
Το αποτέλεσµα της σύνδεσης είναι η δηµιουργία του εκτελέσιµου κώδικα ή η αναφορά τυχόν προβληµάτων, όπως για παράδειγµα η αδυναµία εντοπισµού µίας συνάρτησης ή µίας εξωτερικής µεταβλητής.
Ο εκτελέσιµος κώδικας αποθηκεύεται σε αρχείο που έχει το όνοµα του πηγαίου κώδικα και επέκταση .exe.
Πλέον το πρόγραµµα έχει ξεφύγει από το περιβάλλον της γλώσσας προγραµµατισµού και µπορεί να εκτελεσθεί όπως ένα οποιοδήποτε εκτελέσιµο αρχείο του υπολογιστή.
Ο συνδέτης έχει τη δυνατότητα να συνδέσει περισσότερα του ενός αρχεία αντικείµενου κώδικα.
Επιπλέον, αναζητά σε βιβλιοθήκες τα σώµατα των συναρτήσεων που ο προγραµµατιστής χρησιµοποίησε στο πρόγραµµά του (λεπτοµέρειες στην §1.5 και σε επόµενα κεφάλαια).
Η εκτέλεση του προγράµµατος.
Στο τελευταίο στάδιο εκτελείται ή «τρέχει» το αρχείο .exe και ελέγχεται η ορθή λειτουργία του προγράµµατος.
Τα σφάλµατα που ανακύπτουν στο στάδιο αυτό ονοµάζονται σηµασιολογικά σφάλµατα (semantic errors).
Οφείλονται σε κακή σχεδίαση της λύσης του προβλήµατος και, δυστυχώς, αναγνωρίζονται στο χρόνο εκτέλεσης.
Χαρακτηριστικό σφάλµα εκτέλεσης είναι η διαίρεση αριθµού µε το µηδέν, ενέργεια που δεν ανιχνεύεται ως λανθασµένη κατά τη
Σε περίπτωση σφάλµατος, ο προγραµµατιστής επιστρέφει στο πρώτο στάδιο, όπου κάνει τις διορθώσεις, και επαναλαµβάνει τα υπόλοιπα στάδια έως ότου το πρόγραµµα λειτουργήσει επιτυχώς.
Βασικά στοιχεία προγράµµατος Έστω το ακόλουθο απλό πρόγραµµα:
Η καρδιά ενός προγράµµατος της γλώσσας C είναι η λέξη main.
Αντιστοιχεί στο κύριο τµήµα του κώδικα και χρησιµοποιείται για να γνωστοποιήσει το σηµείο έναρξης εκτέλεσης του προγράµµατος.
Μετά τη main ακολουθεί το εισαγωγικό αριστερό άγκιστρο ({) και κατόπιν οι γραµµές του προγράµµατος.
Η main, και µαζί το πρόγραµµα, τερµατίζει µε το καταληκτικό δεξί άγκιστρο (}).
Στο παρόν πρόγραµµα η main αποτελείται από µία µόνο πρόταση κλήσης της συνάρτησης printf, η οποία ανήκει στη βασική βιβλιοθήκη συναρτήσεων της C.
Η βιβλιοθήκη συναρτήσεων περιλαµβάνει τον κώδικα πρότυπων συναρτήσεων και αποτελείται από µία σειρά αρχείων, τα οποία έχουν την κατάληξη h.
Τα αρχεία αυτά ονοµάζονται αρχεία κεφαλίδας (header files) και περιλαµβάνουν συναρτήσεις συναφούς λειτουργίας.
∆ηλώνονται πριν από τη main, µε χρήση της οδηγίας προς τον προεπεξεργαστή include ως εξής: #include <όνοµα_αρχείου_κεφαλίδας.h> Στην παρούσα περίπτωση το αρχείο κεφαλίδας είναι το stdio.h (standard input– output), το οποίο περιλαµβάνει συναρτήσεις σχετιζόµενες µε τις συσκευές εισόδου (π.χ. πληκτρολόγιο) και εξόδου (π.χ. οθόνη).
Η συνάρτηση main εκτός από προτάσεις και κλήσεις σε συναρτήσεις βιβλιοθήκης µπορεί να καλεί και άλλες συναρτήσεις, οι οποίες δηµιουργούνται από το προγραµµατιστή.
Μία συνάρτηση είναι ένα σύνολο προτάσεων µε ένα δεδοµένο όνοµα, όπως είναι η main ή η printf.
Οι προτάσεις αποτελούν το σώµα (body) της συνάρτησης και περικλείονται σε άγκιστρα.
Οι συναρτήσεις πριν από τη main και αναπτύσσουν τον κώδικά τους είτε πάνω είτε κάτω από τη main1.
Όλες οι προτάσεις τελειώνουν µε ερωτηµατικό (;) (semicolon), το οποίο ονοµάζεται σύµβολο του τερµατιστή προτάσεων (statement terminator symbol).
Eξαίρεση αποτελούν οι οδηγίες προς τον προεπεξεργαστή, όπως είναι η include, οι οποίες αρχίζουν πάντοτε µε δίεση (#) και δεν τελειώνουν µε ερωτηµατικό.
Η έξοδος του προγράµµατος είναι η έξοδος της printf: This is a test.
Οι τρεις πρώτες γραµµές του ανωτέρω προγράµµατος είναι σχόλια (comments) και δεν αποτελούν τµήµα του κώδικα, καθώς δε λαµβάνονται υπόψη από το µεταγλωττιστή.
To σχόλιο είναι κείµενο ανάµεσα σε /* και */ και µπορεί να τοποθετηθεί οπουδήποτε µέσα στο πρόγραµµα.
Μπορεί να επεκταθεί σε περισσότερες από µία γραµµές.
Σε περίπτωση που πρέπει να τοποθετηθεί ένα σχόλιο σε κάποιο σηµείο µίας γραµµής και να µην επεκταθεί σε άλλη γραµµή, χρησιµοποιείται το 1 Λεπτοµερής ανάλυση του συντακτικού και της λειτουργίας των συναρτήσεων στο αντίστοιχο σύµβολο // και ακολούθως τοποθετείται το σχόλιο, όπως συµβαίνει στο τέλος του ανωτέρω προγράµµατος (το κείµενο end of main είναι σχόλιο).
Τα σχόλια πρέπει να χρησιµοποιούνται αφειδώς γιατί καταστούν τον κώδικα ευανάγνωστο και συνεισφέρουν στην επεξήγηση δυσνόητων σηµείων.
Είναι θεµιτό να ευθυγραµµίζονται τα σύµβολα των σχολίων και να µην τοποθετούνται ποτέ σχόλια µέσα σε σχόλια (ένθετα σχόλια) γιατί µπορεί να δηµιουργηθεί πρόβληµα σε µερικούς
Παρακάτω παρουσιάζονται µερικές περιπτώσεις σωστών και λανθασµένων α) /* Αυτό /* το σχόλιο */ είναι λανθασµένο */
Η γλώσσα C διαχωρίζει τα κεφαλαία γράµµατα από τα µικρά (case sensitive).
Η εντολή Printf δεν είναι ίδια µε την printf.
Όλες οι εντολές στη C γράφονται µε µικρά
Η σωστή στηλοθεσία είναι πολύ σηµαντική καθώς καθιστά τον κώδικα
Η συνάρτηση printf ανήκει στις µορφοποιούµενες συναρτήσεις εισόδου– εξόδου.
Ονοµάζεται µορφοποιούµενη γιατί δίνει τη δυνατότητα στο χρήστη να µορφοποιήσει την έξοδό της, δυνάµενη να εκτυπώσει µεταβλητές διαφόρων τύπων και µε διάφορους τρόπους, χρησιµοποιώντας κατάλληλα σύµβολα.
∆υαδική της printf είναι η scanf, η οποία λαµβάνει πληροφορία από την είσοδο (πληκτρολόγιο).
Η πρόταση printf( "This is a test.\n" ); καλεί την printf για να τυπωθεί το καθορισµένο κείµενο.
Τα ορίσµατα εισόδου (input arguments) περικλείονται από παρενθέσεις και προσδιορίζουν το προς εκτύπωση κείµενο και τη µορφή µε την οποία θα εκτυπωθεί.
Τέλος, το σύµβολο \n, που ανήκει στις ακολουθίες διαφυγής, σηµαίνει «µετακινήσου στην επόµενη γραµµή».
Λεπτοµερής περιγραφή της λειτουργίας των συναρτήσεων εισόδου – εξόδου δίνεται στο επόµενο κεφάλαιο.
Πέραν της include, µία σηµαντική οδηγία προς τον προεπεξεργαστή είναι η define, η οποία αντιστοιχίζει ένα όνοµα µε µία σταθερά ή µε µία σειρά χαρακτήρων.
Οποτεδήποτε εµφανίζεται το όνοµα µέσα στον κώδικα, αντικαθίσταται αυτόµατα µε την τιµή της σταθεράς ή τη συµβολοσειρά.
Για παράδειγµα, εάν χρησιµοποιηθεί η λέξη TRUE στη θέση της τιµής 1 και η λέξη FALSE στη θέση της τιµής 0, θα δοθούν δύο define ως εξής:
Εάν αντικατασταθεί ολόκληρη φράση, µπορεί να εµφανισθεί στην οθόνη µε χρήση
Μία συνηθισµένη χρήση της define είναι για τον καθορισµό του µεγέθους στοιχείων, όπως είναι η διάσταση ενός πίνακα, τα οποία µπορεί να αλλάξουν κατά την εκτέλεση του προγράµµατος.
Περισσότερα για αυτό το ζήτηµα θα αναφερθούν
Λεξιλόγιο της γλώσσας C Από τα αναφερθέντα στην προηγούµενη παράγραφο γίνεται φανερό ότι η λειτουργία τής C στηρίζεται σε ένα λεξιλόγιο.
Το λεξιλόγιο της C περιλαµβάνει τέσσερις µείζονες κατηγορίες λέξεων:
Οι δεσµευµένες λέξεις (reserved words) χρησιµοποιούνται από τη C κατά τρόπο αποκλειστικό και πρέπει να αποφεύγεται η χρήση τους ως ονόµατα.
Αποτελούνται Ονόµατα συναρτήσεων πρότυπης βιβλιοθήκης (runtime function names), όπως Macro names.
Είναι ονόµατα που περιέχονται σε αρχεία κεφαλίδας για ορισµό µακροεντολών, π.χ.
Τype names.
Είναι ονόµατα τύπων σε ορισµένα αρχεία κεφαλίδας, π.χ. time_t, Ονόµατα εντολών προεπεξεργαστή (preprocessor).
Είναι ονόµατα που χρησιµοποιεί προεπεξεργαστής της C και έχουν προκαθορισµένη σηµασία, π.χ.
Ονόµατα που αρχίζουν µε το χαρακτήρα υπογράµµισης _ και έχουν δεύτερο χαρακτήρα τον ίδιο ή κεφαλαίο γράµµα, π.χ. _DATE_, _FILE_.
Οι λέξεις κλειδιά (keywords) είναι λεκτικές µονάδες, οι οποίες είτε µόνες τους είτε µε άλλες λεκτικές µονάδες χαρακτηρίζουν κάποια γλωσσική κατασκευή.
Π.χ. η λέξη int αναπαριστά τον ακέραιο τύπο δεδοµένων και το ζεύγος if–else χρησιµοποιείται στον έλεγχο ροής προγράµµατος.
Οι λέξεις κλειδιά, αν και είναι ένας περιορισµός των γλωσσών, αυξάνουν την αναγνωσιµότητα και αξιοπιστία των προγραµµάτων ενώ ταυτόχρονα επιταχύνουν τη διαδικασία της µεταγλώττισης.
Λέξεις κλειδιά όπως if, else, for, case, while, do έχουν γίνει κοινά αποδεκτές, διευκολύνοντας την εκµάθηση των γλωσσών
Στον πίνακα που ακολουθεί παρατίθενται οι λέξεις κλειδιά της C:
Πίνακας 1-1.
Λέξεις κλειδιά της C
Οι αναγνωριστές (identifiers) είναι λεκτικές µονάδες που κατασκευάζει ο προγραµµατιστής.
Αυτές οι λεκτικές µονάδες χρησιµοποιούνται συνήθως ως ονόµατα που ο προγραµµατιστής δίνει σε δικές του κατασκευές, όπως µεταβλητές, σταθερές, συναρτήσεις και δικούς του τύπους δεδοµένων.
Ένα όνοµα προσδιορίζει µοναδιαία, από το σύνολο των κατασκευών του προγράµµατος, την κατασκευή στην οποία αποδόθηκε, εξ ου και το όνοµα αναγνωριστής.
Περισσότερα στοιχεία για τους αναγνωριστές σηµειώνονται στην §2.1.2.
Κανόνες δηµιουργίας ευανώγνωστων
Θα πρέπει να αποφεύγονται ονόµατα ενός χαρακτήρα, όπως i, j, x, y (εκτός από ειδικές περιπτώσεις που θα εξετασθούν αργότερα).
Τα ονόµατα που χρησιµοποιούνται θα πρέπει να είναι εκφραστικά ονόµατα.
Η µεταβλητή που αναπαριστά την ταχύτητα θα µπορούσε να ονοµασθεί velocity και τη µέγιστη τιµή της max_velocity ή maxVelocity.
Η συνάρτηση που εµφανίζει τα λάθη στην οθόνη µπορεί να λάβει τα ενδεικτικά ονόµατα display_error ή displayError.
Για καλύτερη αναγνωσιµότητα των µεταβλητών που αποτελούνται από δύο ή περισσότερες λέξεις ο προγραµµατιστής θα πρέπει να αποφασίσει εάν θα χρησιµοποιήσει τη µορφή display_error ή τη µορφή displayError.
Η σύµβαση που θα επιλεγεί θα πρέπει να τηρηθεί σε όλο το πρόγραµµα.
Θα πρέπει να χρησιµοποιούνται µικρά γράµµατα για ονόµατα µεταβλητών.
Μεταβλητές - σταθερές - Ι/Ο κονσόλας
Η έννοια της µεταβλητής Ένα από τα βασικότερα πλεονεκτήµατα του υπολογιστή είναι η δυνατότητά του να διαχειρίζεται πληροφορία, σε µορφή αριθµητικών δεδοµένων, γραµµάτων ή ακολουθίας γραµµάτων.
Τα δεδοµένα αποθηκεύονται στη µνήµη και απαιτούν ένα µέσο για να κληθούν από τα προγράµµατα, να εισαχθούν σε υπολογισµούς και να δηµιουργήσουν νέα δεδοµένα.
Αρχικά οι προγραµµατιστές χειρίζονταν τα δεδοµένα δουλεύοντας µε τις διευθύνσεις µνήµης στις οποίες ήταν αποθηκευµένα.
Με την αύξηση του µεγέθους και της πολυπλοκότητας των προγραµµάτων, αυτός ο τρόπος διαχείρισης έθετε πολλούς περιορισµούς και αποτελούσε πηγή προβληµάτων.
Η λύση στο πρόβληµα της αναφοράς σε δεδοµένα και στη διαχείρισή τους δόθηκε µε την εισαγωγή της έννοιας των µεταβλητών, οι οποίες είναι φορείς δεδοµένων.
Το όνοµα µίας µεταβλητής είναι άµεσα συνδεδεµένο µε τη διεύθυνση στην οποία είναι αποθηκευµένο το δεδοµένο.
Με τον τρόπο αυτό ο προγραµµατιστής µπορεί να χειρισθεί δεδοµένα χωρίς να γνωρίζει την ακριβή διεύθυνση της µνήµης όπου αυτά
Επιγραµµατικά, η χρήση των µεταβλητών είναι ίδια µε εκείνη της άλγεβρας, π.χ. η παράσταση y=3x+5 ισχύει τόσο στα µαθηµατικά όσο και στις γλώσσες προγραµµατισµού, µε τα x και y να είναι µεταβλητές.
Ωστόσο στον προγραµµατισµό η χρήση της είναι γενικευµένη: η µεταβλητή είναι µία θέση µνήµης για ένα δεδοµένο.
∆ηµιουργείται όταν δηλώνεται και η τιµή της µπορεί να είναι άγνωστη έως ότου χρησιµοποιηθεί από το πρόγραµµα.
Οι µεταβλητές δηλώνονται µε πρόταση ορισµού, η οποία τελειώνει πάντοτε µε (;).
Η µορφή της δήλωσης είναι: data_type var, var, …;
Οι µεταβλητές δηλώνονται στην αρχή µίας συνάρτησης, συνήθως αµέσως µετά το εισαγωγικό άγκιστρο ({), και οπωσδήποτε πριν από τη χρήση τους.
Η δήλωση γνωστοποιεί στο µεταγλωττιστή το όνοµα και τις ιδιότητες της µεταβλητής.
Μία δήλωση έχει ως αποτέλεσµα τη σύνδεση του ονόµατος της τον ανάλογο τύπο δεδοµένων, γεγονός που λαµβάνει χώρα στο χρόνο µεταγλώττισης (compile–time) µία θέση µνήµης κατάλληλου µεγέθους, γεγονός που λαµβάνει χώρα στο χρόνο εκτέλεσης (run–time)
Σε ό,τι αφορά την ονοµατολογία, ακολουθούνται οι εξής κανόνες: Στην C τα ονόµατα των µεταβλητών σχηµατίζονται από: α) τα γράµµατα του αλφαβήτου γ) το χαρακτήρα υπογράµµισης __ (underscore) Το όνοµα πρέπει να ξεκινά µε γράµµα ή µε χαρακτήρα υπογράµµισης (στη δεύτερη περίπτωση ο επόµενος χαρακτήρας πρέπει να είναι µικρό γράµµα).
Το όνοµα δεν πρέπει να είναι ίδιο µε δεσµευµένη λέξη.
Σηµαντικοί είναι µόνο οι πρώτοι 31 χαρακτήρες του ονόµατος.
Οι υπόλοιποι δε Τα όνοµα µεταβλητής πρέπει να είναι ενδεικτικό της ιδιότητάς της ή του τύπου δεδοµένου που αντιπροσωπεύει, έτσι ώστε να δίνει πληροφορία στον
Με βάση τα παραπάνω, ακολουθούν ενδεικτικές περιπτώσεις ονοµατολογίας.
Έγκυρα ονόµατα µεταβλητών: Μη έγκυρα ονόµατα µεταβλητών: Απαράδεκτα ονόµατα µεταβλητών: 1 Στην πορεία ανάγνωσης του κειµένου ο αναγνώστης θα παρατηρήσει ότι οι ονοµασίες των µεταβλητών δε συνάδουν πάντοτε µε τους κανόνες που αναφέρονται, καθώς χρησιµοποιούνται
Οι µεταβλητές της γώσσας C ανήκουν σε δύο κατηγορίες.
Η κατηγορία των βαθµωτών τύπων περιλαµβάνει τους ακέραιους (integers), οι οποίοι δηλώνονται µε την κωδική λέξη int, τους πραγµατικούς, οι οποίοι µερίζονται στους αριθµούς κινητής υποδιαστολής µε κωδική λέξη float και τους αριθµούς διπλής ακρίβειας µε κωδική λέξη double, τη µεταβλητή χαρακτήρα (character, char), τους δείκτες (pointers) και τον απαριθµητικό τύπο (enumerated, enum).
Στην κατηγορία των συναθροιστικών τύπων ανήκουν οι πίνακες, οι δοµές (struct) και οι ενώσεις (union).
Στη συνέχεια του κεφαλαίου γίνεται αναφορά στους βασικούς τύπους της C: char, int, float, double και σε επόµενο κεφάλαιο αναπτύσσονται οι πίνακες.
Οι άλλοι τύποι µεταβλητών θα µελετηθούν αργότερα.
Ο τύπος του χαρακτήρα Ο τύπος του χαρακτήρα (char) παριστάνει απλούς χαρακτήρες του αλφάβητου της γλώσσας.
Βρίσκεται ανάµεσα σε απλά εισαγωγικά (π.χ. 'C', '2', '*', ')').
Η δήλωση της µεταβλητής χαρακτήρα ακολουθεί τον εξής φορµαλισµό: char όνοµα_µεταβλητής; π.χ. char choice;
Υπάρχει η δυνατότητα ταυτόχρονα µε τη δήλωση να αποδοθεί αρχική τιµή στη
Η εισαγωγή τιµών στις µεταβλητές χαρακτήρα γίνεται µε χρήση της συνάρτησης scanf και του προσδιοριστή (specifier) %c (character).
Η πρόταση διαβάζει από την κύρια είσοδο (πληκτρολόγιο) ένα χαρακτήρα και τον αποδίδει στη µεταβλητή ch.
Θα πρέπει να προσεχθεί η χρήση του & πριν από τη µεταβλητή.
Ονοµάζεται τελεστής διεύθυνσης και προηγείται πάντοτε των µεταβλητών στην µεταβλητές µε ένα ή δύο γράµµατα.
Η χρήση τους γίνεται συγγραφική αδεία, επιβληθείσα για λόγους πρακτικούς, έτσι ώστε να µη διευρύνεται ο κώδικας.
Η εκτύπωση µεταβλητών χαρακτήρα γίνεται µε χρήση της συνάρτησης printf και του προσδιοριστή %c.
Η πρόταση θα τυπώσει (θεωρώντας ότι στη choice εισήχθη ο Α)
Παρατήρηση: Επειδή κάθε χαρακτήρας του κώδικα ASCII (American Standard Code for Information Interchange) αντιστοιχεί σε έναν οκταψήφιο δυαδικό αριθµό, εάν αντί του %c χρησιµοποιηθεί ο προσδιοριστής %d (decimal), η printf θα εµφανίσει τον ASCII κωδικό τού χαρακτήρα.
Η πρόταση όπου 65 είναι το δεκαδικό ισοδύναµο του δυαδικού κωδικού ASCII για το χαρακτήρα Ο µεταγλωττιστής απαιτεί 1 byte µνήµης για την αποθήκευση της τιµής µίας µεταβλητής χαρακτήρα.
Στο σχήµα 2-1 παρουσιάζονται οι διαδικασίες της αποθήκευσης και ανάκλησης για το χαρακτήρα Α.
Η τιµή της µεταβλητής µετατρέπεται σε ακέραιο (ενέργεια 1 του σχήµατος 2-1), ο οποίος αποθηκεύεται (ενέργεια 2).
Στην περίπτωση ανάκλησης της τιµής, εκτελείται η αντίστροφη διεργασία.
Ο αριθµός µετατρέπεται σε χαρακτήρα µέσω του προσδιοριστή %c και ακολούθως είτε τυπώνεται ο χαρακτήρας (ενέργεια 3) είτε τυπώνεται το δεκαδικό ισοδύναµο µέσω του προσδιοριστή %d (ενέργεια 4).
Σε κάθε περίπτωση, ο µεταγλωττιστής είναι υπεύθυνος για το ότι ο υπολογιστής διαχειρίζεται τα bits και bytes σύµφωνα µε τους τύπους που δηλώνονται.
Οι σταθερές τύπου χαρακτήρα «νέα γραµµή (new-line)» και «στηλοθέτης (tab)» ανήκουν στην κατηγορία των µη εκτυπούµενων χαρακτήρων, τους οποίους η C αναπαριστά µε τις «ακολουθίες διαφυγής (escape sequences)» \n και \t, αντίστοιχα.
Η παρακάτω πρόταση δίνεται ως παράδειγµα χρήσης χαρακτήρων διαφυγής:
Η πρόταση θα εµφανίσει στην κύρια έξοδο (οθόνη):
Οι µη εκτυπούµενοι χαρακτήρες και οι αντίστοιχες ακολουθίες διαφυγής παρατίθενται στον πίνακα 2-1:
Χαρακτήρας Ακολουθία Χαρακτήρας Ακολουθία συναγερµός (κουδούνι) \a πλάγια γραµµή \\ οπισθοχώρηση \b λατινικό ερωτηµατικό \? αλλαγή σελίδας \f µονό εισαγωγικό \’ νέα γραµµή \n διπλό εισαγωγικό \” επαναφορά κεφαλής \r οκταδικός αριθµός \ooo οριζόντιος στηλοθέτης \t δεκαεξαδικός αριθµός \xhhh
Πίνακας 2-1.
Μη εκτυπούµενοι χαρακτήρες και αντίστοιχες ακολουθίες διαφυγής
Να καταστρωθεί πρόγραµµα που να επιτελεί τα παρακάτω: Ζήτησε από το χρήστη ένα χαρακτήρα Πάρε από το χρήστη το χαρακτήρα
Τύπωσε το χαρακτήρα και τον ASCII κωδικό του Βρες τον επόµενο χαρακτήρα Τύπωσέ τον µαζί µε τον κωδικό του next_ch=ch+1; /* βρίσκει τον επόµενο χαρακτήρα */
Ο τύπος του ακεραίου Ο τύπος του ακεραίου (int από τη λέξη integer) χρησιµοποιείται για να παραστήσει ακέραιους αριθµούς.
Η περιοχή τιµών εξαρτάται από την αρχιτεκτονική του µηχανήµατος.
Για έναν υπολογιστή που διαθέτει 2 bytes (16 bits) για κάθε ακέραιο, το σύνολο των δυνατών τιµών είναι 162 65536=.
Εάν θεωρηθεί ότι τις µισές τιµές θα καταλάβουν αρνητικοί ακέραιοι και τις υπόλοιπες µισές θετικοί, η περιοχή τιµών του τύπου int είναι από -32768 έως +32767, µε την ακόλουθη αντιστοιχία δυαδικής και δεκαδικής τιµής:
Η δήλωση της µεταβλητής ακεραίου ακολουθεί τον εξής φορµαλισµό: int όνοµα_µεταβλητής; π.χ. int num;
Εάν πριν από τη λέξη int τοποθετηθεί ο προσδιοριστής long τότε οι ακέραιοι long int εξασφαλίζουν αποθηκευτικό χώρο 32 bits.
Αντίστοιχα, ο προσδιοριστής unsigned χρησιµοποιείται πριν από τη λέξη int για να χαρακτηρίσει τη µεταβλητή χωρίς πρόσηµο, η οποία λαµβάνει τιµές από 0 έως 65535 για ακέραιο 16 bits.
Σε περιβάλλοντα 4 bytes (32 bits) όπως τα Windows XP, το σύνολο των δυνατών τιµών είναι 322 4.294.967.296=.
Έτσι οι προσηµασµένοι ακέραιοι αποθηκεύουν τιµές στο διάστηµα από -2.147.483.648 έως +2.147.483.647.
Ένας ακέραιος short int είναι τουλάχιστον 16 bits και ο int είναι τουλάχιστον τόσο µεγάλος όσο ο short int (συνήθως είναι 32 bits).
Η εισαγωγή τιµών στις ακέραιες µεταβλητές γίνεται µε χρήση της συνάρτησης scanf και του προσδιοριστή %d.
Η πρόταση διαβάζει από το πληκτρολόγιο έναν ακέραιο και τον αποδίδει στη µεταβλητή num.
Η εκτύπωση ακέραιων µεταβλητών γίνεται µε χρήση της συνάρτησης printf και των προσδιοριστών %d, %o, %x για την εµφάνιση σε δεκαδική, οκταδική και δεκαεξαδική µορφή, αντίστοιχα.
Οι προσδιοριστές l (long), h (short), και u (unsigned) τοποθετούνται πριν από τους d, o, x.
H πρόταση θα τυπώσει (θεωρώντας ότι η num λαµβάνει την τιµή 46):
Υπάρχει η δυνατότητα να καθορισθεί ο αριθµός των ψηφίων που θα τυπωθούν, τοποθετώντας τον επιθυµητό αριθµό ανάµεσα στο % και το d.
Εάν ο αριθµός είναι µικρότερος από τον απαιτούµενο αριθµό ψηφίων του ακέραιου, η επιλογή δε θα ληφθεί υπόψη.
Στην αντίθετη περίπτωση, στις πλεονάζουσες θέσεις θα τοποθετηθούν κενά.
Για το λόγο αυτό, ο αριθµός που τοποθετείται στον προσδιοριστή %d ονοµάζεται καθοριστικό ελάχιστου πλάτους πεδίου.
Με αυτόν τον τρόπο, σε διαδοχικές printf θα υπάρξει ευθυγράµµιση των αποτελεσµάτων κατά στήλες (βλ.
Όταν γράφεται ένας αριθµός στον πηγαίο κώδικα χωρίς δεκαδικό ή εκθετικό µέρος, ο µεταγλωττιστής το χειρίζεται ως ακέραια σταθερά.
Η σταθερά 245 αποθηκεύεται ως int, ενώ η σταθερά 100000 αποθηκεύεται ως long int.
Εάν ορισθεί η σταθερά 8965 ως 8965L, ο µεταγλωττιστής αναγκάζεται να δεσµεύσει χώρο για
Να καταστρωθεί πρόγραµµα που να εξετάζει το µήκος του τύπου ακεραίου. #include <climits.h> // limits.h για παλαιότερα συστήµατα int number_int=INT_MAX; // Μέγιστος int: ορίζεται στο climits.h short int number_short=SHRT_MAX; // Μέγιστος short int long int number_long=LONG_MAX; // Μέγιστος long integer /* ο τελεστής sizeof δίνει το µέγεθος ενός τύπου δεδοµένου
Από τα αποτελέσµατα προκύπτει ότι ταυτίζονται τα bytes για int και long, γιατί στην έκδοση 5 της Borland C++ και µε λειτουργικά συστήµατα Windows 95 και µεταγενέστερα ο int καταλαµβάνει 4 bytes.
Τύποι πραγµατικών αριθµών Οι πραγµατικοί αριθµοί είναι οι αριθµοί που διαθέτουν κλασµατικό µέρος και εκφράζονται συνήθως στις ακόλουθες µορφές:
Η γλώσσα C διαθέτει δύο τύπους για αναπαράσταση πραγµατικών αριθµών.
Τον τύπο float για αριθµούς κινητής υποδιαστολής απλής ακρίβειας και τον τύπο double για αριθµούς κινητής υποδιαστολής διπλής ακρίβειας.
Η δήλωση της µεταβλητής float ή double ακολουθεί τον εξής φορµαλισµό: float όνοµα_µεταβλητής; π.χ. float plank=6.63e-34;
Η χρήση του προσδιοριστή long πριν από τον τύπο double χρησιµοποιείται για δήλωση µεταβλητής κινητής υποδιαστολής εκτεταµένης ακρίβειας, π.χ.
Η εισαγωγή τιµών στις µεταβλητές κινητής υποδιαστολής γίνεται µε χρήση της συνάρτησης scanf και του προσδιοριστή %f (float).
Η πρόταση διαβάζει από το πληκτρολόγιο έναν πραγµατικό αριθµό και τον αποδίδει στη Η εκτύπωση πραγµατικών µεταβλητών γίνεται µε χρήση της συνάρτησης printf και των προσδιοριστών %f για εµφάνιση σε δεκαδική µορφή, %e για εµφάνιση σε εκθετική µορφή, και %g για να ανατεθεί στο σύστηµα να επιλέξει µεταξύ των δύο προηγουµένων, µε προτεραιότητα στη µορφή µε το µικρότερο µέγεθος.
Σε ό,τι αφορά το χώρο που καταλαµβάνουν στη µνήµη, ως συνηθισµένα µεγέθη αναφέρονται για τους µεν float τα 32 bits, για τους δε double τα 64 bits.
Θα πρέπει να σηµειωθεί ότι, σε αντιδιαστολή µε τους ακέραιους αριθµούς, δεν υπάρχει αντιστοιχία ένα προς ένα ανάµεσα στους πραγµατικούς αριθµούς και στις απεικονίσεις τους στις γλώσσες προγραµµατισµού.
Οι αριθµοί που αντιστοιχούν στους πραγµατικούς αριθµούς είναι προσεγγίσεις αυτών και ονοµάζονται αριθµοί µηχανής, εξαιτίας της ανάγκης να απεικονισθούν µε πεπερασµένο αριθµό ψηφίων πραγµατικοί αριθµοί που θεωρητικά µπορούν να περιέχουν άπειρο αριθµό κλασµατικών ψηφίων.
Σε µία µεταβλητή τύπου float των 32 bits τα 8 bits χρησιµοποιούνται για τον εκθέτη, ένα για το πρόσηµο και τα υπόλοιπα 23 για το κλασµατικό µέρος.
Η µορφή του αριθµού είναι η ακόλουθη: όπου τα ψηφία 1d ... 23d είναι δυαδικά και το e είναι το δεκαδικό ισοδύναµο του οκταψήφιου δυαδικού εκθέτη.
Κατά σύµβαση το 1 1d =.
Το δεκαδικό ισοδύναµο της ανωτέρω µορφής είναι:
Κατά συνέπεια, µε βάση το παραπάνω σύστηµα απεικόνισης το µέγεθος της κλασµατικής ακρίβειας ενός αριθµού κινητής υποδιαστολής καθορίζεται από τον αριθµό των κλασµατικών ψηφίων.
Ο οκταψήφιος δυαδικός εκθέτης αντιστοιχεί σε 82 256= δυνατές τιµές.
Από αυτές οι 127 δίνονται σε αρνητικούς ακέραιους και οι υπόλοιπες 129 σε θετικούς, µε την ακόλουθη αντιστοιχία δυαδικής και δεκαδικής τιµής:
Με βάση τα παραπάνω, η µέγιστη απόλυτη τιµή πραγµατικών αριθµών που µπορεί να επιτευχθεί µε µεταβλητή τύπου float των 32 bits είναι (βλ.
Παράδειγµα 2.3): Στους αριθµούς διπλής ακρίβειας δεσµεύονται 64 bits, εκ των οποίων τα 11 δίνονται στον εκθέτη, ένα στο πρόσηµο και 52 στο κλασµατικό µέρος.
Όπως σηµειώθηκε στους ακέραιους, έτσι και στους πραγµατικούς υπάρχει η δυνατότητα να καθορισθεί ο αριθµός των ψηφίων που θα εκτυπωθούν, τοποθετώντας τον επιθυµητό αριθµό ανάµεσα στο % και το f.
Μάλιστα ο αριθµός θα είναι της µορφής a.b, µε το a να δηλώνει το συνολικό αριθµό των ψηφίων – συµπεριλαµβανοµένου του προσήµου – και το b να δηλώνει τον αριθµό των δεκαδικών ψηφίων.
Οι προτάσεις
Eίναι φανερό ότι στην περίπτωση που ο αριθµός των δεκαδικών ψηφίων που ζητούνται είναι µικρότερος από τον απαιτούµενο γίνεται στρογγυλοποίηση (το 37 στρογγυλοποιήθηκε στο 40 και παρελήφθη το 0).
Πραγµατικοί αριθµοί όπως οι όταν εµφανίζονται στον πηγαίο κώδικα αποτελούν τις πραγµατικές σταθερές.
Θεωρούνται από το µεταγλωττιστή ως double και δεσµεύουν τον αντίστοιχο χώρο.
Να καταστρωθεί πρόγραµµα που να εξετάζει το µήκος του τύπου κινητής #include <float.h> // για τα όρια του float float num_float=FLT_MAX; // Μέγιστος float double num_double=DBL_MAX; // Μέγιστος double num_dοuble,DBL_MIN);
Η Ι/Ο κονσόλας αναφέρεται στις λειτουργίες που γίνονται στο πληκτρολόγιο και στην οθόνη του υπολογιστή.
Πέραν των printf και scanf, που χρησιµοποιήθηκαν προγουµένως (και αποτελούν τη µορφοποιούµενη Ι/Ο κονσόλας γιατί µπορούν να διαβάζουν και να τυπώσουν δεδοµένα σε διάφορες µορφές), υπάρχει µία σειρά απλούστερων συναρτήσεων, που αναπτύσσεται στις επόµενες παραγράφους.
Οι συναρτήσεις getche, getch H συνάρτηση getche διαβάζει ένα χαρακτήρα από την κύρια είσοδο.
Αναµένει έως ότου πατηθεί ένα πλήκτρο και στη συνέχεια επιστρέφει την τιµή του, εµφανίζοντας στην οθόνη το πλήκτρο που πατήθηκε.
Το πρωτότυπο της getche είναι και το αρχείο κεφαλίδας της συνάρτησης βρίσκεται στο conio.h.
H getche επιστρέφει µεν έναν ακέραιο αλλά το byte χαµηλής τάξης είναι αυτό που περιέχει τον χαρακτήρα.
Η χρήση ακεραίων γίνεται για λόγους συµβατότητας µε τον αρχικό µεταγλωττιστή της UNIX C.
H συνάρτηση getch αποτελεί παραλλαγή της getche και βρίσκεται επίσης στο conio.h.
Λειτουργεί όπως ακριβώς η getche, µε τη διαφορά ότι η getch δεν εµφανίζει τον πληκτρολογηθέντα χαρακτήρα στην οθόνη.
H συνάρτηση getchar (get character) διαβάζει ένα χαρακτήρα από την κύρια είσοδο και τον επιστρέφει στο πρόγραµµα.
Αποτελεί παραλλαγή της getche.
Είναι η αρχική συνάρτηση εισόδου χαρακτήρων και βασίζεται στο UNIX.
Το πρόβληµα µε τη συνάρτηση αυτή είναι ότι κρατά την είσοδο στην περιοχή προσωρινής αποθήκευσης µέχρι να δοθεί επαναφορά κεφαλής.
Έτσι, µετά την επιστροφή της getchar περιµένουν ένας ή περισσότεροι χαρακτήρες στην ουρά εισόδου.
Το πρωτότυπο της getchar είναι το ακόλουθο: και το αρχείο κεφαλίδας της συνάρτησης βρίσκεται στο stdio.h.
H συνάρτηση putchar (put character) εµφανίζει στην οθόνη το χαρακτήρα που έχει ως όρισµα (π.χ. c), στην τρέχουσα θέση του δροµέα.
Το πρωτότυπο της putchar
H putchar επιστρέφει µεν έναν ακέραιο αλλά το byte χαµηλής τάξης είναι αυτό που περιέχει το χαρακτήρα.
Όπως συνέβη και µε τις προηγούµενες συναρτήσεις, η χρήση ακεραίων γίνεται για λόγους συµβατότητας µε τον αρχικό µεταγλωττιστή της UNIX C.
Το αρχείο κεφαλίδας της συνάρτησης putchar βρίσκεται στο stdio.h.
H συνάρτηση kbhit (keyboard hit) ελέγχει κατά πόσον ο χρήστης έχει πατήσει κάποιο πλήκτρο.
Εφόσον έχει πατήσει κάποιο πλήκτρο η συνάρτηση επιστρέφει ως αληθής, σε αντίθετη περίπτωση επιστρέφει ως ψευδής.
Η συνάρτηση kbhit χρησιµοποιείται κυρίως για να διακόπτει ο χρήστης το πρόγραµµα κατά το δοκούν.
Το πρωτότυπο της kbhit είναι:
Το αρχείο κεφαλίδας της συνάρτησης kbhit βρίσκεται στο conio.h.
Παραδείγµατα όπου γίνεται χρήση της kbhit. θα παρουσιασθούν στη συνέχεια.
Το ακόλουθο πρόγραµµα παίρνει χαρακτήρες από το πληκτρολόγιο και µετατρέπει τα κεφαλαία γράµµατα σε µικρά και τούµπαλιν.
Το πρόγραµµα τερµατίζει µόλις πληκτρολογηθεί µία τελεία (.).
Το αρχείο κεφαλίδας ctype.h απαιτείται για τη συνάρτηση islower, που αληθεύει εάν το όρισµά της είναι σε µικρά γράµµατα, και τις συναρτήσεις toupper, tolower, που µετασχηµατίζουν τα γράµµατα.2 2 Ο αναγνώστης καλείται να παρακάµψει την επαναληπτική πρόταση και την υπό συνθήκη διακλάδωση.
Θα µελετηθούν εκτενώς αργότερα. while (ch!='.'); // τέλος προγράµµατος µε '.'
Οι τελεστές (operators) είναι σύµβολα ή λέξεις που αναπαριστούν συγκεκριµένες διεργασίες, οι οποίες εκτελούνται επί ενός ή περισσότερων δεδοµένων.
Τα δεδοµένα καλούνται τελεστέοι (operands) και µπορούν να είναι µεταβλητές, σταθερές ή ακόµη και κλήσεις συναρτήσεων.
Οι τελεστές χρησιµοποιούνται για το σχηµατισµό εκφράσεων.
Μία έκφραση, εν γένει, αποτελείται από έναν ή περισσότερους τελεστέους και από έναν ή περισσότερους τελεστές.
Κάθε έκφραση έχει µία τιµή, η οποία υπολογίζεται µε ορισµένους κανόνες.
Για παράδειγµα, στην έκφραση num+12 ο χαρακτήρας + αναπαριστά τη διεργασία της πρόσθεσης των δύο τελεστέων, οι οποίοι είναι η µεταβλητή num και η σταθερά 12.
Οι τελεστές ταξινοµούνται, ανάλογα µε τον αριθµό των τελεστέων στους οποίους δρουν, σε µοναδιαίους (unary), δυαδικούς (binary) και τριαδικούς (ternary).
Μία δεύτερη κατηγοριοποίηση επιτελείται µε βάση τη διεργασία που εκτελούν, οδηγώντας στις κατηγορίες του πίνακα 3-1:
Κατηγορία Ενδεικτικοί τελεστές
Πίνακας 3-1.
Κατηγορίες τελεστών
Τα σύµβολα των συνηθέστερων δυαδικών τελεστών στη C παρατίθενται στον πίνακα που ακολουθεί: ∆υαδικός τελεστής Σύµβολο ∆υαδικός τελεστής Σύµβολο µικρότερο ή ίσο <= αφαίρεση -
Μεγαλύτερο > πηλίκο διαίρεσης ακεραίων / Μεγαλύτερο ή ίσο >= υπόλοιπο διαίρεσης
Πίνακας 3-2.
Σύµβολα δυαδικών τελεστών Στη συνέχεια του κεφαλαίου θα µελετηθούν οι συνηθέστεροι των τελεστών ενώ για ενδελεχή µελέτη ο αναγνώστης µπορεί να ανατρέξει στην αναφορά [3].
Η γλώσσα C δίνει τη δυνατότητα να επιτυγχάνονται διαφορετικές λειτουργίες στην ίδια έκφραση ανάλογα µε τη θέση των τελεστών ανάµεσα στους τελεστέους.
Για το λόγο αυτό έχουν αναπτυχθεί τρεις σηµειογραφίες για τους δυαδικούς τελεστές: Η σηµειογραφία ένθεσης ή ένθετου τελεστή (infix notation), όταν ο τελεστής τοποθετείται µεταξύ των τελεστέων στους οποίους ενεργεί, όπως στην έκφραση x+y.
Η σηµειογραφία πρόθεσης ή προπορευόµενου τελεστή (prefix notation), όταν αυτός τοποθετείται πριν από τους τελεστέους, όπως στην έκφραση +x y.
Η σηµειογραφία παρελκόµενου τελεστή (postfix notation), όταν ο τελεστής τοποθετείται µετά από τους τελεστέους, όπως στην έκφραση x y+.
Οι τελεστές είναι προτιµότερο να µη χρησιµοποιούνται σε µεικτούς τύπους.
Για δεν παρουσιάζει κανένα πρόβληµα, σε αντιδιαστολή µε τον ακόλουθο µεικτό τύπο
Στη C υπάρχει διάκριση ανάµεσα στη διαίρεση ακεραίων και στη διαίρεση αριθµών κινητής υποδιαστολής.
Στη διαίρεση ακεραίων το αποτέλεσµα είναι το πηλίκο, π.χ. 5/2=2.
Για να ληφθεί ως αποτέλεσµα αριθµός κινητής υποδιαστολής, τουλάχιστον ένας από τους τελεστέους πρέπει να είναι αριθµός κινητής
Κατηγορίες εκφράσεων της C - προτεραιότητα
Οι εκφράσεις τής C µπορούν να καταταγούν στις παρακάτω κατηγορίες: Σταθερές εκφράσεις.
Είναι εκφράσεις που περιέχουν µόνο σταθερές τιµές.
Ακέραιες εκφράσεις και εκφράσεις κινητής υποδιαστολής.
Είναι εκφράσεις, οι οποίες µετά από όλες τις άµεσες και έµµεσες µετατροπές τύπων δίνουν αποτέλεσµα ακέραιου τύπου ή τύπου κινητής υποδιαστολής, αντίστοιχα.
Εκφράσεις δείκτη.
Είναι εκφράσεις µε τιµή µία διεύθυνση.
Περιλαµβάνουν µεταβλητές δείκτη, τον τελεστή διεύθυνσης (&), αλφαριθµητικές σταθερές και
Ο υπολογισµός µίας έκφρασης δεν είναι πάντοτε απλή υπόθεση, ιδιαίτερα στην περίπτωση που υπάρχουν ένθετες (nested) εκφράσεις, δηλαδή εκφράσεις που είναι φωλιασµένες µέσα σε άλλες.
Στην έκφραση η έκφραση n+5 είναι φωλιασµένη στην έκφραση (n+5)<=a, η οποία µε τη σειρά της είναι φωλιασµένη στη συνολική έκφραση.
Μία άλλη περίπτωση δυσχέρειας στον υπολογισµό είναι η διαδοχική παράθεση τελεστών: 7*8-2, η οποία µπορεί να υπολογισθεί είτε ως (7*8)-2=54 είτε ως 7*(8-2)=42, οδηγώντας σε διαφορετικά
Για να αντιµετωπισθούν οι ανωτέρω δυσχέρειες έχει υιοθετηθεί µία σειρά εφαρµογής των τελεστών, η επονοµαζόµενη εφαρµοστική σειρά (applicative order), η οποία στηρίζεται στις έννοιες της προτεραιότητας (precedence) και της προσεταιριστικότητας (associativity) των τελεστών.
Οι τελεστές ταξινοµούνται σε επίπεδα προτεραιότητας, µε τη σύµβαση ότι οι τελεστές υψηλότερου επιπέδου προτεραιότητας δρούν επί των τελεστέων πριν από τους τελεστές χαµηλότερου επιπέδου.
Η ύπαρξη περισσότερων τελεστών στο ίδιο επίπεδο προτεραιότητας επιβάλλει τον προσδιορισµό της κατεύθυνσης εφαρµογής, µε την κατεύθυνση από τα αριστερά προς τα δεξιά να είναι ευρύτερα χρησιµοποιούµενη.
Ένας τελεστής καλείται αριστερής προσεταιριστικότητας (left associative), όταν σε εκφράσεις που περιέχουν πολλά στιγµιότυπα του τελεστή η οµαδοποίηση γίνεται από τα αριστερά προς τα δεξιά.
Έτσι, η έκφραση 10-8-2 υπολογίζεται ως (10-8)-2.
Οι τελεστές +,-,*,/ είναι όλοι αριστερής προσεταιριστικότητας.
Για τη C παράδειγµα δεξιάς προσεταιριστικότητας αποτελεί η ύψωση σε δύναµη και ο τελεστής ανάθεσης (=).
Στην έκφραση num1=num2=10 εφαρµόζεται πρώτα ο δεξιός τελεστής ανάθεσης, µε αποτέλεσµα η num2 να αποκτήσει την τιµή 10, και ακολούθως εφαρµόζεται ο αριστερός τελεστής ανάθεσης, έτσι ώστε η num1 εξισώνεται µε τη num2 και αποκτά την τιµή 10.
Η προτεραιότητα και το είδος προσεταιριστικότητας των τελεστών παρατίθενται στον πίνακα 3-3, όπου οι τελεστές έχουν τεθεί µε σειρά φθίνουσας προτεραιότητας: Τελεστές Είδος προσεταιριστικότητας () [] -> από αριστερά προς τα δεξιά ! ̃ ++ - - + - * & (τύπος) sizeof από δεξιά προς τα αριστερά * / % (αριθµητικοί τελεστές) από αριστερά προς τα δεξιά ?: από δεξιά προς τα αριστερά ´ από αριστερά προς τα δεξιά
Πίνακας 3-3.
Προτεραιότητα και προσεταιριστικότητα τελεστών Με βάση τα προαναφερθέντα, είναι προφανές ότι µε τους κανόνες προτεραιότητας και προσεταιριστικότητας δεν είναι απαραίτητη η χρήση παρενθέσεων για τον προσδιορισµό του τρόπου υπολογισµού της τιµής των εκφράσεων.
Ωστόσο, οι παρενθέσεις χρησιµοποιούνται για τους ακόλουθους λόγους: Για να προσδιορισθεί συγκεκριµένη σειρά εφαρµογής, όπως στην έκφραση (2- Για να καταστεί µία έκφραση ευανάγνωστη, όπως στην έκφραση 2-(3*4), παρά το γεγονός ότι στην τελευταία περίπτωση αποτελεί πλεονασµό.
Στην περίπτωση ένθετων παρενθέσεων ο µεταγλωττιστής εφαρµόζει πρώτα τις εσωτερικές παρενθέσεις.
Για παρενθέσεις όµως που βρίσκονται στο ίδιο βάθος ένθεσης, δεν ορίζεται η σειρά υπολογισµού.
Με χρήση του πίνακα 3-3 να υπολογισθούν οι εκφράσεις:
Τελεστές αύξησης και µείωσης Ο τελεστής αύξησης (increment operator) συµβολίζεται ++.
Με χρήση αυτού του τελεστή η έκφραση num = num + 1; γίνεται num ++;
Αντίστοιχα, ο τελεστής µείωσης (decrement operator) συµβολίζεται -- και η έκφραση num = num - 1; γίνεται num --;
Προπορευόµενοι και παρελκόµενοι τελεστές µοναδιαίας αύξησης και µείωσης: να υπολογισθούν οι τιµές των x και y στις ακόλουθες διαδοχικές εκφράσεις.
Πρόταση τιµή x Τιµή y
Να προσδιορισθεί η τιµή των x και z µετά την εκτέλεση κάθε µίας από τις παρακάτω προτάσεις, θεωρώντας ότι πριν την εκτέλεση της κάθε πρότασης οι τιµές των x και y είναι το 10 και το 20 αντίστοιχα.
Στην περίπτωση του προπορευόµενου τελεστή, το σύστηµα πρώτα εκτελεί την αύξηση ή µείωση και µετά χρησιµοποιεί τη νέα τιµή της µεταβλητής στον υπολογισµό της τιµής της έκφρασης (προτάσεις α και β).
Αντίθετα, στην περίπτωση του παρελκόµενου τελεστή το σύστηµα πρώτα χρησιµοποιεί την τιµή της µεταβλητής για τον υπολογισµό της τιµής της έκφρασης και µετά εκτελεί την αύξηση ή µείωση της τιµής της µεταβλητής (προτάσεις γ και δ).
Πρόταση τιµή x τιµή z
Οι τελεστές ανάθεσης (assignment operators) εκτελούν κάποια πράξη ανάµεσα στους τελεστέους και εκχωρούν το αποτέλεσµα σε έναν από τους τελεστέους: x* = 10; εκτελεί την πράξη του πολλαπλασιασµού µεταξύ των x και 10 και εκχωρεί το αποτέλεσµα στον τελεστέο x.
Αντιστοιχεί στην πρόταση x = x * 10; x* = y + 1;
Αντιστοιχεί στην πρόταση x = x * (y + 1); κι όχι στην πρόταση Τελεστές ανάθεσης δηµιουργούν κι οι τελεστές διαχείρισης δυαδικών ψηφίων (bitwise operators).
Οι τελεστές αυτοί είναι: >>= <<= &= ^= |=.
Οι τελεστές ανάθεσης µαζί µε τους τελεστές αύξησης/µείωσης γίνονται αιτία δηµιουργίας παρενεργειών (side effects), για το λόγο αυτό αναφέρονται και ως παρενεργοί τελεστές (side effect operators).
Οι παρενέργειες αυτές έχουν ως αποτέλεσµα την απροσδιόριστη συµπεριφορά του συστήµατος ως προς τον τρόπο υπολογισµού της τιµής της µεταβλητής i σε εκφράσεις όπως: i = n[i++]; ή i = ++i +
Οι συσχετιστικοί τελεστές (relational operators) συγκρίνουν δύο τελεστέους.
Οι βασικοί τελεστές της κατηγορίας αυτής παρατίθενται στον πίνακα 3-4: <= µικρότερο ή ίσον από
Πίνακας 3-4.
Συσχετιστικοί τελεστές Το αποτέλεσµα της χρήσης των συσχετιστικών τελεστών είναι είτε ΑΛΗΘΕΣ (true) είτε ΨΕΥ∆ΕΣ (false).
Για παράδειγµα, η τιµή της έκφρασης (3 < 2) είναι ψευδής ενώ η τιµή της έκφρασης (2 = = 2) είναι αληθής.
Στη C (και σε πολλές άλλες γλώσσες προγραµµατισµού) η τιµή ΑΛΗΘΗΣ αντιστοιχεί στον ακέραιο 1 και η τιµή ΨΕΥ∆ΗΣ αντιστοιχεί στον ακέραιο 0.
Παρατήρηση: Συγκρίνοντας τους αριθµητικούς µε τους συσχετιστικούς τελεστές προκύπτει ότι και οι δύο χρησιµοποιούν αριθµητικές εισόδους, π.χ. (num + 10) και (num < 10), όπου num είναι µία ακέραια µεταβλητή.
Ωστόσο οι αριθµητικοί τελεστές µπορούν να δώσουν ως έξοδο οποιοδήποτε αριθµό (για κάθε τιµή του num η πρόταση (num + 10) δίνει µία άλλη τιµή) ενώ οι συσχετιστικές τελεστές έχουν δίτιµη έξοδο (για κάθε τιµή του num µικρότερη του 10 η πρόταση (num < 10) δίνει TRUE (1) και για όλες τις άλλες τιµές του num δίνει FALSE (0)).
Οι λογικοί τελεστές δρουν επί ενός ή δύο τελεστέων και λειτουργούν µε βάση τη δίτιµη άλγεβρα Boole.
Τόσο οι είσοδοι όσο και οι έξοδοι µπορούν να λάβουν µόνο δύο τιµές, TRUE και FALSE.
Οι τελεστές της κατηγορίας αυτής παρατίθενται στον πίνακα 3-5 ενώ στον πίνακα 3-6 περιγράφεται ο τρόπος λειτουργίας τους (πίνακας
Πίνακας 3-5.
Λογικοί τελεστές
Πίνακας 3-6.
Πίνακας αληθείας
Για x = 10 και y = -8 να υπολογισθούν οι εκφράσεις:
Αντιακθιστώντας τις αριθµητικές τιµές προκύπτει: β) (10>5) || (-8>10) Æ (TRUE) || (FALSE) Æ TRUE
Όταν ένας τελεστής έχει τελεστέους διαφορετικών τύπων δεδοµένων, αυτοί µετατρέπονται σε ενιαίο τύπο.
Η µετατροπή είτε γίνεται αυτόµατα από τον υπολογιστή, οπότε καλείται υπονοούµενη (implicit conversion), είτε άµεσα από τον προγραµµατιστή, οπότε καλείται ρητή (explicit conversion).
Οι υπονοούµενες µετατροπές διευκολύνουν την εργασία του προγραµµατιστή, ο οποίος όµως θα πρέπει σε κάθε περίπτωση να γνωρίζει τις συνέπειες µίας µετατροπής.
Για παράδειγµα, η έκφραση δε δίνει τιµή 3.5, όπως πιθανόν να ήταν αναµενόµενο, αλλά 3.0.
Η διαδικασία της αυτόµατης µετατροπής στηρίζεται στους ακόλουθους κανόνες: Σε κάθε πράξη που υπάρχουν δύο τύποι δεδοµένων, ο στενότερος τύπος µετατρέπεται στον ευρύτερο χωρίς να υπάρχει απώλεια πληροφορίας.
Οι τύποι της γλώσσας ταξινοµούνται ανάλογα µε το µέγεθος της µνήµης που απαιτούν για αποθήκευση, όπως παρακάτω
Ο τύπος unsigned ακολουθεί τον αντίστοιχο προσηµασµένο τύπο.
Όλοι οι µεταγλωττιστές της C όταν υπολογίζουν αριθµητικές εκφράσεις µετατρέπουν αυτόµατα τον τύπο char σε int και το float σε double.
Να µελετηθεί το ακόλουθο πρόγραµµα: (1): Ο χαρακτήρας 'A' αποθηκεύεται ως χαρακτήρας στη µεταβλητή ch.
Η µεταβλητή i λαµβάνει την τιµή του ακέραιου από τη µετατροπή του 'A' (65), ενώ η µεταβλητή fl λαµβάνει την τιµή του αριθµού κινητής υποδιαστολής που προέρχεται (2): Η πρόσθεση της µονάδας γίνεται στην ακέραια τιµή του 'A'.
Το αποτέλεσµα (66) αντιστοιχεί στο χαρακτήρα 'Β', ο οποίος αποθηκεύεται στη µεταβλητή ch. (3): Η πράξη δίνει 2*66+65.00=197.00.
Το αποτέλεσµα µετατρέπεται σε int (197) και αποθηκεύεται στη µεταβλητή i. (4): Η πράξη δίνει 2.0*66+197=329.00 (οι αριθµοί int µετατρέπονται σε float).
Το αποτέλεσµα αποθηκεύεται στη µεταβλητή fl.
Ρητές µετατροπές - τελεστής typecast Εκτός από τις αυτόµατες µετατροπές η C επιτρέπει ρητές µετατροπές µίας τιµής σε ένα διαφορετικό τύπο δεδοµένων.
Η διαδικασία ονοµάζεται προσαρµογή ή εκµαγείο (casting) και ο τελεστής µετατροπής τύπου ή cast τελεστής, όπως αποκαλείται, είναι µοναδιαίος κι έχει τη µορφή (τύπος δεδοµένων), π.χ. (float).
Τοποθετείται µπροστά από µία έκφραση για να µετατρέψει την τιµή της στον περικλειόµενο σε παρενθέσεις τύπο:
f2 = (float)i/(float)j + 0.5; /* Αποτέλεσµα: 3.0 */
Ο τελεστής sizeof είναι µοναδιαίος και δρα σε δύο τύπους δεδοµένων: β) σε τύπο δεδοµένων, πχ. sizeof(int) Σε κάθε περίπτωση επιστρέφει τον αριθµό των bytes που η τιµή τής έκφρασης ή ο τύπος των δεδοµένων καταλαµβάνει στη µνήµη.
Προσοχή θα πρέπει να δοθεί στο γεγονός ότι το σύστηµα δεν υπολογίζει την τιµή της έκφρασης κι έτσι πιθανή ύπαρξη παρενεργειών από τους τελεστές δε δηµιουργεί παρενέργειες στη λειτουργία της
Έλεγχος ροής - προτάσεις υπό συνθήκη
Τα προγράµµατα αποτελούνται από προτάσεις, οι οποίες εκτελούνται µε κάποια σειρά.
Ο πιο συνηθισµένος τρόπος εκτέλεσης είναι ο ακολουθιακός: δύο ή περισσότερες προτάσεις βρίσκονται διατεταγµένες η µία µετά την άλλη και εκτελούνται διαδοχικά, όπως φαίνεται στο σχήµα 4.1.
Ωστόσο ορισµένες φορές επιβάλλεται να γίνουν λογικές επιλογές (µε χρήση λογικών τελεστών και τελεστών συσχέτισης).
Εάν π.χ. περιγραφόταν η σωστή συµπεριφορά ενός πεζού µπροστά σε ένα φωτεινό σηµατοδότη, θα προέκυπτε η
ΕΑΝ στο σηµατοδότη βρίσκεται ο ΓΡΗΓΟΡΗΣ ΤΟΤΕ µπορείς να διασχίσεις την οδό ΑΛΛΙΩΣ περίµενε αλλαγή του σηµατοδότη Για να επιτευχθεί οποιαδήποτε διαφοροποίηση από την ακολουθιακή εκτέλεση απαιτούνται ειδικές κατασκευές.
Ορισµένες από αυτές τις κατασκευές διασφαλίζουν ταυτόχρονα τη δόµηση του προγράµµατος, µε κύριο στόχο: η δοµή του πηγαίου κώδικα να µας βοηθά να κατανοήσουµε τι κάνει το πρόγραµµα.
Οι κατασκευές διακρίνονται σε δύο βασικές κατηγορίες:
την υπό συνθήκη διακλάδωση (conditional branching) την επανάληψη (looping) Η πρώτη κατηγορία θα αποτελέσει αντικείµενο του παρόντος κεφαλαίου ενώ η δεύτερη κατηγορία θα µελετηθεί στο επόµενο κεφάλαιο.
Επιλεκτική εκτέλεση προτάσεων Στις γλώσσες προγραµµατισµού µία πρόταση διακλάδωσης περιέχει έναν αριθµό υποπροτάσεων, από τις οποίες επιλέγεται για εκτέλεση µόνο µία.
H πρόταση if, που συναντάται σε πολλές γλώσσες προγραµµατισµού, είναι η πλέον γνωστή πρόταση αυτής της κατηγορίας κι έχει την παρακάτω µορφή:
Στο σχήµα 4-2α αναπαριστάται η παραπάνω πρόταση.
Είναι προφανές ότι είναι πρόταση µίας εισόδου – µίας εξόδου.
Ο έλεγχος του προγράµµατος εισέρχεται από το σηµείο στην κορυφή, υπολογίζεται η τιµή της λογικής πρότασης Ε και, έαν είναι αληθής, επιλέγεται για εκτέλεση η πρόταση Π1, διαφορετικά η Π2.
Σε κάθε περίπτωση, ο έλεγχος µεταφέρεται στο ένα και µοναδικό σηµείο εξόδου στο κάτω µέρος του διαγράµµατος.
Στο σχήµα 4-2β παρουσιάζεται η γενίκευση της προηγούµενης περίπτωσης, η επιλεκτική εκτέλεση πολλών προτάσεων, όπου µάλιστα υπάρχει ένθεση, δηλαδή υπάρχει διακλάδωση µέσα σε διακλάδωση.
Ο φορµαλισµός για την περίπτωση αυτή
Οι λογικές εκφράσεις υπολογίζονται σειριακά και η πρώτη που θα δώσει αληθή τιµή οδηγεί στην εκτέλεση της αντίστοιχης πρότασης.
Εάν καµία από τις λογικές εκφράσεις δε δώσει αληθή τιµή, εκτελείται η Π0.
Η πρόταση if βασίζει την επιλογή της σε λογική έκφραση.
Υπάρχουν κατασκευές στις οποίες η απόφαση επιλογής και εκτέλεσης πρότασης βασίζεται σε άλλου τύπου εκφράσεις, όπως συµβαίνει µε τη switch της C, στην οποία η επιλογή γίνεται µέσα από ένα σύνολο αµοιβαία αποκλειόµενων επιλογών, όπως θα αναλυθεί (β) Πολλές προτάσεις µε ένθεση
Να περιγραφεί µε ψευδοκώδικα η διεργασία που πρέπει να ακολουθήσει ο υπολογιστής για να διαπιστώσει κατά πόσο ένα δεδοµένο έτος είναι δίσεκτο ή όχι.
Να χρησιµοποιηθεί η κατασκευή if – else.
Εάν αναπαρασταθεί το έτος µε την ακέραια µεταβλητή year και ο τελεστής υπολοίπου (modulo) µε το σύµβολο %, η περιγραφή µπορεί να γίνει ως ακολούθως: IF ((year % 400) == 0) THEN το έτος είναι δίσεκτο ELSE IF ((year % 100) == 0) THEN το έτος δεν είναι δίσεκτο ELSE IF ((year % 4) == 0) THEN το έτος είναι δίσεκτο
ELSE το έτος δεν είναι δίσεκτο
Υπό συνθήκη διακλάδωση if - else Στη C η υπό συνθήκη διακλάδωση if έχει στη γενική περίπτωση την ακόλουθη
H if αποτελείται από τρία τµήµατα: Το τµήµα της συνθήκης, που ακολουθεί τη λέξη if.
Το αληθές τµήµα, που ακολουθεί τη λέξη if και εκτελείται όταν η συνθήκη είναι Το ψευδές τµήµα – εφόσον υπάρχει – που ακολουθεί τη λέξη else και εκτελείται όταν η συνθήκη είναι ψευδής.
Όταν τα if, else ακολουθεί µία µόνο πρόταση, τα άγκιστρα περιττεύουν, ωστόσο είναι ορθή προγραµµατιστική τακτική να τοποθετούνται πάντοτε, αφενός µεν για να καταστήσουν τον κώδικα ευανάγνωστο αφετέρου δε για να αποτρέψουν λάθη σε περίπτωση που προστεθούν κι άλλες προτάσεις στο αληθές ή το ψευδές τµήµα.
Μερικές φορές δεν υπάρχει else, δηλαδή δεν υπάρχει ψευδές τµήµα:
Εάν η συνθήκη είναι ψευδής (π.χ. το ντεπόζιτο της βενζίνης είναι άδειο) δε γίνεται
Όταν υπάρχουν περισσότερα από δύο τµήµατα και απαιτούνται ένθετες προτάσεις if/else, το ζεύγος else { if (συνθήκη) { προτάσεις; } } µπορεί να ατικατασταθεί µε την περισσότερο ευανάγνωστη µορφή: else if (συνθήκη) { προτάσεις; } Η ανωτέρω µορφή ονοµάζεται κλίµακα if – else – if.
Στη γενική περίπτωση έχει την ακόλουθη σύνταξη:
Να ελεγχθεί κατά πόσον τα ακόλουθα τµήµατα κώδικα είναι λειτουργικά
Οι πρώτες πέντε γραµµές των δύο τµηµάτων κώδικα είναι ίδιες, στο τέλος των οποίων η µεταβλητές maria και petros έχουν λάβει τις τιµές 30 και 18, αντίστοιχα.
Στην έκτη γραµµή υπάρχει διαφοροποίηση: στο πρώτο τµήµα κώδικα το else δε θα εκτελεσθεί, καθώς η συνθήκη του if ήταν αληθής, και η µεταβλητή petros θα διατηρήσει την τιµή της (18).
Στο δεξί τµήµα κώδικα όµως, η διακλάδωση if είναι καινούρια, η συνθήκη είναι αληθής (maria=30>20) και η µεταβλητή petros θα λάβει νέα τιµή (1700).
Κατά συνέπεια τα δύο τµήµατα κώδικα δεν είναι λειτουργικά
Ο υποθετικός τελεστής (?:) αποτελείται από δύο σύµβολα.
Ανήκει στην κατηγορία των τελεστών που αποτελούνται από συνδυασµό συµβόλων και δεν ακολουθούν καµία από τις postfix, prefix ή infix σηµειογραφίες.
Όταν τα σύµβολα ή οι λέξεις του τελεστή είναι διάσπαρτα στους τελεστέους στους οποίους εφαρµόζεται ο τελεστής, λέµε ότι ο τελεστής είναι σε µεικτή σηµειογραφία (mixfix notation).
Η έκφραση που σχηµατίζει ο υποθετικός τελεστής έχει τη µορφή:
Ουσιαστικά ο υποθετικός τελεστής υλοποιεί µία υποθετική πρόταση.
Η τιµή της παραπάνω έκφρασης είναι η τιµή της εκφρ2, εάν η εκφρ1 είναι αληθής, αλλιώς είναι
Η εκφρ1 αποτελεί τη συνθήκη ελέγχου.
Έτσι η έκφραση
Έχει τιµή x, εάν το x>z είναι αληθές, διαφορετικά έχει τιµή z.
Να γραφεί πρόγραµµα που υπολογίζει το µέγιστο ανάµεσα σε τρεις ακέραιους.
Ακολούθως να τροποποιηθεί ο κορµός του προγράµµατος κάνοντας χρήση του
Χρησιµοποιώντας τον υποθετικό τελεστή, οι προτάσεις διακλάδωσης συνοψίζονται στην ακόλουθη πρόταση:
Υπό συνθήκη διακλάδωση switch Αν και η κλίµακα if – else – if µπορεί να πραγµατοποιεί ελέγχους διαφόρων ειδών, είναι δύσχρηστη καθώς δεν παρέχει εποπτεία στον προγραµµατιστή και καθυστερεί στην εκτέλεση.
Για τις περιπτώσεις πολλαπλής διακλάδωσης η C διαθέτει την πολυκλαδική εντολή switch, η οποία έχει την ακόλουθη σύνταξη:
case (σταθ.-έκφρ. 1): case (σταθ.-έκφρ.
Ν):
Η πρόταση switch επιτρέπει τον προσδιορισµό απεριόριστου αριθµού διαδροµών, ανάλογα µε την τιµή της έκφρασης.
Υπολογίζεται η έκφραση και η τιµή της συγκρίνεται διαδοχικά µε τις σταθερές εκφράσεις (σταθ.-έκφρ. 1, σταθ.-έκφρ. 2, …).
Ο έλεγχος µεταφέρεται στις προτάσεις που είναι κάτω από τη σταθ.-έκφρ. µε την οποία ισούται η τιµή της έκφρασης.
Εάν δεν ισούται µε καµία από τις σταθερές εκφράσεις, ο έλεγχος µεταφέρεται στις προτάσεις που ακολουθούν την ετικέτα default, εάν βέβαια αυτή υπάρχει, αλλιώς στην πρόταση που ακολουθεί το σώµα της
Η πρόταση ελέγχου break, η οποία υποδηλώνει άµεση έξοδο από τη switch, είναι προαιρετική.
Εάν αυτή λείπει, µετά την εκτέλεση των προτάσεων που ακολουθούν την επιλεγείσα ετικέτα case θα ακολουθήσει η εκτέλεση των προτάσεων και των επόµενων case ετικετών.
Βέβαια στην πράξη η break συναντάται σχεδόν πάντοτε, ακόµη και µετά τις προτάσεις της ετικέτας default.
Το τελευταίο γίνεται για να προστατευθούµε από το δύσκολο στην ανεύρεση σφάλµα που θα προκύψει εάν προστεθεί µελλονικά µία νέα case και ταυτόχρονα παραληφθεί να προστεθεί πριν από
Θα πρέπει να σηµειωθεί ότι η switch διαφέρει από την if στο ότι ελέγχει µόνο την ισότητα, ενώ η παράσταση µε συνθήκη της if µπορεί να είναι οιουδήποτε τύπου.
Η λειτουργία της switch διέπεται από το ακόλουθο σύνολο κανόνων: Κάθε case πρέπει να έχει µία int ή char σταθερά έκφραση.
∆ύο case δεν µπορούν να έχουν την ίδια τιµή.
Οι προτάσεις κάτω από την ετικέτα default εκτελούνται όταν δεν ικανοποιείται καµία από τις case ετικέτες.
Η default δεν είναι απαραίτητα η τελευταία ετικέτα.
Να γραφεί πρόγραµµα, το οποίο να δίνει τη δυνατότητα στο χρήστη να εισάγει δύο αριθµούς και στη συνέχεια να εκτελεί επί αυτών επιλεκτικά µία από τις τέσσερις
Χρησιµοποιώντας δδοοµµηηµµέένναα ΕΕλλλληηννιικκάά η διεργασία περιγράφεται ως εξής: Πάρε δύο αριθµούς Ενηµέρωσε το χρήστη για δυνατές επιλογές Πάρε την επιλογή του χρήστη
Ανάλογα µε την επιλογή Εκτέλεσε την αντίστοιχη πράξη
Ο κώδικας του προγράµµατος είναι ο ακόλουθος: } // Τέλος της switch } // Τέλος της main
Να γραφεί πρόγραµµα που να υλοποιεί το παράδειγµα 4.1.
Προτάσεις επανάληψης - βρόχοι Οι προτάσεις επανάληψης αποτελούν ένα ισχυρό εργαλείο προγραµµατισµού καθώς µπορούν να κωδικοποιήσουν και να συµπυκνώσουν επαναλαµβανόµενες λειτουργίες, δηµιουργώντας ένα βρόχο (loop).
Ορίζονται ως προτάσεις που επαναλαµβάνουν ένα µπλοκ εντολών είτε για όσες φορές το επιθυµούµε είτε έως ότου πληρωθεί µία συνθήκη τερµατισµού.
Η πλήρωση του κριτηρίου τερµατισµού οδηγεί στην περάτωση του βρόχου.
Εάν δεν υπάρχει συγκεκριµένος αριθµός επαναλήψεων ή συνθήκη τερµατισµού, ο βρόχος θα εκτελείται αενάως και θα καλείται ατέρµων βρόχος (infinite loop), γεγονός που οδηγεί ως επί το πλείστον σε σφάλµα.
Εάν ο βρόχος τελειώνει µετά το πέρας ενός ορισµένου αριθµού επαναλήψεων τότε καλείται βρόχος οδηγούµενος από µετρητή.
Εάν περατώνεται µε την πλήρωση ενός κριτηρίου τερµατισµού ονοµάζεται βρόχος οδηγούµενος από γεγονός.
Επιπρόσθετα, στις περισσότερες γλώσσες προγραµµατισµού υπάρχει µία δεύτερη κατηγοριοποίηση των προτάσεων επανάληψης: α) εκείνες στις οποίες ο έλεγχος του κριτηρίου τερµατισµού γίνεται στην αρχή του βρόχου, επονοµαζόµενες βρόχοι µε συνθήκη εισόδου (pre-test loops), και β) εκείνες στις οποίες ο έλεγχος του κριτηρίου τερµατισµού γίνεται στο τέλος του βρόχου, επονοµαζόµενες βρόχοι µε συνθήκη εξόδου (post-test loops).
Στις παραγράφους που ακολουθούν πρώτα θα παρουσιασθούν οι µορφές βρόχων που κυριαρχούν στις γλώσσες προγραµµατισµού και στη συνέχεια θα εστιασθούµε στις επαναληπτικές προτάσεις που χρησιµοποιούνται στη C.
Ο βρόχος while-do είναι βρόχος µε συνθήκη εισόδου, δυνάµενος να οδηγείται τόσο από µετρητή όσο και από γεγονός.
Η λειτουργία του απεικονίζεται στο µπλοκ διάγραµµα του σχήµατος 5-1α ενώ το διάγραµµα ροής παρατίθεται στο σχήµα 5-1β. (α) Μπλοκ διάγραµµα (β) ∆ιάγραµµα ροής Όπως προκύπτει από το σχήµα 5-1, ο βρόχος θα εκτελείται – δηλαδή η πρόταση Π – για όσες επαναλήψεις η συνθήκη Ε είναι αληθής.
Κατά συνέπεια απαιτείται: α) πριν την πρώτη επανάληψη η συνθήκη Ε να είναι αληθής και β) κατά τη διάρκεια εκτέλεσης του βρόχου να υπάρχει η δυνατότητα, µέσω της Π, να µπορεί να καταστεί η Ε ψευδής για να τερµατισθεί ο βρόχος.
Ο βρόχος do-while είναι βρόχος µε συνθήκη εξόδου, δυνάµενος κι αυτός να οδηγείται τόσο από µετρητή όσο και από γεγονός.
Στα σχήµατα 5-2α και 5-2β παρουσιάζονται το µπλοκ διάγραµµα και το διάγραµµα ροής αντίστοιχα.
Από το σχήµα 5-2 καθίσταται φανερό ότι ο βρόχος do-while διαφέρει από το βρόχο while-do στο σηµείο ελέγχου της συνθήκης τερµατισµού.
Ο βρόχος do-while επιτρέπει την εκτέλεση της πρώτης επανάληψης πριν προχωρήσει στον έλεγχο της συνθήκης, γεγονός που σηµαίνει ότι δεν απαιτείται να είναι αληθής η συνθήκη πριν από την εκτέλεση του βρόχου.
Μπορεί να γίνει αληθής µέσα στην Π και, φυσικά, πρέπει να υπάρχει η δυνατότητα, µέσω της Π, να µπορεί να καταστεί η Ε ψευδής για (α) Μπλοκ διάγραµµα (β) ∆ιάγραµµα ροής
Βρόχοι µε συνθήκη εισόδου στη C Ο βρόχος while είναι βρόχος µε συνθήκη εισόδου, οδηγούµενος από γεγονός.
Η λειτουργία του περιγράφεται εποπτικά από το σχήµα 5-1α και η σύνταξή του είναι η προτάσεις, µέσα στις οποίες θα αλλάζει η συνθήκη;
Η λειτουργία της πρότασης επανάληψης while µπορεί να µορφοποιηθεί σε δδοοµµηηµµέένναα ΕΕλλλληηννιικκάά ως εξής: Εάν είναι αληθής Προχώρησε στις προτάσεις Ξεκίνησε από την αρχή
Ο βρόχος while είναι κατάλληλος στις περιπτώσεις που δεν είναι γνωστός εκ των προτέρων ο αριθµός των επαναλήψεων.
Εκτελείται καθόσον η συνθήκη παραµένει αληθής.
Όταν η συνθήκη καταστεί ψευδής, ο έλεγχος του προγράµµατος παρακάµπτει το περιεχόµενο του βρόχου και προχωρά στην επόµενη εντολή.
Επιπρόσθετα, για το βρόχο while ισχύουν οι παρατηρήσεις της §5.1.1.
Θα πρέπει να σηµειωθεί ότι εάν το σώµα του βρόχου αποτελείται από µία πρόταση, δεν απαιτούνται {}.
Να περιγραφεί η λειτουργία του ακόλουθου τµήµατος κώδικα και να δοθεί το διάγραµµα ροής της πρότασης επανάληψης.
Στις πρώτες δύο γραµµές δηλώνονται και αρχικοποιούνται οι ακέραιες µεταβλητές count και limit.
Ακολουθεί η πρόταση επανάληψης while, η οποία καθορίζει ως συνθήκη η µεταβλητή count να είναι µικρότερη της limit, γεγονός που αληθεύει.
Κατά συνέπεια ο έλεγχος εισέρχεται στο βρόχο, η µεταβλητή count αυξάνεται κατά µία µονάδα και τυπώνεται στην οθόνη η φράση
Ο βρόχος εκτελείται συνολικά 10 φορές:
Στην ενδέκατη επανάληψη η count έχει λάβει την τιµή 40 και είναι ίση µε τη limit, οπότε η συνθήκη καθίσταται ψευδής και ο έλεγχος προσπερνά το βρόχο και προχωρά στην επόµενη πρόταση.
Θα πρέπει να σηµειωθεί ότι εάν η συνθήκη ήταν εξαρχής ψευδής (π.χ. count=45), ο βρόχος δε θα εκτελείτο ούτε µία φορά.
Το διάγραµµα ροής απεικονίζεται στο σχήµα 5-3: ∆ίνονται οι παρακάτω δύο προτάσεις:
Να περιγραφεί ο τρόπος µε τον οποίο ο υπολογιστής τις εκτελεί, εντοπίζοντας τη διαφορά τους, εάν υπάρχει.
Υπάρχει διαφορά µεταξύ των προτάσεων κι αυτή εντοπίζεται στον αριθµό επαναλήψεων.
Η (α) χρησιµοποιεί την προθεµατική σηµειογραφία ενώ η (β) τη µεταθεµατική.
Στην πρόταση (α) πρώτα αυξάνεται η τιµή τής count και η νέα τιµή της συγκρίνεται µε το 12, ενώ στη (β) πρώτα συγκρίνεται η τιµή τής count µε το 12 και στη συνέχεια αυξάνεται η τιµή της.
Αυτό σηµαίνει πως η πρόταση Π1 θα εκτελεσθεί µία φορά παραπάνω στην περίπτωση (β).
Ο βρόχος for είναι βρόχος µε συνθήκη εισόδου, οδηγούµενος από µετρητή.
Η for (αρχική τιµή µετρητή; συνθήκη; βήµα µετρητή)
Η λειτουργία της πρότασης επανάληψης for µπορεί να µορφοποιηθεί σε
Εάν είναι αληθής Εκτέλεσε τις προτάσεις Επάνελθε στον έλεγχο της συνθήκης Αλλιώς ενηµέρωσε το µετρητή και σταµάτησε Μία τυπική εκτέλεση του βρόχου for είναι η ακόλουθη, κατά την οποία σε κάθε επανάληψη θα τυπώνεται η µεταβλητή n:
Ωστόσο ο βρόχος for στη γλώσσα C παρέχει µεγάλη ευελιξία καθώς οι εκφράσεις µέσα στις παρενθέσεις µπορούν να έχουν πολλές παραλλαγές.
Eνδεικτικά αναφέρονται µερικές από τις παραλλαγές ενώ για ενδελεχή µελέτη ο αναγνώστης µπορεί να ανατρέξει στην αναφορά [18]. ¾ Μπορεί να χρησιµοποιηθεί ο τελεστής µείωσης για µέτρηση προς τα κάτω: ¾ Το βήµα καθορίζεται από το χρήστη: ¾ Χρησιµοποιώντας την ιδιότητα ότι κάθε χαρακτήρας του κώδικα ASCII έχει µία ακέραια τιµή, ο µετρητής µπορεί να είναι µεταβλητή χαρακτήρα.
Το παρακάτω τµήµα κώδικα θα τυπώνει τους χαρακτήρες από το ‘a’ έως το ‘z’ µαζί µε τον ASCII κωδικό τους: ¾ Ο µετρητής µπορεί να αυξάνει κατά γεωµετρική πρόοδο:
Στην πρώτη γραµµή δηλώνονται οι ακέραιες µεταβλητές count και max_count, και αποδίδεται τιµή στη max_count.
Ακολουθεί η πρόταση επανάληψης for, η οποία έχει µετρητή τη µεταβλητή count, βήµα τη µονάδα και θα εκτελείται καθόσον ο µετρητής έχει τιµή µικρότερη της max_count.
Στο τέλος της τριακοστής επανάληψης ο µετρητής έχει λάβει την τιµή 30 και στον έλεγχο της συνθήκης στην τριακοστή πρώτη επανάληψη η τελευταία είναι ψευδής, οπότε ο έλεγχος προσπερνά το βρόχο και προχωρά στην επόµενη πρόταση.
Η πρόταση επανάληψης for µπορεί να χρησιµοποιεί περισσότερες της µίας µεταβλητές ελέγχου του βρόχου.
Στο ακόλουθο πρόγραµµα τόσο η µεταβλητή x όσο και η y ελέγχουν το βρόχο:
Το παραπάνω πρόγραµµα τυπώνει τους αριθµούς 0 έως 90 σε βήµατα του 30.
Σε κάθε εκτέλεση του βρόχου το x αυξάνει κατά 20 και το y κατά 10.
Μετά το τέλος του βρόχου τα x και y έχουν διατηρήσει τις τιµές που τους δόθηκαν πριν τερµατίσει ο βρόχος, όπως φαίνεται στα αποτελέσµατα.
Στο παράδειγµα 5.4 οι µεταβλητές για το έλεγχο της πρότασης επανάληψης διαχωρίζονταν µε τον τελεστή κόµµα (,).
Ο τελεστής κόµµα επιτρέπει την παράθεση περισσότερων της µίας εκφράσεων σε θέσεις όπου επιτρέπεται µία έκφραση.
Η τιµή της έκφρασης είναι η τιµή της δεξιότερης των εκφράσεων.
Συνήθως περιπλέκει τον κώδικα και για αυτό το λόγο η χρήση του είναι περιορισµένη, εκτός από την πρόταση for, στην οποία συνηθίζεται να χρησιµοποιείται ως συνθετικό των εκφράσεων αρχικοποίησης και ανανέωσης.
Για παράδειγµα, η πρόταση αντιγράφει τα οκτώ πρώτα στοιχεία του πίνακα s στον s, ξεκινώντας από το ενδέκατο
Θα πρέπει να αποφεύγονται προτάσεις όπως η
Η πρόταση, αν και είναι συµπαγής ως προς τον κώδικα, µειώνει σε µεγάλο βαθµό την αναγνωσιµότητά του.
Μετασχηµατισµός βρόχων while - for Ένας βρόχος for µπορεί να µετασχηµατισθεί σε βρόχο while και τανάπαλιν µε βάση την ακόλουθη φόρµα µετασχηµατισµού:
αρχική τιµή µετρητή;
Τι εµφανίζεται στην οθόνη του υπολογιστή από την εκτέλεση του βρόχου:
Να γραφεί εκ νέου ο παραπάνω κώδικας αντικαθιστώντας τη for µε while.
Ο παραπάνω κώδικας εκτελεί ένα βρόχο for µε φθίνον βήµα τη µονάδα, σε κάθε επανάληψη του οποίου τυπώνεται το πηλίκο διαίρεσης ακεραίων.
Τα αποτελέσµατα
Με βάση τη φόρµα µετασχηµατισµού της §5.2.4, ο κώδικας µε χρήση του βρόχου while είναι ο ακόλουθος:
Βρόχος µε συνθήκη εξόδου στη C (do - while) Ο βρόχος do–while είναι βρόχος µε συνθήκη εξόδου.
Η λειτουργία του περιγράφεται εποπτικά στο σχήµα 5-2α και η σύνταξή του είναι η ακόλουθη:
Η λειτουργία της πρότασης επανάληψης do–while µπορεί να µορφοποιηθεί σε
Είναι φανερό ότι ο βρόχος do–while εκτελείται τουλάχιστον µία φορά, καθώς ο έλεγχος της συνθήκης έπεται του σώµατος του βρόχου.
∆εν είναι συχνή η χρήση του – στατιστικά χρησιµοποιείται µόνο στο 5% των περιπτώσεων χρήσης βρόχου – καθώς αφενός µεν είναι προτιµότερο να εξετάζεται ένας βρόχος προτού εκτελεσθεί παρά µετά, αφετέρου δε σε πολλές χρήσεις είναι σηµαντικό να µπορεί να παραληφθεί τελείως ο βρόχος εφόσον δεν ικανοποιείται εξαρχής ο έλεγχος.
Επιπρόσθετα, για το βρόχο while ισχύουν οι παρατηρήσεις της §5.1.2. µεταβλητές count και limit.
Ακολουθεί η πρόταση επανάληψης do–while, η οποία αυξάνεται κατά µία µονάδα, τυπώνεται στην οθόνη η φράση και στη συνέχεια διενεργείται ο έλεγχος της συνθήκης.
Ο βρόχος εκτελείται συνολικά
Στο τέλος της δέκατης επανάληψης η συνθήκη είναι ψευδής και ο βρόχος τερµατίζεται.
Θα πρέπει να σηµειωθεί ότι εάν η συνθήκη ήταν εξαρχής ψευδής (π.χ. count=45), ο βρόχος θα εκτελείτο µία φορά.
Τι εµφανίζεται στην οθόνη του υπολογιστή από την εκτέλεση του βρόχου:
Να γραφεί εκ νέου ο παραπάνω κώδικας αντικαθιστώντας τη for µε dο–while. επανάληψη του οποίου τυπώνεται το υπόλοιπο διαίρεσης ακεραίων.
Τα αποτελέσµατα είναι τα εξής:
Ο κώδικας µε χρήση του βρόχου dο–while είναι ο ακόλουθος:
Θα πρέπει να σηµειωθεί ότι στη συνθήκη ελέγχου του βρόχου ο µετρητής δεν είναι το n αλλά το n-1 (δηλαδή η n-1 να είναι αληθής, εποµένως n-1>0⇔n>1), καθώς πρέπει να ληφθεί υπόψη η πρώτη επανάληψη, η οποία εκτελείται ούτως ή
Ένθετος ή φωλιασµένος βρόχος (nested loop) ονοµάζεται ο βρόχος που περικλείεται σε έναν άλλο.
Ο εσωτερικός βρόχος λογίζεται ως µία πρόταση του εσωτερικού, κατά συνέπεια πρώτα θα εκτελείται ολόκληρος ο εσωτερικός βρόχος και µετά θα εκτελείται η επόµενη επανάληψη του εξωτερικού.
Η C δε θέτει κανένα περιορισµό στην ένθεση των προτάσεων ελέγχου ροής, επιτρέποντας την πολλαπλή ένθεση.
Ο συνολικός αριθµός επαναλήψεων σε έναν πολλαπλό βρόχο είναι το γινόµενο του αριθµού των επαναλήψεων όλων των επιµέρους βρόχων.
Να περιγραφεί η λειτουργία του ακόλουθου τµήµατος κώδικα.
Ο κώδικας παρουσιάζει ένα διπλό βρόχο.
Ο εξωτερικός βρόχος for έχει µετρητή το i και σώµα που αποτελείται από δύο προτάσεις: α) τον εσωτερικό βρόχο for µε µετρητή το j και β) την πρόταση printf(“\n”);.
Σε κάθε επανάληψη του εσωτερικού βρόχου θα εκτελούνται όλες οι επαναλήψεις του ένθετου και στη συνέχεια θα εκτελείται η printf(“\n”);, όπως προκύπτει από τα αποτελέσµατα:
Το πρόγραµµα που ακολουθεί εµφανίζει τις τέσσερις πρώτες ακέραιες δυνάµεις των αριθµών έως 9. } // Τέλος του βρόχου j } // Tέλος του βρόχου i
Η κωδική λέξη break Στο προηγούµενο κεφάλαιο η λέξη break χρησιµοποιήθηκε στην πρόταση διακλάδωσης switch.
Όµως πέραν αυτής, η break έχει και δεύτερη χρήση, η οποία σχετίζεται µε τις προτάσεις επανάληψης.
Χρησιµοποιείται για να τερµατίζει αµέσως την εκτέλεση ενός βρόχου, µεταβιβάζοντας τον έλεγχο του προγράµµατος στην εντολή που βρίσκεται αµέσως µετά το βρόχο.
Εάν η break βρίσκεται µέσα σε ένθετο βρόχο, τότε επηρεάζεται µόνο ο εσώτερος βρόχος.
Η λειτουργία της break περιγράφεται εποπτικά στο σχήµα 5-6:
Το πρόγραµµα που ακολουθεί εµφανίζει στην οθόνη τους αριθµούς 1 έως 10 και στη συνέχεια τερµατίζεται γιατί η break υπερφαλαγγίζει τη συνθήκη ελέγχου του
H εντολή continue µεταφέρει τον έλεγχο της ροής στην αρχή του βρόχου, παραλείποντας την εκτέλεση του υπόλοιπου τµήµατος του σώµατος του βρόχου και προχωρώντας στην επόµενη επανάληψη.
Στους βρόχους while και do–while η εντολή continue υποχρεώνει τον έλεγχο του προγράµµατος να περάσει κατευθείαν στη συνθήκη ελέγχου και να προχωρήσει κατόπιν στην επεξεργασία του βρόχου.
Στην περίπτωση της for ο υπολογιστής εκτελεί πρώτα το τµήµα του βρόχου και κατόπιν τη συνθήκη ελέγχου, προτού συνεχισθεί η εκτέλεση του βρόχου.
Το πρόγραµµα που ακολουθεί εµφανίζει στην οθόνη µόνο τους άρτιους
Kάθε φορά που παράγεται ένας περιττός αριθµός ενεργοποιείται η εντολή διακλάδωσης και εκτελείται η continue, παρακάµπτεται η printf και οι υπόλοιπες προτάσεις, οπότε ο έλεγχος προχωρά στην επόµενη επανάληψη.
H πρόταση ρητής διακλάδωσης µεταφέρει τον έλεγχο στην πρόταση που σηµειώνεται µε την ετικέτα ως H εντολή goto πρέπει να αποφεύγεται γιατί οδηγεί σε κώδικα «σπαγγέτι» και αίρει τα πλεονεκτήµατα του δοµηµένου προγραµµατισµού.
Μπορεί να χρησιµοποιηθεί σε περιπτώσεις εξόδου από πολύ βαθιά ενσωµατωµένη δοµή, όπου µία προσεκτική χρήση της goto µπορεί να δώσει πιο συµπαγή κώδικα.
Θα πρέπει να σηµειωθεί ότι η C είναι δοµηµένη κατά τρόπο ώστε να µην απαιτεί ποτέ τη χρήση τής goto, σε αντιδιαστολή µε άλλες γλώσσες προγραµµατισµού, όπως η FORTRAN και η BASIC, στις οποίες επιβάλλεται η χρήση της goto σε ορισµένες περιπτώσεις.
Έστω το ακόλουθο τµήµα κώδικα:
H απαλοιφή της goto θα υποχρέωνε τον κώδικα να εκτελέσει έναν αριθµό από πρόσθετους ελέγχους.
Η χρήση µίας break δε θα ήταν αρκετή γιατί θα προκαλούσε έξοδο µόνο από τον εσώτερο βρόχο.
Εάν τοποθετούνταν έλεγχοι σε όλους τους βρόχους, ο κώδικας θα έπαιρνε την ακόλουθη σωστή αλλά δύσχρηστη µορφή: break; // έξοδος από τη while } // τέλος της while } // τέλος του εσωτερικού βρόχου for } // τέλος του εξωτερικού βρόχου for
Κανόνες για τη χρήση των προτάσεων
Τοποθετείτε πάντοτε το σώµα των προτάσεων επανάληψης µία θέση στηλογνώµονα δεξιότερα, για αύξηση της αναγνωσιµότητας του κώδικα.
Στην περίπτωση δε που το σώµα αποτελείται από περισσότερες της µίας προτάσεις, περικλείετε αυτές σε άγκιστρα.
Αποφεύγετε τη χρήση της πρότασης διακλάδωσης goto.
Καταστρέφει τη δόµηση του προγράµµατος και τις περισσότερες φορές προδίδει αδυναµία κατασκευής
Προτιµήστε το βρόχο επανάληψης συνθήκης εισόδου (while) από τον αντίστοιχο συνθήκης εξόδου (do-while) γιατί οδηγεί σε πιο ευανάγνωστο κώδικα.
Αποφεύγετε κατά το δυνατόν τη χρήση των break και continue σε βρόχους επανάληψης, επειδή διακόπτουν την κανονική ροή ελέγχου και καθιστούν την παρακολούθησή της δύσκολη.
Ελέγξτε σχολαστικά και βεβαιωθείτε ότι κάθε συνθήκη βρόχου επανάληψης οδηγεί στην έξοδο µετά από πεπερασµένες επαναλήψεις, έτσι ώστε να µη δηµιουργούνται ατέρµονες βρόχοι.
Ο πίνακας είναι µία συλλογή µεταβλητών ίδιου τύπου, οι οποίες είναι αποθηκευµένες σε διαδοχικές θέσεις µνήµης.
Χρησιµοποιείται για την αποθήκευση και διαχείριση δεδοµένων κοινού τύπου και αποτελεί, µαζί µε τους δείκτες, από τα πλέον ισχυρά εργαλεία της γλώσσας C.
Η δήλωση του πίνακα ακολουθεί τον εξής φορµαλισµό: τύπος_δεδοµένου όνοµα_πίνακα[µέγεθος] ∆ιακρίνονται τρία τµήµατα: α) ο τύπος δεδοµένου (float, int, char, double), β) το όνοµα του πίνακα και γ) ο αριθµός των στοιχείων που απαρτίζουν τον πίνακα.
Έτσι, µία τυπική δήλωση ενός πίνακα 31 στοιχείων κινητής υποδοαστολής είναι η H αναφορά σε στοιχείο πίνακα γίνεται µε συνδυασµό του ονόµατος και ενός δείκτη (index), ο οποίος εκφράζει τη σειρά τού στοιχείου µέσα στον πίνακα: temp[0]: πρώτο στοιχείο του πίνακα temp[1]: δεύτερο στοιχείο του πίνακα temp[30]: τελευταίο (τριακοστό πρώτο) στοιχείο του πίνακα Η απόδοση αρχικής τιµής κατά τη δήλωση του πίνακα γίνεται µε χρήση του τελεστή ανάθεσης ως εξής: float temp[5] = {1,2,-4.2,6,8}: αρχικοποιούνται και τα 5 στοιχεία του πίνακα temp. float temp[5] = {1,2,-4.2}: αρχικοποιούνται τα 3 πρώτα στοιχεία του πίνακα temp, δηλαδή τα temp[0], temp[1], temp[2].
Η ανάγνωση και εκτύπωση ενός πίνακα γίνονται κατά στοιχείο, µε τους κανόνες που ισχύουν για κάθε τύπο δεδοµένου:
Όταν αποδίδονται αρχικές τιµές µπορεί να παραληφθεί το µέγεθος του πίνακα.
Ο υπολογιστής θα υπολογίσει αυτόµατα πόσα είναι τα στοιχεία του πίνακα από τον αριθµό των αρχικών τιµών που δίδονται.
Η παρακάτω δήλωση έχει ως αποτέλεσµα τη δηµιουργία ενός πίνακα χαρακτήρων (char) τεσσάρων στοιχείων µε αρχικές τιµές:
To γεγονός ότι οι δείκτες των στοιχείων ενός πίνακα ξεκινούν από το 0 κι όχι από το 1 µπορεί αρχικά να προκαλέσει σύγχυση αλλά αντανακλά τη φιλοσοφία της C, η οποία επιδιώκει να παραµείνει ο προγραµµατισµός κοντά στην αρχιτεκτονική του υπολογιστή.
Το 0 αποτελεί το σηµείο εκκίνησης για τους υπολογιστές.
Εάν η αρίθµηση των στοιχείων πίνακα ξεκινούσε από το 1, όπως π.χ. συµβαίνει στη FORTRAN, ο µεταγλωττιστής θα έπρεπε να αφαιρέσει τη µονάδα από κάθε αναφορά σε δείκτη στοιχείου για να ληφθεί η πραγµατική διεύθυνση ενός στοιχείου.
Εποµένως, η επιλογή της C παράγει πιο αποτελεσµατικό κώδικα.
Υπάρχει διαφορά ανάµεσα στη δήλωση πίνακα και στην αναφορά στοιχείου πίνακα.
Σε µία δήλωση, ο δείκτης καθορίζει το µέγεθος του πίνακα.
Σε µία αναφορά στοιχείου πίνακα, ο δείκτης προσδιορίζει το στοιχείο του πίνακα στο οποίο αναφερόµαστε.
Π.χ. στη δήλωση int temp[31]; τo 31 δηλώνει τον αριθµό των στοιχείων του πίνακα.
Αντίθετα στη temp[13]=21; τo 13 δηλώνει το συγκεκριµένο στοιχείο (14ο) του πίνακα, στο οποίο αναφερόµαστε και αποδίδουµε την τιµή 21.
Μπορεί να βρεθεί το µέγεθος σε bytes ενός πίνακα χρησιµοποιώντας τον τελεστή sizeof.
Για παράδειγµα, εάν θεωρηθεί ο πίνακας int ar[5]; η έκφραση sizeof(ar) δίνει τιµή 20 επειδή ο πίνακας αποτελείται από 5 ακεραίους των 4 bytes.
Στη sizeof θα πρέπει να περιλαµβάνεται µόνο το όνοµα του πίνακα.
Αν περιληφθεί δείκτης ενός στοιχείου, τότε θα εξαχθεί το µέγεθος του στοιχείου.
Για παράδειγµα, η έκφραση sizeof(ar[0]) δίνει τιµή 4.
Χρησιµοποιώντας ένα συνδυασµό των παραπάνω µπορεί να βρεθεί ο αριθµός των στοιχείων του πίνακα.
Η έκφραση sizeof(ar)/sizeof(ar[0]) δίνει 5, τον αριθµό δηλαδή των στοιχείων του πίνακα ar.
Οι πολυδιάστατοι πίνακες είναι πίνακες, τα στοιχεία των οποίων είναι επίσης πίνακες.
Η πρόταση int array[4][12]; δηλώνει τη µεταβλητή array ως πίνακα 4 στοιχείων, όπου το κάθε στοιχείο είναι πίνακας 12 στοιχείων ακεραίων.
Η C δε θέτει περιορισµό στον αριθµό των διαστάσεων των πινάκων.
Αν και ο πολυδιάστατος πίνακας αποθηκεύεται στη µνήµη ως µία ακολουθία στοιχείων µίας διάστασης, µπορούµε να το θεωρούµε ως πίνακα πινάκων.
Για παράδειγµα, έστω το επόµενο «µαγικό τετράγωνο», του οποίου οι γραµµές οριζόντια, κάθετα και διαγώνια δίνουν το ίδιο άθροισµα:
Για να αποθηκευθεί το τετράγωνο αυτό σε πίνακα θα µπορούσε να γίνει η ακόλουθη
Από τον προηγούµενο κώδικα γίνεται αντιληπτό ότι στην απόδοση των αρχικών τιµών οι τιµές των στοιχείων κάθε γραµµής περικλείονται σε άγκιστρα.
Για την αναφορά σε στοιχείο ενός πολυδιάστατου πίνακα θα πρέπει να καθορισθούν τόσοι δείκτες όσοι είναι αναγκαίοι.
Έτσι, η έκφραση αναφέρεται στη δεύτερη γραµµή του πίνακα, ενώ η αναφέρεται στο τέταρτο στοιχείο της δεύτερης γραµµής του πίνακα.
Οι πολυδιάστατοι πίνακες αποθηκεύονται κατά γραµµές, που σηµαίνει ότι ο τελευταίος δείκτης θέσης µεταβάλλεται ταχύτερα κατά την προσπέλαση των στοιχείων.
Για παράδειγµα, ο πίνακας που δηλώνεται ως: αποθηκεύεται όπως φαίνεται ακολούθως:
Αρχικοποίηση πολυδιάστατου πίνακα Για την αρχικοποίηση ενός πολυδιάστατου πίνακα κάθε γραµµή αρχικών τιµών περικλείεται σε άγκιστρα.
Εάν δεν υπάρχουν οι αναγκαίες αρχικές τιµές, τα επιπλέον στοιχεία λαµβάνουν αρχική τιµή 0.
Έτσι, στη δήλωση και αρχικοποίηση του η µεταβλητή ar δηλώνεται ως πίνακας 5 γραµµών και 3 στηλών.
Ωστόσο έχουν αποδοθεί τιµές µόνο για τις 3 πρώτες γραµµές του πίνακα και µάλιστα για τη δεύτερη γραµµή έχει ορισθεί η τιµή µόνο του πρώτου στοιχείου.
Η παραπάνω δήλωση έχει ως αποτέλεσµα τη δηµιουργία του ακόλουθου πίνακα:
Εάν δε συµπεριληφθούν τα ενδιάµεσα άγκιστρα: το αποτέλεσµα είναι ο ακόλουθος πίνακας, που είναι σαφώς διαφορετικός, οπότε
Όπως και µε τους πίνακες µίας διάστασης, έτσι και στους πολυδιάστατους πίνακες εάν αµεληθεί να δοθεί το µέγεθος του πίνακα, ο µεταγλωττιστής θα το καθορίσει αυτόµατα µε βάση τον αριθµό αρχικών τιµών που παρουσιάζονται.
Ωστόσο στους πολυδιάστατους πίνακες µπορεί να παραληφθεί ο αριθµός των στοιχείων µόνο της πρώτης διάστασης, καθώς ο µεταγλωττιστής µπορεί να τον υπολογίσει από τον αριθµό των αρχικών τιµών που διατίθενται.
Η παρακάτω δήλωση αξιοποιεί τη δυνατότητα αυτή του µεταγλωττιστή:
Με την παραπάνω δήλωση ο ar δηλώνεται αυτόµατα ως πίνακας 2x3x2. είναι ανεπίτρεπτη επειδή ο µεταγλωττιστής δεν µπορεί να γνωρίζει τι είδους θα ήταν αυτός ο πίνακας.
Θα µπορούσε να το θεωρήσει είτε πίνακα 2x3 είτε 3x2. είναι λανθασµένη στη γλώσσα C αλλά δεν εντοπίζεται από το µεταγλωττιστή και οδηγεί σε ανεπιθύµητα αποτελέσµατα..
Η σωστή είναι
Έστω πίνακας που αναπαριστά τις µέσες θερµοκρασίες των µηνών των τελευταίων τριών ετών.
Να δοθούν: (α) βρόχος για τον υπολογισµό των µέσων ετήσιων θερµοκρασιών των τριών ετών, (β) βρόχος για τον υπολογισµό των µέσων µηνιαίων θερµοκρασιών των τριών ετών. // ο temp θεωρείται αρχικοποιηµένος
Αποθήκευση των πινάκων στη µνήµη Η πρόταση δήλωσης int ar[5]; έχει ως αποτέλεσµα τη δέσµευση χώρου στη µνήµη για την αποθήκευση 5 µεταβλητών ακέραιου τύπου.
Έστω ότι µέσα στον κώδικα του προγράµµατος υπάρχουν οι παρακάτω προτάσεις ανάθεσης, που αποδίδουν τιµές σε στοιχεία του πίνακα:
Στο σχήµα 6-2 φαίνεται η µορφή που έχει η µνήµη, η οποία έχει δεσµευτεί για την αποθήκευση του πίνακα ar, θεωρώντας 32 bits για κάθε ακέραιο και πως η πρώτη διεύθυνση είναι η 1000.
Γίνεται αντιληπτό ότι τα ar[1] και ar[3] έχουν απροσδιόριστες τιµές.
Τα περιεχόµενα αυτών των θέσεων µνήµης είναι ο,τιδήποτε έχει µείνει στις θέσεις αυτές από προηγούµενη αποθήκευση.
Οι απροσδιόριστες τιµές αναφέρονται ως «σκουπίδια» (junk) και πολλές φορές αποτελούν αιτία πρόκλησης
Για την αποφυγή προβληµάτων αυτής της µορφής πρέπει να αποδίδονται αρχικές τιµές στους πίνακες ή να υπάρχει συνεχής αντίληψη του τι περιλαµβάνει ένας πίνακας.
Θα πρέπει να σηµειωθεί ότι η ANSI C διασφαλίζει ότι οι καθολικές µεταβλητές (αρχικοποιούνται από το σύστηµα µε την τιµή 0.
Αυτό συµβαίνει βέβαια και για όλα τα στοιχεία πίνακα, ο οποίος έχει δηλωθεί ως καθολική µεταβλητή.
Το αλφαριθµητικό ή συµβολοσειρά (string) είναι ένας πίνακας χαρακτήρων που τερµατίζει µε το µηδενικό (null) χαρακτήρα.
Ο µηδενικός χαρακτήρας έχει ASCII κωδικό 0 και αναπαρίσταται από την ακολουθία διαφυγής \0.
Η δήλωση του αλφαριθµητικού ακολουθεί τον εξής φορµαλισµό: char όνοµα[µήκος] ∆ιακρίνονται τρία τµήµατα: α) ο τύπος δεδοµένου, ο οποίος είναι πάντοτε char, β) το όνοµα του αλφαριθµητικού και γ) το µήκος του.
Έτσι, µία τυπική δήλωση ενός αλφαριθµητικού 30 χαρακτήρων έχει την ακόλουθη µορφή: Τα αλφαριθµητικά µπορούν να εµφανίζονται µέσα στον κώδικα όπως οι αριθµητικές σταθερές, αποτελώντας τις αλφαριθµητικές σταθερές.
Η αλφαριθµητική σταθερά απαντήθηκε σε προηγούµενο κεφάλαιο, όπου και σηµειώθηκε ότι οι χαρακτήρες της περικλείονται σε διπλά εισαγωγικά.
Για την αποθήκευσή της χρησιµοποιείται ένας πίνακας χαρακτήρων, µε το µεταγλωττιστή να θέτει αυτόµατα στο τέλος του αλφαριθµητικού ένα µηδενικό χαρακτήρα για να προσδιορίσει το τέλος του.
Έτσι, η αλφαριθµητική σταθερά “Hello” απαιτεί για αποθήκευση 6 bytes, όπως φαίνεται παρακάτω:
Παρατήρηση: Θα πρέπει να σηµειωθεί η διαφορά ανάµεσα στη σταθερά χαρακτήρα ‘Α’ και την αλφαριθµητική σταθερά “Α”.
Η πρώτη απαιτεί 1 byte για αποθήκευση, ενώ η δεύτερη απαιτεί ένα byte για το χαρακτήρα Α κι ένα byte για το
Η ανάθεση τιµής µε τη δήλωση ακολουθεί το γενικό κανόνα απόδοσης αρχικής
Στην πράξη χρησιµοποιείται η ακόλουθη εναλλακτική και πιο συµπαγής µορφή µε χρήση αλφαριθµητικής σταθεράς:
Θα πρέπει να προσεχθεί ότι στη δήλωση µε λίστα στοιχείων ο προγραµµατιστής πρέπει να περιλάβει ως τελευταία τιµή το null.
Στο δεύτερο τρόπο απόδοσης αρχικής τιµής, αυτή την εργασία την εκτελεί αυτόµατα ο µεταγλωττιστής.
Είσοδος - έξοδος αλφαριθµητικών
Η εισαγωγή αλφαριθµητικού από την κύρια είσοδο γίνεται µε τη µορφοποιούµενη συνάρτηση scanf και τον προσδιοριστή %s.
Η πρόταση διαβάζει την κύρια είσοδο ως αλφαριθµητικό και αποθηκεύει την τιµή στη µεταβλητή isbn.
∆ε χρειάζεται ο τελεστής & πριν από το όνοµα της µεταβλητής isbn όπως συνέβαινε µε τους άλλους τύπους δεδοµένων, γιατί το όνοµα του αλφαριθµητικού αναπαριστά τη διεύθυνση του πρώτου στοιχείου του.
Εναλλακτικά, η εισαγωγή αλφαριθµητικού µπορεί να γίνει µε χρήση της συνάρτησης gets, η γενική µορφή της οποίας είναι gets(όνοµα_πίνακα_χαρακτήρων) Καλείται η gets µε το όνοµα του πίνακα χαρακτήρων ως όρισµα, χωρίς δείκτη.
Με την επιστροφή από τη gets το αλφαριθµητικό θα έχει περασθεί στον πίνακα χαρακτήρων.
Η gets θα διαβάζει χαρακτήρες από το πληκτρολόγιο έως ότου πατηθεί
Το αλφαριθµητικό αποθηκεύεται σε έναν πίνακα χαρακτήρων µαζί µε το τελικό µηδενικό χαρακτήρα.
Κατά συνέπεια, όταν δηλώνεται το µέγεθος του πίνακα, έστω Ν, σε αυτόν µπορεί να αποθηκευθεί αλφαριθµητικό µέγιστου µήκους Ν-1.
Θα πρέπει να σηµειωθεί ότι τόσο η scanf όσο και η gets δεν εκτελούν έλεγχο ορίων στον πίνακα χαρακτήρων µε τον οποίο καλούνται.
Εάν π.χ. δηλωθεί char isbn[30] και το αλφαριθµητικό είναι µεγαλύτερο από το µέγεθος του isbn, ο πίνακας
Η εκτύπωση αλφαριθµητικής σταθεράς γίνεται µε την printf χωρίς τη χρήση προσδιοριστή.
Απλώς της δίνεται η προς εκτύπωση αλφαριθµητική σταθερά:
H εκτύπωση αλφαριθµητικού γίνεται µε την printf χρησιµοποιώντας τον προσδιοριστή %s.
Η παρακάτω πρόταση printf( "Τhe ISBN code is: %s", isbn ); θα έχει ως αποτέλεσµα να τυπωθεί στην οθόνη η πρόταση Τhe ISBN code is: 0-49-743-3 Εναλλακτικά, η εκτύπωση αλφαριθµητικής σταθεράς και αλφαριθµητικού µπορεί να γίνει µε χρήση της συνάρτησης puts, η γενική µορφή της οποίας είναι puts(όνοµα_πίνακα_χαρακτήρων) Καλείται η puts µε το όνοµα του πίνακα χαρακτήρων ως όρισµα, χωρίς δείκτη, π.χ. puts(isbn).
Βέβαια, η puts παρουσιάζει το µειονέκτηµα ότι δεν παρέχει δυνατότητες µορφοποίησης της εξόδου.
Στο ακόλουθο πρόγραµµα γίνεται εισαγωγή και εκτύπωση αλφαριθµητικών µε όλους τους τρόπους που περιγράφηκαν ανωτέρω.
Θα πρέπει να προσεχθεί η χρήση της define για την εισαγωγή αλφαριθµητικής σταθεράς.
Η C υποστηρίζει µία ποικιλία συναρτήσεων για το χειρισµό των αλφαριθµητικών.
Οι συναρτήσεις αυτές βρίσκονται στο αρχείο κεφαλίδας <string.h>.
Οι πιο συνηθισµένες παρουσιάζονται στον ακόλουθο πίνακα, στον οποίο η δεύτερη και η τρίτη στήλη περιέχουν τα ονόµατα των συναρτήσεων όταν η λειτουργία τους επιδρά σε ολόκληρο το αλφαριθµητικό ή στους πρώτους n
Λειτουργία Όλοι οι χαρακτήρες Οι n πρώτοι χαρακτήρες Εύρεση µήκους string strlen() Αντιγραφή string stcpy() strncpy() Συνένωση 2 strings strcat() strncat() Σύγκριση 2 strings strcmp() strncmp() Εύρεση χαρακτήρα σε string strchr() strrchr() Εύρεση string σε string strstr()
H συνάρτηση µήκους αλφαριθµητικού H συνάρτηση strlen() επιστρέφει τον αριθµό χαρακτήρων του αλφαριθµητικού, χωρίς να συµπεριλαµβάνει το µηδενικό χαρακτήρα.
Το παρακάτω τµήµα κώδικα θα τυπώσει τον αριθµό των χαρακτήρων του αλφαριθµητικού name, δηλαδή 4 κι όχι 12, που είναι ο αριθµός των στοιχείων του πίνακα χαρακτήρων name.
H συνάρτηση αντιγραφής αλφαριθµητικού H συνάρτηση strcpy() αντιγράφει ένα αλφαριθµητικό από έναν πίνακα σε έναν άλλο.
∆έχεται δύο ορίσµατα που είναι τα ονόµατα των αλφαριθµητικών.
Το όνοµα του πίνακα προορισµού πρέπει να είναι το πρώτο όρισµα, ενώ το δεύτερο όρισµα προσδιορίζει τον πίνακα πηγής.
Στο παρακάτω τµήµα κώδικα η πρόταση strcpy(name1,name2); αντιγράφει το περιεχόµενο του πίνακα name2 στον πίνακα name1.
Έτσι στην οθόνη θα εµφανισθεί το «ef».
Για να αντιγραφούν οι πρώτοι n χαρακτήρες του name2 χρησιµοποιείται η σύνταξη strncpy(name1,name2,n), όπου το τρίτο όρισµα είναι ο αριθµός των προς
H συνάρτηση συνένωσης αλφαριθµητικών H συνάρτηση stcat() δέχεται δύο ορίσµατα που είναι τα ονόµατα των αλφαριθµητικών, τα οποία και συνενώνει.
Συγκεκριµένα, προσθέτει στο τέλος του αλφαριθµητικού, που προσδιορίζεται από το πρώτο όρισµα, τα στοιχεία του αλφαριθµητικού που προσδιορίζεται από το δεύτερο όρισµα.
Στο παρακάτω τµήµα προστίθεται στο τέλος του πίνακα name1 το περιεχόµενο του πίνακα name2.
Έτσι στην οθόνη θα εµφανισθεί το «abcdef».
Για να προστεθούν οι πρώτοι n χαρακτήρες του name2 χρησιµοποιείται η σύνταξη strncat(name1,name2,n), όπου το τρίτο όρισµα είναι ο αριθµός των
Να περιγραφεί η λειτουργία του ακόλουθου προγράµµατος: ∆ηλώνονται δύο πίνακες χαρακτήρων 20 θέσεων και µε χρήση της συνάρτησης αντιγραφής αλφαριθµητικών τους αποδίδονται τα περιεχόµενα "Lucky you!" και
Ακολούθως οι τρεις πρώτοι χαρακτήρες του msg2 προσαρτώνται στο τέλος του msg1.
Τέλος, στο msg1 αντιγράφεται το αλφαριθµητικό "Hello".
H συνάρτηση σύγκρισης αλφαριθµητικών H συνάρτηση strcmp(name1,name2) δέχεται δύο ορίσµατα που είναι τα ονόµατα των αλφαριθµητικών, τα οποία και συγκρίνει.
Η έξοδός της είναι ένας ακέραιος αριθµός, ο οποίος λαµβάνει την τιµή 0 εφόσον τα αλφαριθµητικά είναι όµοια.
Για να συγκριθούν οι πρώτοι n χαρακτήρες των αλφαριθµητικών χρησιµοποιείται η σύνταξη strncmp(name1,name2,n), όπου το τρίτο όρισµα είναι ο αριθµός των προς σύγκριση χαρακτήρων.
∆ηλώνονται δύο πίνακες χαρακτήρων 81 θέσεων, στους οποίους αποδίδονται τα περιεχόµενα "Hello to you" και "Hello to me!", αντίστοιχα.
Ακολούθως συγκρίνονται τα δύο αλφαριθµητικά µε χρήση της strcmp() και κατόπιν συγκρίνονται οι πέντε πρώτοι χαρακτήρες τους µε χρήση της strncmp().
Στο παρόν κεφάλαιο θα χρησιµοποιηθεί το σύνολο των στοιχείων της C, που παρατέθηκαν στα προηγούµενα κεφάλαια, µε άµεσο στόχο την υλοποίηση απλών προβληµάτων και απώτερο την εισαγωγή στη λογική της προγραµµατιστικής ανάλυσης.
Επιπρόσθετα, τα παραδείγµατα που θα αναπτυχθούν στη συνέχεια αποτελούν µία ενδεικτική αναφορά για τον αναγνώστη, καθώς αποτελούν επιλεγµένα
Να γραφεί πρόγραµµα, το οποίο να δέχεται ως είσοδο κείµενο, να απαριθµεί τις εµφανίσεις των ψηφίων 0-9, τα λευκά διαστήµατα και τους υπόλοιπους χαρακτήρες και στη συνέχεια να τυπώνει τα αποτελέσµατα.
Το πρόγραµµα ολοκληρώνεται όταν δοθεί ο χαρακτήρας τελεία ‘.’.
Το παραπάνω πρόβληµα µπορεί να µορφοποιηθεί σε δδοοµµηηµµέένναα ΕΕλλλληηννιικκάά ως
Για κάθε χαρακτήρα του κειµένου που είναι διάφορος της ‘. ’ ελέγχεται ο τύπος του χαρακτήρα αν είναι ένας από τους ‘ ’, ‘\t’, ‘\n’ αυξάνεται κατά µία µονάδα ο απαριθµητής των διαστηµάτων αυξάνεται κατά µία µονάδα ο απαριθµητής που αντιστοιχεί στο σε κάθε άλλη περίπτωση αυξάνεται κατά µία µονάδα ο απαριθµητής των υπόλοιπων Όσον αφορά στις µεταβλητές, απαιτείται ένας απαριθµητής για τα διαστήµατα, τον οποίο ονοµάζουµε n_white, ένας απαριθµητής για τους λοιπούς χαρακτήρες, ο n_other, και δέκα απαριθµητές για τα ψηφία.
Για την τελευταία περίπτωση µπορούµε να δηλώσουµε δέκα ανεξάρτητες µεταβλητές αλλά είναι προτιµότερο να επιλεχθεί ένας πίνακας δέκα θέσεων, όπως ο int n_digit[10], o οποίος οδηγεί σε πιο συµπαγή και δοµηµένο κώδικα.
Για την εκτύπωση των αριθµών των εµφανίσεων των δέκα ψηφίων, στην περίπτωση του πίνακα απαριθµητών, ο αντίστοιχος κώδικας θα έχει τη µορφή Για τη διεργασία «πάρε χαρακτήρα» χρησιµοποιείται η συνάρτηση getchar, η οποία επιστρέφει το χαρακτήρα που διαβάζει από την κύρια είσοδο.
Αυτός ο χαρακτήρας πρέπει να αποθηκευθεί σε µία µεταβλητή τύπου χαρακτήρα για
Τα παραπάνω οδηγούν στη δήλωση και στην έκφραση η τιµή της οποίας είναι η τιµή του αριστερού τελεστέου της έκφρασης.
Για την ανίχνευση του τέλους της εισαγωγής χαρακτήρων χρησιµοποιούµε το συσχετιστικό τελεστή != οδηγούµαστε στην έκφραση
Η έκφραση γίνεται ψευδής όταν αναγνωσθεί ο χαρακτήρας τελεία.
Μπορεί εποµένως να χρησιµοποιηθεί ως έκφραση µίας πρότασης while, που θα οδηγεί στην επανάληψη του συνόλου των ενεργειών που το πρόγραµµα πρέπει να εκτελεί για κάθε ∆ιαµόρφωση της ροής ελέγχου: Με βάση τα προηγούµενα, η περιγραφή διαµορφώνεται ως εξής:
Το σώµα της while αποτελεί κλασική περίπτωση επιλογής από αµοιβαία αποκλειόµενες ενέργειες, γεγονός που οδηγεί στη χρήση της πρότασης switch.
Η έκφραση ανάλογα µε την τιµή της οποίας θα γίνει η επιλογή της κατάλληλης ενέργειας είναι η απλή έκφραση ch.
εάν είναι ένας από τους ‘ ’, ‘\t’, ‘\n’ αυξάνεται κατά µία µονάδα ο απαριθµητής n_white εάν ο χαρακτήρας είναι ψηφίο αυξάνεται κατά µία µονάδα ο απαριθµητής που αντιστοιχεί στο µία πρώτη µορφή του κώδικα είναι η παρακάτω
O κώδικας αυτός δεν εκµεταλλεύεται τη δήλωση των απαριθµητών των ψηφίων ως πίνακα χαρακτήρων.
Για το λόγο αυτό, θα προσπαθήσουµε να ενοποιήσουµε τα case ώστε να έχουν µία παραµετρική πρόταση, που σε κάθε περίπτωση θα οδηγεί στην αύξηση του κατάλληλου απαριθµητή.
Θεωρούµε την έκφραση και εξετάζουµε την τιµή της για τιµές τής ch από το σύνολο {‘0’, ‘1’, …, ‘9’}.
Είναι προφανές ότι, εάν το ch είναι ‘0’, η έκφραση έχει τιµή 0 οπότε και η πρόταση έχει ως αποτέλεσµα την αύξηση του απαριθµητή που αντιστοιχεί στο ψηφίο ‘0’.
Αντίστοιχα, η παραπάνω πρόταση για ch=‘8’ θα αυξήσει τον απαριθµητή που αντιστοιχεί στο ‘0’.
Κατά αυτόν τον τρόπο οδηγούµαστε στον ακόλουθο συµπαγή
Για τα υπόλοιπα στοιχεία έχουµε την κλασική περίπτωση χρήσης της εντολής default, οπότε προκύπτει:
Το τελευταίο σηµείο που πρέπει να προσεχθεί είναι η αρχικοποίηση των
Να γραφεί πρόγραµµα που επιλύει δευτεροβάθµιες εξισώσεις.
Να δέχεται ως είσοδο τους συντελεστές της εξίσωσης και να ελέγχει το είδος των ριζών (απλές πραγµατικές, συζυγείς µιγαδικές ή διπλή πραγµατική).
Θεωρείστε την περίπτωση #include<math.h> // για sqrt(), fabs() if (a==0) // Έλεγχος για α=0, οπότε η εξίσωση γίνεται α/θµια if(D<0) // Εάν ∆<0, οι ρίζες είναι συζυγείς µιγαδικές { // Εάν ∆=0, υπάρχει διπλή ρίζα } //τέλος του else if else // Σε κάθε άλλη περίπτωση υπάρχουν δύο πραγµατικές ρίζες } //τέλος της else } //τέλος της main
Αποτέλεσµα για διπλή πραγµατική ρίζα:
Αποτέλεσµα για συζυγείς µιγαδικές ρίζες:
Αποτέλεσµα για απλές πραγµατικές ρίζες:
Να γραφεί πρόγραµµα, χωρίς χρήση της εντολής goto, µε το οποίο θα εισάγονται από το πληκτρολόγιο δύο ζεύγη πραγµατικών αριθµών (x1,y1), (x2,y2).
Από τα ζεύγη αυτά θα υπολογίζονται οι συντελεστές a, b της εξίσωσης της ευθείας y=ax+b.
Θα πρέπει να λαµβάνεται πρόνοια ώστε σε περίπτωση που x2=x1 να ζητείται εκ νέου το σηµείο (x2,y2).
Οι συντελεστές a, b να εµφανίζονται στην οθόνη. } //τέλος της main
Να γραφεί πρόγραµµα, το οποίο θα δέχεται από το πληκτρολόγιο διαδοχικά 6 ακέραιους αριθµούς του ΛΟΤΤΟ.
Θα πρέπει να λαµβάνεται πρόνοια ώστε όταν είτε ένας αριθµός δεν ανήκει στο [1 49] είτε επαναλαµβάνεται αριθµός που δόθηκε προηγουµένως, να ζητείται νέα τιµή γι’ αυτόν.
Οι αριθµοί θα αποθηκεύονται σε πίνακα ακεραίων και θα εµφανίζονται στην οθόνη µετά το πέρας της εισαγωγής τους. for (j=0;j<i;j++) if (lotto[j]==lotto[i]) deikt++; //Να µην } //τέλος της while
Να γραφεί πρόγραµµα, µε το οποίο θα εισάγονται από το πληκτρολόγιο 4 αλφαριθµητικά σε πίνακα αλφαριθµητικών, µήκους 7 χαρακτήρων το καθένα.
Στη συνέχεια θα λαµβάνονται οι τρεις πρώτοι χαρακτήρες κάθε αλφαριθµητικού και θα συνενώνονται σε ένα νέο αλφαριθµητικό, το οποίο και θα τυπώνεται. char str[4][8], str_total[13]; //στις διαστάσεις των πινάκων θα πρέπει //ληφθεί υπόψη και ο ‘\0’
Να γραφεί πρόγραµµα µε το οποίο θα εισάγονται 6 πραγµατικοί αριθµοί από το πληκτρολόγιο, θα αποθηκεύονται στον πίνακα array[] και θα τυπώνονται: α) οι θετικοί εξ αυτών, β) ο µεγαλύτερος, γ) ο αριθµός των στοιχείων του array[], τα οποία έχουν τιµές στο διάστηµα [1.05 50.8]. for (i=0;i<N;i++) /* i=0 για να µπουν όλα σε ένα βρόχο, µόνο για το
Να γραφεί πρόγραµµα µε το οποίο θα εισάγονται 6 χαρακτήρες από το πληκτρολόγιο, θα αποθηκεύονται στον πίνακα array[] και θα τυπώνονται διαδοχικά α) οι χαρακτήρες µε δεκαδικό ισοδύναµο µικρότερο του 75 β) ο χαρακτήρας µε το µικρότερο δεκαδικό ισοδύναµο γ) όσοι χαρακτήρες είναι διάφοροι των χαρακτήρων ‘b’, ‘c’, ‘d’ (υλοποίηση αποκλειστικά µε χρήση της εντολής switch-case) } //τέλος της switch } // τέλος της for
