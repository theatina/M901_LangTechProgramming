Η Γλώσσα Βάσεων Δεδομένων SQL
Το εργαστήριο “Βάσεις Δεδομένων Ι” αποτελείται από μία σειρά ασκήσεων πάνω στις σχεσιακές βάσεις δεδομένων και τη γλώσσα SQL.
Οι πρώτες τρεις ασκήσεις αφορούν την δημιουργία βάσης δεδομένων, ανάπτυξη των οθονών της εφαρμογής, τις βασικές λειτουργίες και τη βασική χρήση της γλώσσας QBE και της γλώσσας SQL πάνω σε μία βάση δεδομένων για μία πανεπιστημιακή σχολή, και αφορά τα κεφάλαια του βιβλίου “Σχεσιακές βάσεις δεδομένων, Χ.
Σκουρλάς, Νέων Τεχν.
Αθήνα 2000”.
Η τέταρτη άσκηση είναι επαναληπτική.
Οι επόμενες ασκήσεις αφορούν το κεφ.8 της γλώσσας SQL του βιβλίου “Fundamentals of Database Systems, R.
Α, Diaulos ed., 2001” και τη βάση δεδομένων μιας εταιρίας με εργαζομένους και τμήματα που είναι και η εκπαιδευτική προεγκατεστημένη βάση της Oracle.
Η αμέσως επόμενη άσκηση αφορά συμπληρωματικές έννοιες όπως παρουσιάζονται στα κεφ. 7, 8 του βιβλίου “Σχεδιασμός Βάσεων Δεδομένων & SQL, Βασιλακόπουλος Γ., Πειραιάς, 1993”.
Οι τέσσερις τελευταίες ασκήσεις αφορούν το κεφ. 4 της γλώσσας SQL από το βιβλίο “Database System Concepts, H.
Sudarshan, 3rd Edition, McGraw-Hill, 1998” και το παράδειγμα μιας τράπεζας και περιέχουν εκτεταμένα προβλήματα για το σύνολο των εντολών της γλώσσας SQL όπως καλύπτεται στην ύλη του βιβλίου “SQL Fundamentals, John Patrick, 2nd ed.
Οι βάσεις δεδομένων και τα συστήματα των βάσεων δεδομένων αποτελούν ένα σημαντικό στοιχείο της καθημερινής ζωής στη σύγχρονη κοινωνία.
Για παράδειγμα, αν πάμε στην τράπεζα για κατάθεση η ανάληψη χρημάτων, αν κάνουμε κράτηση ξενοδοχείου η αεροπορικού ταξιδιού, αν ψάχνουμε βιβλιογραφικά στοιχεία από έναν κατάλογο βιβλιοθήκης η αν παραγγέλνουμε μια συνδρομή περιοδικού σ' έναν εκδότη, υπάρχει πιθανότητα η δραστηριότητα μας να περιλαμβάνει κάποια προσπέλαση σε βάση δεδομένων.
Ακόμη και η αγορά αντικειμένων από ένα σούπερ μάρκετ σήμερα περιλαμβάνει σε πολλές περιπτώσεις ενημέρωση της βάσης δεδομένων όπου καταχωρούνται τα αποθέματα των προϊόντων του σούπερ μάρκετ.
Αυτές οι διεπαφές είναι παραδείγματα αυτού που αποκαλούμε παραδοσιακές εφαρμογές των βάσεων δεδομένων, όπου οι περισσότερες αποθηκευμένες πληροφορίες είναι ή σε μορφή text ή σε μορφή αριθμών.
Τα τελευταία χρόνια η πρόοδος στην τεχνολογία έχει οδηγήσει σε συναρπαστικές νέες εφαρμογές των συστημάτων βάσεων δεδομένων.
Οι βάσεις δεδομένων πολυμέσων μπορούν σήμερα να αποθηκεύουν εικόνες, video και μηνύματα ήχου.
Τα γεωγραφικά πληροφοριακά συστήματα (GIS) μπορούν να αποθηκεύουν και να αναλύσουν δεδομένα καιρού και δορυφορικές εικόνες.
Οι αποθήκες δεδομένων και τα on-line συστήματα αναλυτικής επεξεργασίας (OLAP) χρησιμοποιούνται σε πολλές εταιρείες για την εξαγωγή και ανάλυση χρήσιμων πληροφοριών από μεγάλες βάσεις δεδομένων για λήψη αποφάσεων.
Οι τεχνικές αναζήτησης των βάσεων δεδομένων έχουν εφαρμοσθεί στο We για τη βελτίωση της αναζήτησης πληροφοριών.
Είναι εύλογο να ειπωθεί ότι οι βάσεις δεδομένων θα διαδραματίσουν κρίσιμο ρόλο σε όλες τις περιοχές όπου χρησιμοποιούνται υπολογιστές όπως στις επιχειρήσεις, στη μηχανική, στην ιατρική, στα νομικά, στην εκπαίδευση και στη βιβλιοθηκονομία, για να αναφέρουμε μερικές μόνο από αυτές.
Η φράση βάση δεδομένων βρίσκεται σε τόσο κοινή χρήση που πρέπει να αρχίσουμε ορίζοντας τι είναι μια βάση δεδομένων.
Βάση δεδομένων (database) είναι μια ολοκληρωμένη συλλογή από σχετιζόμενα δεδομένα.
Για παράδειγμα, σε ένα πανεπιστήμιο, οι καθηγητές διδάσκουν μαθήματα, τα οποία παρακολουθούνται από φοιτητές.
Άρα θα αποτελείται από το σύνολο των Φοιτητών, το σύνολο των Μαθημάτων και το σύνολο των Καθηγητών.
Αν μια πληροφορία δεν σχετίζεται με άλλες, τότε δεν ανήκει στη συγκεκριμένη βάση δεδομένων.
Μια βάση δεδομένων που αποτελείται από κάποια συλλογή δεδομένων χρησιμοποιείτε από όλα τα συστήματα των εφαρμογών μιας επιχείρησης, ενός οργανισμού ενός ιδιώτη κλπ.
Μερικά παραδείγματα είναι τα: · Τράπεζες - Νοσοκομεία- Πανεπιστήμια- Κρατικές υπηρεσίες · Αντιπροσωπεία Αυτοκινήτων (Αγορές-Πωλήσεις-Ενοικιάσεις) · Βάση Εφαρμογών Λογισμικού (Εταιρείες, Κατηγορίες, Λογισμικά, Λειτουργικά) · Βιβλίο Εσόδων-Εξόδων (Κατηγορίες, Κινήσεις, Πελάτες, Προμηθευτές) · Διαχείριση εστιατορίου (Υπάλληλοι, Κινήσεις-Παραγγελίες, Τραπέζια) · Διαχείριση μηχανογραφικού κέντρου (Servers, Υπολογιστές, Administrators, Χρήστες, Περιφερειακά, Λογισμικό, Δίκτυα) · Εμπορικό κύκλωμα (Πελάτες, Προμηθευτές, Κινήσεις, Αποθήκη) · Εταιρεία Πώλησης Software / Hardware · Ιατρείο - Λογιστικό Γραφείο - Μεσιτικό Γραφείο · Εταιρεία εύρεσης προσωπικού επιχειρήσεων (Επιχειρήσεις, Ειδικότητες, Κινήσεις) · Πολιτικό γραφείο υπ.
Βουλευτή (Ραντεβού, Ψηφοφόροι, Επαγγέλματα, Πόλεις) · Σχολείο (Μαθητές, Καθηγητές, Τμήματα, Μαθήματα, Αίθουσες) · Ταμείο Επιχείρησης (Εσοδα, Εξοδα, Αξιόγραφα, Πελάτες, Προμηθευτές) · Τεχνική Βοήθεια (Ηλεκτρικά / Υδραυλικά κλπ) · Τεχνική Εταιρεία (Έργα, Υλικά, Πελάτες, Προμηθευτές, Υπεργολάβοι, Εργάτες) Σήμερα επίσης, οι βάσεις δεδομένων χρησιμοποιούνται όλο και περισσότερο και για άλλου είδους εφαρμογές — όπως είναι τα συστήματα υποστήριξης αποφάσεων (decision support systems).
Στην πράξη μάλιστα, οι επιχειρήσεις διατηρούν στις μέρες μας δύο ξεχωριστές βάσεις δεδομένων, μία για τα επιχειρησιακά δεδομένα και άλλη μία για τα δεδομένα υποστήριξης αποφάσεων.
Η αποθήκη δεδομένων συναλλαγών για υποστήριξη αποφάσεων αποτελείται συχνά και από συγκεντρωτικές πληροφορίες (π.χ. πληροφορίες για συνολικές ποσότητες και μέσους όρους), οι οποίες εξάγονται περιοδικά (για παράδειγμα, καθημερινά ή εβδομαδιαία) από την επιχειρησιακή βάση δεδομένων με σκοπό την παραγωγή συγκεντρωτικών αναφορών, την αναλυτική επεξεργασία, αναζήτηση συσχετίσεων, παραγωγή δένδρων αποφάσεων, ανακάλυψη προτύπων ακολουθιών, ανάλυση ομάδων, κατηγοριοποίηση, συσταδοποίηση και άλλες λειτουργίες data mining.
Η διαχείριση των δεδομένων περιλαμβάνει: τον ορισμό δομών για τη αποθήκευση των δεδομένων και τον ορισμό μεθόδων για τη διαχείριση των δεδομένων Ο ορισμός της δομής της βάσης δεδομένων βασίζεται σε ένα μοντέλο δεδομένων το οποίο ορίζει τον τρόπο που περιγράφονται τα δεδομένα, οι συσχετίσεις τους, η σημασία τους και οι περιορισμοί ακεραιότητας πάνω στα δεδομένα αυτά.
Το σχεσιακό μοντέλο (relational model) δεδομένων παριστάνει δεδομένα και τις συσχετίσεις τους ως ένα σύνολο πινάκων.
Κάθε πίνακας (table) αποτελείται από στήλες (columns) με μοναδικά ονόματα.
Μια γραμμή (row) του πίνακα παριστάνει μια σχέση (relation) ανάμεσα σε ένα σύνολο από τιμές.
Ένα Σχήμα Βάσης Δεδομένων είναι ένα σύνολο πινάκων (Σχέσεων) ΣΕΜΙΝΑΡΙΟ (ΚωδΣεμιναρίου, Τίτλος, Διάρκεια) ΠΡΟΑΠΑΙΤΟΥΜΕΝΑ ΣΕΜΙΝΑΡΙΑ (ΚωδΣεμιναρίου, ΚωδΠροαπαιτουμενου) ΠΡΟΣΦΕΡΟΜΕΝΑ ΜΑΘΗΜΑΤΑ (ΚωδΠροσφΜαθ, ΚωδΣεμιναριου, ΗμερομΕναρξης) ΔΗΛΩΣΕΙΣ ΣΥΜΜΕΤΟΧΗΣ (ΚωδΠροσφΜαθ, ΚωδΣεμιναρίου, ΚωδΥπαλλήλου, Βαθμός) ΔΙΔΑΣΚΟΝΤΕΣ (ΚωδΠροσφΜαθ, ΚωδΣεμιναρίου, ΚωδΥπαλλήλου, ΩρεςΔιδασκαλίας) ΥΠΑΛΛΗΛΟΙ (ΚωδΥπαλλήλου, Όνομα, Επώνυμο, Εργασία) Το σχεσιακό σχήμα μίας βάσης δεδομένων εκπαίδευσης που περιέχει πληροφορίες για ένα εσωτερικό εκπαιδευτικό πρόγραμμα μιας εταιρείας.
Σημειώστε ότι μερικά πεδία-γνωρίσματα στο σχήμα εμφανίζονται πολλές φορές.
Αυτό δεν είναι λάθος.
Προσφέρει τον τρόπο σύνδεσης των πινάκων μεταξύ τους.
Περιορισμοί Σχεσιακής ακεραιότητας:
Περιορισμός κλειδιού: Κάθε πίνακας πρέπει να έχει ένα πρωτεύον κλειδί για να εξασφαλίζεται η μοναδικότητα των εγγραφών.
Ακεραιότητα οντότητας: Ένα πρωτεύον κλειδί δεν μπορεί να περιέχει τιμή Null.
Ακεραιότητα αναφορών: Δεν είναι δυνατόν να υπάρχει μία τιμή ξένου κλειδιού σε έναν πίνακα R1 η οποία δεν αντιστοιχεί σε καμία τιμή του πρωτεύοντος κλειδιού του άλλου πίνακα R2.
Συνήθως μία συσχέτιση A δημιουργείται μεταξύ των δύο πινάκων για να διατηρεί την ακεραιότητα αυτών των αντιστοιχιών.
Η SQL (Structured Query Language - Δομημένη Γλώσσα Ερωτημάτων) είναι μία σχεσιακή γλώσσα βάσεων δεδομένων η οποία σχεδιάστηκε και υλοποιήθηκε από την IBM.
Αρχικά η SQL ονομαζόταν SEQUEL (από το Structured English QUery Language).
Έπειτα από τόσα χρόνια συνεχίζει να προφέρεται έτσι.
Η SQL αποτελεί σήμερα την πιο διαδεδομένη γλώσσα διαχείρισης σχεσιακών βάσεων δεδομένων.
Η SQL παρέχει δυνατότητες για: · τον ορισμό, τη διαγραφή και τη μεταβολή πινάκων και κλειδιών, · τη σύνταξη ερωτήσεων (queries) για ανάκτηση δεδομένων, · την εισαγωγή, διαγραφή και μεταβολή στοιχείων, · τον ορισμό όψεων (views) πάνω στα δεδομένα, · τον ορισμό δικαιωμάτων πρόσβασης, · τον έλεγχο της ακεραιότητας των στοιχείων, · τον έλεγχο συναλλαγών (transaction) Η SQL είναι ορισμένη ως διεθνές πρότυπο ANSI SQL.
Προσκόληση στο πρότυπο ANSI SQL-2 Εξαιρετική (όχι συναλλαγές) (και επεκτάσεις SQL -3), σχετικά βαρύς server Εύκολη εγκατάσταση, δωρεάν διανομή για προσωπική χρήση εξαιρετική, καλύτερη σύνταξη για τις (join) συνενώσεις Σχετικά δύσκολη εγκατάσταση, δωρεάν διανομή για προσωπική χρήση MS Windows, Unix, mac os, πάνω από 30 διαφορετικά λειτουργικά συστήματα Πολύ καλή, όχι υποερωτήματα (ακόμη) όχι όψεις (views) Πολύ ελαφριά (μικρό footprint) και πολύ δημοφιλής (και επεκτάσεις SQL -3) εξαιρετική (λίγα bugs στις όψεις) Εύκολη εγκατάσταση, δωρεάν χρήση
Τα πακέτα εγκατάστασης των SQL Server, MySQL, MimerSQL και Oracle Server διανέμονται δωρεάν για προσωπική χρήση από τα αντίστοιχα site των εταιριών.
Τα client tools είναι αυτά που συνήθως δεν προσφέρονται δωρεάν.
Οι MySQL, MimerSQL και PostgreSQL παρέχονται επίσης μαζί με κάθε τυπική διανομή LINUX.
Η μηχανή desktop του SQL Server εγκαθίσταται στον υπολογιστή σας με κάθε εγκατάσταση του Visual Studio.
Υπάρχουν δεκάδες ακόμη υλοποιήσεις συστημάτων σχεσιακών βάσεων δεδομένων όπως τα DBASE, FOXPRO, PARADOX, DB2, INTRBASE, INFORMIX κ.α.
Για τα τελευταία υπάρχουν native drivers και στον Borland C++ Builder.
Όλα αυτά τα συστήματα χρησιμοποιούν την γλώσσα SQL.
Η υψηλού επιπέδου γλώσσα SQL έχει σαν κύρια συστατικά στοιχεία της μια γλώσσα ορισμού δεδομένων (Data Definition Language, DDL) και όψεων και μια γλώσσα χειρισμού δεδομένων (Data Manipulation Language, DML) καθώς και εντολών για καθορισμό περιορισμών και εξέλιξης του σχήματος.
Η SQL-DDL επιτρέπει τον ορισμό, τροποποίηση ή διαγραφή πινάκων.
Χρησιμοποιείται για να καθορίσει το σχήμα της βάσης δεδομένων ως σύνολο δηλώσεων DDL.
Οι δηλώσεις DDL μεταγλωτίζονται και δημιουργούν ένα σύνολο πινάκων που αποθηκεύονται σε ένα ειδικό αρχείο αποκαλούμενο λεξικό δεδομένων ή κατάλογος δεδομένων.
Ο κατάλογος δεδομένων περιέχει τα μεταδεδομένα.
Οι δομές αποθήκευσης και προσπέλασης δεδομένων που χρησιμοποιούνται από το σύστημα βάσης δεδομένων καθορίζονται με ένα σύνολο ορισμών από έναν τμήμα της γλώσσας αποκαλούμενο γλώσσα ορισμού και αποθήκευσης δεδομένων.
Η βασική ιδέα: η απόκρυψη των λεπτομερειών φυσικής υλοποίησης του σχήματος της βάσης από τους χρήστες.
Η SQL-DML, μπορεί να προσδιορίσει και να ανακτήσει πολλές εγγραφές ενός πίνακα με μία και μόνο εντολή DML και επομένως λέγεται και γλώσσα χειρισμού δεδομένων συνόλου τη φορά (set-at-a-time) ή συνολοστρεφής (set-oriented).
Μια ερώτηση σε μια υψηλού επιπέδου γλώσσα χειρισμού δεδομένων είναι δηλωτική γιατί προσδιορίζει ποια δεδομένα πρέπει να ανακτηθούν και όχι πώς θα ανακτηθούν αυτά.
Η SQL είναι ανεξάρτητη από την εσωτερική δομή της βάσης δεδομένων ή το λειτουργικό σύστημα.
Η ροή των πληροφοριών μεταξύ του χρήστη και της βάσης δεδομένων είναι όμοια με την παρακάτω εικόνα.
Το DBMS (Database Management System) έχει τον έλεγχο της διαχείρισης της βάσης δεδομένων.
Οι αιτήσεις στέλνονται στο DBMS όπου επεξεργάζονται και αλλάζουν σε εντολές ανάγνωσης/εγγραφής προς το διαχειριστή των αρχείων της βάσης.
Τα κύρια πλεονεκτήματα της SQL είναι η ανεξαρτησία κατασκευαστή όπου αλλάζοντας σύστημα βάσης δεδομένων συνήθως δεν χρειάζεται να ξαναγραφεί ο κώδικας SQL, η υψηλού-επιπέδου γλωσσική δομή, που κάνει εύκολη τη χρήση της γλώσσας, η Τυποποίηση που επικυρώθηκε από το ANSI και τον ISO, και η Δυναμική διαχείριση δεδομένων που προσφέρει προχωρημένες εντολές επεξεργασίας καθώς και τα ερωτήματα πολλαπλών επιπέδων.
H SQL έχει διάφορα τμήματα: Γλώσσα Ορισμού Δεδομένων (DDL)
Γλώσσα Χειρισμού Δεδομένων (DML) INSERT εισαγωγή εγγραφής DELETE διαγραφή εγγραφής UPDATE τροποποίηση εγγραφής Ενσωματωμένη Γλώσσα Χειρισμού Δεδομένων
CREATE DOMAIN S_No AS INTEGER CONSTRAINT Έλεγχος-Αριθμού-Προμηθευτή CHECK (S_No >0);
CREATE ASSERTION <Όνομα-δήλωσης> CHECK <Κατηγόρημα>;
CREATE TRIGGER <όνομα> ON UPDATE OF SUPPLIERS ()
Παρακάτω θα αναλύσουμε περισσότερο τα τμήματα της Γλώσσας Ορισμού Δεδομένων ορισμός, δημιουργία, τροποποίηση και διαγραφή σχήματος και της Γλώσσας Χειρισμού Δεδομένων ορισμός, δημιουργία, τροποποίηση, διαγραφή και επιλογή δεδομένων.
Η γλώσσα ορισμού δεδομένων της SQL (Data Definition Language) χρησιμοποιείται για την περιγραφή της δομής των πινάκων μιας βάσης δεδομένων (το λογικό σχήμα).
Τα δεδομένα κάθε στήλης ενός πίνακα πρέπει να έχουν ένα συγκεκριμένο τύπο.
Οι βασικοί τύποι που υποστηρίζονται από την SQL είναι οι παρακάτω:
Αλφαριθμητικό μεταβλητού μήκους (από 0 έως n), με μέγιστο μήκος n οριζόμενο από τον χρήστη.
Το n μπορεί να οριστεί από 0 έως 255 χαρακτήρες 2 byte ανά χαρακτήρα Αλφαριθμητικό σταθερού μήκους n που ορίζεται από τον χρήστη.
Το n μπορεί να οριστεί έως 255 χαρακτήρες Ακέραιος με εύρος τιμών από -2.147.483.648 έως 2.147.483.647
Μικρός ακέραιος, με εύρος τιμών από -32,768 έως 32,767.
Πολύ μικρός ακέραιος (0 έως 255) Πραγματικός αριθμός κινητής υποδιαστολής, απλής ακρίβειας Πραγματικός αριθμός κινητής υποδιαστολής, διπλής ακρίβειας Τιμή που παριστάνει με ακρίβεια αριθμούς από
Ημερομηνία της μορφής Π.χ. date ‘2002-10-22’ Ώρα της ημέρας σε ώρες, λεπτά, δευτερόλεπτα.
Π.χ. time ‘09:05:32’ Η ημέρα συν την ώρα.
Π.χ. timestamp ‘2002-10-22 09:05:32.75’
Νέοι πίνακες δημιουργούνται με την εντολή CREATE TABLE.
Η σύνταξη είναι: CREATE TABLE όνομα_πίνακα (πεδίο1 τύπος [(μέγεθος)] [, πεδίο2 τύπος [(μέγεθος)]) Περιορισμοί πρωτεύοντος κλειδιού, αναφορικής ακεραιότητας ξένων κλειδιών και not null primary key (Όνομα-πεδίου1 , Όνομα-πεδίου2), (Ορίζει τα πεδία που θα αποτελούν το πρωτεύον κλειδί) foreign key (Όνομα-πεδίου1) references Όνομα-Πίνακα (Όνομα-πεδίου1) (Ορίζει σε ποιο πρωτεύον κλειδί θα αναφέρονται οι τιμές του ξένου κλειδιού) Όνομα-πεδίου1 not null (Δηλώνοντας ένα πεδίο ως not null απαγορεύονται οι τιμές null (κενά)).
Για παράδειγμα η εντολή που δημιουργεί τον πίνακα με όνομα Customer με δύο στήλες την Name και την AccountNum είναι η παρακάτω:
Το όνομα πίνακα που προσδιορίζεται σε μία εντολή Create Table πρέπει να είναι μοναδικό μεταξύ των αντικειμένων της SQL που περιέχονται στην ίδια βάση δεδομένων.
Επίσης το όνομα στήλης ενός πίνακα πρέπει να είναι μοναδικό για το συγκεκριμένο πίνακα αλλά μπορεί να είναι το ίδιο με το όνομα μιας στήλης ενός άλλου πίνακα.
Η ιδιότητα αυτή είναι ιδιαίτερα χρήσιμη διότι μπορεί να χρησιμοποιηθεί για να δηλωθεί η συσχέτιση που μπορεί να υπάρχει μεταξύ δύο ή περισσοτέρων πινάκων μιας βάσης δεδομένων.
Η εντολή ALTER TABLE επιτρέπει την προσθήκη νέων στηλών ή τη διαγραφή υπαρχόντων.
Η προσθήκη νέων στηλών γίνεται με τη σύνταξη: ALTER TABLE όνομα_πίνακα ADD COLUMN πεδίο τύπος[(μέγεθος)] Για παράδειγμα η εντολή που προσθέτει μια νέα στήλη στον πίνακα Customer:
Η διαγραφή υπαρχόντων στηλών γίνεται με τη σύνταξη: ALTER TABLE όνομα_πίνακα DROP COLUMN πεδίο Για παράδειγμα η εντολή που αφαιρεί τη στήλη Notes από τον πίνακα Customer.
Τέλος, η εντολή DROP TABLE επιτρέπει τη διαγραφή πινάκων.
Για παράδειγμα η εντολή που θα διαγράψει τον πίνακα Customer
Η πρόσβαση στα στοιχεία ενός πίνακα γίνεται ταχύτερα όταν αυτά οργανωθούν με τη βοήθεια ευρετηρίων.
Ένα ευρετήριο ορίζεται για μια συγκεκριμένη στήλη ή στήλες και επιτρέπει τη γρήγορη πρόσβαση σε γραμμές με βάση τιμές της συγκεκριμένης στήλης.
Ουσιαστικά όταν ορίζουμε έναν ευρετήριο το ΣΔΒΔ υλοποιεί μια δομή δεδομένων (π.χ. ταξινομημένο ή κατακερματισμένο πίνακα ή δένδρο) για γρήγορη πρόσβαση στα αντίστοιχα δεδομένα.
Ευρετήρια δημιουργούνται με την εντολή CREATE INDEX.
Η σύνταξή της είναι η παρακάτω: CREATE [ UNIQUE ] INDEX όνομα_ευρετηρίου ON όνομα_πίνακα (πεδίο [ASC|DESC][, πεδίο [ASC|DESC], ...]) Η λέξη UNIQUE ορίζει πως δε θα επιτρέπονται διπλές εμφανίσεις μιας τιμής για το συγκεκριμένο ευρετήριο.
Οι λέξεις ASC και DESC ορίζουν αύξουσα ή φθίνουσα ταξινόμηση του πίνακα με βάση το ευρετήριο.
Παράδειγμα:
Δημιουργεί το ευρετήριο NameIdx για τη στήλη Name στον πίνακα Customer.
Ένα ευρετήριο μπορεί να διαγραφεί με τη σύνταξη: DROP INDEX όνομα_δείκτη ON όνομα_πίνακα
Εδώ θα χρησιμοποιήσουμε μία απλοποιημένη βάση δεδομένων που διαχειρίζεται παραγγελίες βιβλιοθηκών
ΠΑΡΑΓΓΕΛΙΕΣ (ΑριθμοςΠαραγγελιας, Ημερομηνια, Βιβλιοθηκη)
ΒΙΒΛΙΟ (ΚωδικοςΒιβλιου, Τιτλος, Θεμα, Τιμη)
ΑΝΤΙΤΥΠΑ (ΑριθμοςΠαραγγελιας, ΚωδικοςΒιβλιου, Αντιτυπα)
ΑριθμοςΠαραγγελιας CHAR(4) NOT NULL ,
PRIMARY KEY (ΑριθμοςΠαραγγελιας) );
ΚωδικοςΒιβλιου CHAR(4) NOT NULL ,
PRIMARY KEY (ΚωδικοςΒιβλιου) );
PRIMARY KEY (ΑριθμοςΠαραγγελιας, ΚωδικοςΒιβλιου ) );
Η γλώσσα χειρισμού δεδομένων της SQL (Data Manipulation Language) παρέχει τη δυνατότητα εκτέλεσης των πράξεων ανάκτησης και μεταβολής των περιεχομένων των πινάκων ή των όψεων (views) μιας βάσης δεδομένων.
Στην SQL οι πράξεις αυτές εκτελούνται επί συνόλων γραμμών (δηλαδή ομαδικά) όπως υπαγορεύει η σχεσιακή θεωρία.
Δηλαδή πρόκειται για εντολές επεξεργασίας πινάκων (table-at-a-time processing) σε αντίθεση με την επεξεργασία γραμμών ή εγγραφών (record- at-a-time processing) που γίνεται με τις συμβατικές γλώσσες προγραμματισμού.
Με την παρεμβολή κάποιων μηχανισμών που κατασκευάζονται μέσω της SQL και ονομάζονται οδηγοί (cursors) είναι δυνατή η εκτέλεση των πράξεων ανάκτησης και μεταβολής των πινάκων γραμμή-προς-γραμμή.
Η δυνατότητα αυτή παρέχεται για λόγους συμβατότητας προς τη λογική σχεδιασμού των συμβατικών γλωσσών προγραμματισμού τρίτης γενιάς (C/C++, PASCAL, FORTRAN, BASIC).
Οι εντολές της γλώσσας χειρισμού δεδομένων της SQL είναι: SELECT (ανάκτηση γραμμών πινάκων) INSERT (εισαγωγή γραμμών πινάκων), UPDATE (τροποποίηση γραμμών πινάκων) και DELETE (διαγραφή γραμμών πινάκων).
Η πρώτη απ' αυτές τις εντολές αφορά την ανάκτηση των περιεχομένων των πινάκων ή όψεων και οι τρεις τελευταίες την μεταβολή τους.
Στην SQL, ο χρήστης καθορίζει τα δεδομένα που επιθυμεί να ανακτήσει και η SQL αναλαμβάνει να προσδιορίσει τη διαδρομή που θα ακολουθηθεί για την προσπέλαση τους (μέσω της διαδικασίας της βελτιοποίησης).
Όμως, οι χρήστες θα πρέπει να γνωρίζουν τις στήλες που έχουν χρησιμοποιηθεί για τη δημιουργία των ευρετηρίων, τα ευρετήρια που είναι διαθέσιμα για κάθε πίνακα και τα μήκη των στηλών.
Ο λόγος είναι ότι αυτοί οι παράγοντες είναι μεταξύ εκείνων που λαμβάνονται υπόψη από τον βελτιστοποιητή για την επιλογή της καταλληλότερης διαδρομής προσπέλασης των δεδομένων.
Ο σκοπός της υποβολής ενός ερωτήματος (query) SQL είναι η ανάκτηση δεδομένων από πίνακες.
Η ανάκτηση δεδομένων επιτυγχάνεται με τη χρήση της εντολής SELECT.
Μία εντολή SELECT πρέπει να προσδιορίζει τα ονόματα των επιθυμητών στηλών και τα ονόματα των πινάκων από τους οποίους θα ανακτηθούν οι αντίστοιχες στήλες δεδομένων.
Προαιρετικά, σε μία εντολή SELECT είναι δυνατό να προσδιοριστούν οι επιθυμητές γραμμές των πινάκων (βάσει συνθηκών που αυτές πρέπει να πληρούν) ή/και ο τρόπος παρουσίασης του αποτελέσματος της πράξης ανάκτησης.
Η σύνταξη της βασικής εντολής επιλογής δεδομένων της SQL SELECT < όνομα-στήλης-1, όνομα-στήλης-2,..., όνομα-στήλης-Ν > FROM < όνομα-πίνακα >;
Εναλλακτικά, το κάθε όνομα στήλης μπορεί να περιέχει ένα διακριτικό (qualifier), που είναι ο πίνακας στον οποίο ανήκει.
Έτσι, το < όνομα στήλης > μπορεί να αντικατασταθεί με το <όνομα-πίνακα>.<όνομα στήλης>.
Η δυνατότητα αυτή παρέχεται για όλες τις εντολές και εκφράσεις της SQL.
Η σειρά των στηλών του πίνακα, όπως εμφανίζεται στην εντολή SELECT, αποτελεί και τη σειρά εμφάνισης των στηλών στο αποτέλεσμα.
Ο αστερίσκος ( * ) δηλώνει ότι θα εμφανιστούν όλες οι στήλες ενός πίνακα και η σειρά εμφάνισης τους θα είναι ίδια με τη σειρά ορισμού των στηλών στον πίνακα όταν αυτός δημιουργηθεί με την εντολή CREATE TABLE.
Παραδείγματα χρήσης της εντολής SELECT
Αν επιθυμούμε την ανάκτηση επιλεγμένων μόνο γραμμών ενός πίνακα, τότε οι λογικές συνθήκες που προσδιορίζουν τα χαρακτηριστικά των επιθυμητών γραμμών γράφονται στην πρόταση WHERE (το κατηγόρημα).
Η σύνταξη της αντίστοιχης εντολής είναι: SELECT < όνομα-στήλης-1,..., όνομα-στήλης-Ν > FROM < όνομα-πίνακα >
Οι συνθήκες (τα κριτήρια) αναζήτησης στην πρόταση WHERE είναι εκφράσεις πάνω στα πεδία.
Μία συνθήκη αποτελείται από ένα όνομα πεδίου, έναν τελεστή σύγκρισης και μία έκφραση.
Η πρόταση WHERE της SQL δέχεται πολλούς τελεστές.
Ορισμένοι βασικοί τελεστές είναι οι: · τελεστές σύγκρισης < <= > >= = <> σε λογικές εκφράσεις · λογικοί τελεστές and, or, not που συνδέουν πολλές λογικές συνθήκες · πρόσθετοι τελεστές in, between, like, is null.
H SQL παρέχει τη δυνατότητα χρήσης συνδυασμών αυτών των τελεστών.
Η SQL παρέχει τη δυνατότητα χρησιμοποίησης ορισμένων αριθμητικών τελεστών (arithmetic operators) μέσα σε εντολές χειρισμού δεδομένων.
Οι τελεστές αυτοί είναι: πρόσημο (αν παραληφθεί τότε εννοείται το +) Η σειρά κατά την οποία εκτελούνται οι αντίστοιχες αριθμητικές πράξεις εντός μιας σύνθετης αριθμητικής έκφρασης είναι: πολλαπλασιασμός και διαίρεση, πρόσθεση και αφαίρεση.
Με παρενθέσεις αλλάζει η σειρά.
Παράδειγμα χρήσης αριθμητικού τελεστή σε εντολή SQL.
To ΤΙΜΗ*1.2 ονομάζεται αριθμητική έκφραση επειδή περιέχει αριθμητικό τελεστή.
Τελεστές Σύγκρισης στα κριτήρια Οι τελεστές σύγκρισης της SQL φαίνονται παρακάτω (μικρότερο ή ίσο από) (μεγαλύτερο ή ίσο από) Συγκρίνετε πάντα αριθμούς με αριθμούς, συμβολοσειρές με συμβολοσειρές και ημερομηνίες με ημερομηνίες.
Μην χρησιμοποιείται τον τελεστή != για την ανισότητα στις ερωταποκρίσεις SQL.
Ο σωστός τελεστής της ANSI SQL για τον έλεγχο της ανισότητας είναι ο <>.
Σε μερικές εκδόσεις της SQL (MySQL, Oracle κλπ) μπορείτε να γράψετε την ανισότητα και με τους δύο τρόπους.
Παράδειγμα ανάκτησης δεδομένων που πληρούν μια συνθήκη.
Ζητούνται οι τίτλοι και οι τιμές αγοράς των βιβλίων πληροφορικής που έχουν καταχωρηθεί στον πίνακα ΒΙΒΛΙΟ.
WHERE ΘΕΜΑ = 'Πληροφορική';
Τα εισαγωγικά (μονά ή διπλά) περικλείουν τις συμβολοσειρές που χρησιμοποιούνται σε συγκρίσεις.
Λογικοί Τελεστές AND, OR συνδυασμού πολλών συνθηκών Σε πολλές περιπτώσεις ανάκτησης γραμμών από έναν πίνακα είναι επιθυμητή η εναλλακτική ή αναγκαστική εκπλήρωση περισσοτέρων της μιας συνθηκών.
Οι λογικοί τελεστές που συνδυάζουν πολλές συνθήκες είναι οι γνωστοί AND (σύζευξη), OR (διάζευξη) και NOT (άρνηση).
Η σειρά προτεραιότητας για την εκτέλεση των λογικών πράξεων είναι πρώτα τα NOT έπειτα τα AND και τέλος τα OR.
Με παρενθέσεις αλλάζει αυτή η σειρά.
Ο τελεστής AND υπαγορεύει ότι πρέπει να πληρούνται όλες οι λογικές συνθήκες που συνδέει για να ανακτηθεί μία γραμμή ενός πίνακα.
Έτσι, καθιστά ακόμη πιο περιοριστικό το ερώτημα που διατυπώνεται και συνήθως έχει ως αποτέλεσμα την επιστροφή από την SQL ενός μικρότερου συνόλου γραμμών.
Παράδειγμα χρήσης του τελεστή AND WHERE ΘΕΜΑ = 'Μαθηματικά' AND ΤΙΜΗ < = 10000 Ο τελεστής OR υπαγορεύει ότι πρέπει να πληρείται μία τουλάχιστον από τις λογικές συνθήκες που συνδέει για να ανακτηθεί μία γραμμή ενός πίνακα.
Έτσι, διευρύνει ακόμη περισσότερο το ερώτημα που διατυπώνεται και συνήθως έχει ως αποτέλεσμα την επιστροφή από την SQL ενός μεγαλύτερου συνόλου γραμμών.
Παράδειγμα χρήσης του τελεστή OR
WHERE ΘΕΜΑ = 'Πληροφορική’ OR ΘΕΜΑ = ‘Μαθηματικά’ Παράδειγμα χρήσης συνδυασμού των τελεστών AND και OR.
WHERE ΤΙΜΗ >= 5000 AND (ΘΕΜΑ = 'Πληροφορική’ OR ΘΕΜΑ = ‘Μαθηματικά’);
Πρόσθετοι Τελεστές: in, betweenand, like, is null Ο περιεκτικός τελεστής IN ελέγχει τη συμμετοχή μιας τιμής σε ένα σύνολο τιμών.
Αν μία στήλη της πρότασης WHERE μπορεί να παίρνει πολλές διακριτές τιμές και είναι επιθυμητό να συμπεριληφθεί στη συνθήκη ένα μεγάλο υποσύνολο των τιμών αυτών, τότε το όνομα της στήλης πρέπει να επαναληφθεί πολλές φορές.
Η SQL παρέχει τη δυνατότητα συντόμευσης της συνθήκης με τη χρήση του περιεκτικού τελεστή IN.
Δύο ισοδύναμες εκφράσεις μιας εντολής SQL με ή χωρίς χρήση του τελεστή IN φαίνονται παρακάτω
WHERE ΘΕΜΑ = 'Πληροφορική' OR ΘΕΜΑ = 'Μαθηματικά' OR ΘΕΜΑ = 'Στατιστική';
WHERE ΘΕΜΑ IN ('Πληροφορική' , 'Μαθηματικά' , 'Στατιστική' ) Ο συγκριτικός τελεστής BETWEEN ANDχρησιμοποιείται όπου οι ζητούμενες γραμμές του πίνακα περιέχουν τιμές μιας στήλης που βρίσκονται εντός μιας συγκεκριμένης περιοχής (πεδίο τιμών).
Η περιοχή αυτή μπορεί να είναι περιοχή ημερομηνιών, αριθμών ή χαρακτήρων.
Δύο ισοδύναμες εκφράσεις μιας εντολής SQL με ή χωρίς χρήση του τελεστού BETWEEN φαίνονται παρακάτω
Ο τελεστής σύγκρισης LIKE επιτρέπει τη σύγκριση με συμβολοσειρές (strings).
Χρησιμοποιείται για την ανάκτηση εκείνων των τιμών ενός πεδίου κειμένου που ταιριάζουν μερικά με μια συγκεκριμένη συμβολοσειρά. – που αρχίζουν από ένα γράμμα-που περιέχουν μία φράση ή λέξη κλπ.
Η συμβολοσειρά μπορεί να περιέχει το σύμβολο % (ή το * ) ως υποκατάστατο πολλών αγνώστων χαρακτήρων και το σύμβολο _ (ή το ?) ως υποκατάστατο ακριβώς ενός αγνώστου χαρακτήρα.
Παραδείγματα χρήσης του τελεστή LIKE.
WHERE ΤΙΤΛΟΣ LIKE ‘%Τεχνητή% ' OR ΤΙΤΛΟΣ LIKE '%Δεδομένων’;
Ο τελεστής σύγκρισης IS NULL επιστρέφει αληθές (true) όταν η τιμή στο αντίστοιχο πεδίο είναι κενή.
Είναι πιθανό για τις γραμμές ενός πίνακα να έχουν τιμή NULL (κενή τιμή) σε κάποιο πεδίο.
NULL τιμές εμφανίζονται και στην εξωτερική σύζευξη δύο πινάκων (LEFT JOIN, RIGHT JOIN).
Το αποτέλεσμα σύγκρισης με μια τιμή NULL είναι unknown (ούτε true, ούτε false).
Επίσης το αποτέλεσμα οποιασδήποτε αριθμητικής έκφρασης είναι NULL όταν κάποια τιμή που περιλαμβάνει είναι NULL.
Τότε η πρόταση WHERE βγαίνει false και η σειρά δεν επιλέγεται.
H λέξη κλειδί IS NULL (IS NOT NULL) μπορεί να χρησιμοποιηθεί σε μια συνθήκη για να ελέγξουμε αν μια τιμή είναι null και να ανακτήσουμε την αντίστοιχη σειρά.
Η σύνταξη είναι : Τελεστής άρνησης (not) των: in, betweenand, like, is null Σε μερικές περιπτώσεις η διατύπωση ενός ερωτήματος απλουστεύεται κατά πολύ αν εισαχθεί το αντίθετο μιας συνθήκης.
Τότε μπορεί να χρησιμοποιηθεί ο τελεστής άρνησης NOT με οποιονδήποτε από τους παραπάνω τελεστές.
Ο τελεστής NOT έχει ως αποτέλεσμα την ανάκτηση μόνον εκείνων των γραμμών ενός πίνακα για τις οποίες δεν ικανοποιείται μια συγκεκριμένη συνθήκη.
Ο τελεστής NOT εισάγεται είτε μπροστά από κάθε τελεστή σύγκρισης είτε μπροστά από κάθε συνθήκη σύγκρισης Παρακάτω φαίνονται παραδείγματα χρήσης του τελεστή NOT.
SELECT * FROM ΒΙΒΛΙΟ WHERE ΘΕΜΑ NOT IN ('Πληροφορική');
Βασικό στοιχείο του σχεσιακού μοντέλου είναι η αποθήκευση δεδομένων σε πίνακες που σχετίζονται μεταξύ τους μέσω κοινών πεδίων.
Έτσι για παράδειγμα ένας πίνακας μπορεί να φυλάει τα στοιχεία των πελατών και ένας άλλος τους λογαριασμούς.
Με τον τρόπο αυτό τα στοιχεία ενός πελάτη που έχει πολλούς λογαριασμούς σε μια τράπεζα φυλάσσονται μόνο μια φορά.
Ανάκτηση από δύο τέτοιους πίνακες γίνεται με τον προσδιορισμό τους στην πρόταση FROM μαζί με τη χρήση της κατάλληλης έκφρασης (συνθήκη σύζευξης) που θα ενώσει τους πίνακες στην πρόταση WHERE.
Παράδειγμα:
Είναι πιθανό ορισμένες εγγραφές να έχουν null τιμές, δηλωμένες ως null, για ορισμένα από τα γνωρίσματά τους.
Το null δηλώνει μια άγνωστη τιμή ή τιμή που δεν υπάρχει.
Το αποτέλεσμα οποιασδήποτε αριθμητικής έκφρασης που συμπεριλαμβάνει το null είναι null.
Οι συναθροιστικές συναρτήσεις (avg, max, min, sum, count) απλώς αγνοούν το null.
Στην απαλοιφή διπλότυπων και στην ομαδοποίηση, το null χρησιμοποιείται όπως οποιαδήποτε άλλη τιμή, και δύο null θεωρούνται πως είναι το ίδιο.
Οι συγκρίσεις με null τιμές επιστρέφουν την τιμή unknown (που είναι μία επιπλέον τιμή αληθείας εκτός από τις γνωστές true/false) · Εάν χρησιμοποιούνταν η τιμή false αντί της unknown, τότε not (A < 5) Στη λογική τριών τιμών οι λογικές πράξεις χρησιμοποιώντας την τιμή αληθείας unknown: · Το αποτέλεσμα του κατηγορήματος επιλογή P θεωρείται ως false αν αποτιμάται σε unknown · “P is unknown” αποτιμάται ως true αν το κατηγόρημα P θεωρηθεί ως unknown Πίνακες αληθείας της λογικής τριών τιμών (true – unknown - false)
Είναι εύκολο να τα θυμάστε αν παρατηρήσετε ότι, όπως και στη λογική δύο τιμών (από τις λογικές πύλες), ο εγγενής κανόνας του AND είναι ένα true, και ο εγγενής κανόνας του OR είναι ένα false.
Εάν Α=3, Β=4 και το C είναι null, τότε βρείτε τις τιμές αληθείας των παρακάτω εκφράσεων:
Στα κατηγορήματα της SQL (στις προτάσεις where ή having) επιλέγονται μόνο οι σειρές για τις οποίες βγαίνει true, και αποκλείονται εκείνες στις οποίες βγαίνει false ή unknown.
Εκτός από αριθμητικούς τελεστές οι εντολές χειρισμού δεδομένων της SQL μπορούν να περιέχουν και ορισμένες Συναθροιστικές συναρτήσεις (aggregate functions).
To όρισμα (argument) κάθε Συναθροιστικής συνάρτησης είναι είτε ένα όνομα στήλης είτε μια αριθμητική παράσταση.
Οι Συναθροιστικές συναρτήσεις που υποστηρίζει η SQL είναι: Υπολογίζει τον αριθμητικό μέση τιμή μιας στήλης Α ή μιας αριθμητικής παράστασης.
Ο τύπος δεδομένων της στήλης πρέπει να είναι αριθμός.
Υπολογίζει το πλήθος των γραμμών ενός πίνακα που έχουν επιλεγεί βάσει των συνθηκών της εντολής SELECT ανεξάρτητα από τα περιεχόμενα των στηλών του.
Το αποτέλεσμα είναι ένας ακέραιος.
COUNT ( DISTINCT όνομα-στήλης-1 [,..., όνομα-στήλης-Ν] ).
Υπολογίζει το πλήθος των διαφορετικών τιμών των στηλών των επιλεγμένων γραμμών.
Το αποτέλεσμα είναι ένας ακέραιος.
Επιστρέφει τη μέγιστη τιμή μιας στήλης Α μεταξύ των επιλεγμένων γραμμών.
Ο τύπος δεδομένων της στήλης μπορεί να είναι αριθμοί, κείμενο, ή ημερομηνία ή ώρα.
Επιστρέφει την ελάχιστη τιμή μιας στήλης Α μεταξύ όλων των επιλεγμένων γραμμών.
Ο τύπος δεδομένων της στήλης μπορεί να είναι αριθμοί, κείμενο, ή ημερομηνία ή ώρα.
Υπολογίζει το άθροισμα των τιμών μιας στήλης Α ή αριθμητικής έκφρασης για όλες τις γραμμές που έχουν επιλεγεί.
Ο τύπος δεδομένων πρέπει να είναι αριθμός. παραδείγματα χρήσης συναθροιστικών συναρτήσεων σε εντολές SQL.
SELECT AVG (ΤΙΜΗ*1.2) FROM ΒΙΒΛΙΟ WHERE ΘΕΜΑ = 'Πληροφορική';
Η ταξινόμηση των αποτελεσμάτων γίνεται πάντα τελευταία.
Γίνεται όταν πρέπει να εμφανιστούν οι γραμμές ενός πίνακα που έχουν επιλεγεί από μια εντολή SELECT κατά κάποια συγκεκριμένη σειρά.
Για να εμφανιστούν τα αποτελέσματα κατά αύξουσα ή φθίνουσα σειρά μπορεί να χρησιμοποιηθεί η πρόταση ORDER BY Η σύνταξη της είναι: < όνομα-στήλης > | < ακέραιος-αριθμός > [ASC | DESC] ,... < όνομα-στήλης > | <ακέραιος-αριθμός > [ASC | DESC] είναι το όνομα της στήλης που περιέχει τις τιμές με βάση τις οποίες θα γίνει η ταξινόμηση των γραμμών του πίνακα είναι μια σταθερά που υποδηλώνει τη σχετική θέση των στηλών στην εντολή SELECT, από αριστερά προς τα δεξιά. είναι δεσμευμένες λέξεις της SQL που χρησιμοποιούνται προαιρετικά για να υποδηλώσουν ότι η ταξινόμηση των γραμμών του πίνακα πρέπει να γίνει κατά αύξουσα σειρά (ASC) ή φθίνουσα σειρά (DESC) των τιμών της στήλης.
Όπως φαίνεται από την παραπάνω σύνταξη της φράσης ORDER BY σε μία εντολή SELECT, είναι δυνατό να ταξινομηθούν οι γραμμές ενός πίνακα με βάση περισσότερες από μία στήλες.
Σε αυτήν την περίπτωση οι γραμμές ταξινομούνται πρώτα ως προς την πρώτη στήλη, εντός αυτής της ταξινόμησης κατά τη δεύτερη στήλη κ. ο. κ.
Παραδείγματα χρήσης της φράσης ORDER BY σε εντολές SELECT.
Η πρόταση GROUP BY χρησιμοποιείται συνήθως όταν υπάρχουν μια ή περισσότερες συναθροιστικές συναρτήσεις στη δήλωση SQL.
Τότε, αυτές οι συναθροιστικές συναρτήσεις εφαρμόζονται σε τιμές στήλης ανά ομάδα γραμμών και όχι σε όλες τις τιμές της στήλης.
Έτσι έχουμε μία συγκεντρωτική παρουσίαση δεδομένων.
Η πρόταση GROUP BY έχει ως αποτέλεσμα τη λογική αναδιάταξη των γραμμών που έχουν επιλεγεί (με ή χωρίς συνθήκες) σε ένα ελάχιστο αριθμό ομάδων ή διαμερίσεων έτσι ώστε όλες οι γραμμές κάθε ομάδας να έχουν την ίδια τιμή για τη στήλη ή τις στήλες που χρησιμοποιούνται για την ομαδοποίηση.
Η πρόταση GROUP BY έχει την ακόλουθη σύνταξη: GROUP BY < όνομα-στήλης-1, ... , όνομα-στήλης-Ν > \ Το αποτέλεσμα είναι ένας ομαδοποιημένος πίνακας (grouped table).
Παραδείγματα χρήσης της GROUP BY
Το AS είναι ο τελεστής προσωρινής μετονομασίας (δημιουργεί ψευδώνυμα) των ονομάτων στηλών που εμφανίζονται στην πρόταση SELECT.
Η πρόταση HAVING μπορεί να θεωρηθεί ως μια φράση WHERE αλλά αναφορικά με ομάδες και όχι με γραμμές.
Δηλαδή, η HAVING περιορίζει τις επιζητούμενες ομάδες ακριβώς όπως η WHERE περιορίζει τις επιζητούμενες γραμμές Αν η πρόταση HAVING εμφανιστεί χωρίς την πρόταση GROUP BY (πράγμα σπάνιο) τότε όλες οι γραμμές που έχουν επιλεγεί θεωρούνται ως μια ομάδα.
Επίσης, αν η HAVING εμφανιστεί χωρίς τη φράση GROUP BY τότε όλα τα ονόματα στηλών που εμφανίζονται στην εντολή SELECT πρέπει να είναι ορίσματα συναθροιστικών συναρτήσεων.
Η σύνταξη της πρόταση HAVING είναι: HAVING <συνθήκη > [ AND | OR < συνθήκη > ... ] j Όπως ακριβώς και στην WHERE, στη φράση HAVING μπορούν να χρησιμοποιηθούν πολλαπλές συνθήκες που θα πρέπει να συνδέονται με τους τελεστές AND , OR και NOT.
Παράδειγμα χρήσης της φράσης HAVING που αφορά την ανάκτηση των κωδικών των βιβλίων που περιέχονται σε περισσότερες από μια παραγγελίες.
Η πρόταση having συντάσσεται μετά την group by και περιέχει συνθήκες που περιορίζουν τις γραμμές που επιστρέφονται μετά από μία ομαδοποίηση (group by).
Προστέθηκε στην SQL επειδή η πρόταση where δεν μπορεί να χρησιμοποιηθεί για συγκρίσεις με αποτελέσματα συναθροιστικών συναρτήσεων (π.χ.
COUNT ( * ) > 1) Πρέπει όμως να επαναλάβετε τη συνάρτηση γιατί δεν μπορείτε να χρησιμοποιήσετε το ψευδώνυμο της.
Υποερώτημα ονομάζεται οποιαδήποτε εντολή select που είναι ενσωματωμένη (φωλιασμένη) σε άλλη εντολή select.
Έτσι, είναι δυνατό να κατασκευάζονται και υποερωτήματα άλλων υποερωτημάτων.
Ο αριθμός των υποερωτημάτων υπόκειται στους περιορισμούς του διαθέσιμου συστήματος αλλά και στις απαιτήσεις αποδοτικότητας της βάσης δεδομένων.
Τα υποερωτήματα ονομάζονται και υποεπιλογές (subselects).
Επίσης αν μια εντολή SELECT περιέχει μια άλλη εντολή SELECT τότε η πρώτη ονομάζεται εξωτερική εντολή SELECT (outer SELECT) και η δεύτερη εσωτερική εντολή SELECT (inner SELECT).
Κατ' αντιστοιχία το πρώτο ερώτημα ονομάζεται εξωτερικό ερώτημα (outer query) και το δεύτερο εσωτερικό ερώτημα (inner query).
Τα υποερωτήματα χρησιμοποιούνται σε φράσεις WHERE και HAVING για να επιστρέψουν μια ή περισσότερες τιμές που προσδιορίζουν τη συνθήκη μιας τέτοιας φράσης.
Η γενική σύνταξη των εμφωλιασμένων υποερωτημάτων είναι η
Σαν τελεστές σύγκρισης χρησιμοποιούνται οι < <= > >= = <> Στις περιπτώσεις όπου το εσωτερικό υποερώτημα θα έχει ως αποτέλεσμα την επιστροφή δύο ή περισσοτέρων τιμών χρησιμοποιούνται οι τελεστές IN, NOT IN, SOME, ALL, EXISTS που θα δούμε αργότερα.
Τα συνηθέστερα υποερωτήματα είναι αυτά που έχουν ως αποτέλεσμα μία τιμή συναθροιστικής συνάρτησης MAX, MIN, AVG, SUM, COUNT η οποία χρησιμοποιείται σαν τιμή σύγκρισης για να βρεθούν με το εξωτερικό ερώτημα τα στοιχεία των κατόχων αυτής της τιμής.
Τα εμφωλιασμένα υποερωτήματα χρησιμοποιούνται όταν δεν γνωρίζουμε την τιμή σύγκρισης στο κατηγόρημα σε προτάσεις where ή having.
Ένα παράδειγμα χρήσης υποερωτημάτων που αφορά την ανάκτηση των αριθμών παραγγελιών που περιέχουν τουλάχιστον ένα βιβλίο Πληροφορικής.
WHERE ΒΙΒΛΙΟ.ΘΕΜΑ = 'Πληροφορική' )) Υπολογίζεται πρώτα το εσωτερικό υποερώτημα και κατόπιν το εξωτερικό εφαρμόζοντας σε αυτό το αποτέλεσμα του εσωτερικού ερωτήματος.
Εξαίρεση αποτελεί η περίπτωση των συσχετιζόμενων υποερωτημάτων όπου το εσωτερικό υποερώτημα θα υπολογιστεί για κάθε γραμμή (συστοιχία) του εξωτερικού ερωτήματος.
Στα παραδείγματα παρατηρείται ότι χρησιμοποιούντα προσδιοριστικά (qualifiers) στα ονόματα των στηλών, που είναι τα ονόματα των πινάκων στους οποίους ανήκουν οι στήλες (π.χ.
ΒΙΒΛΙΟ.ΚΩΔΙΚΟΣΒΙΒΛΙΟΥ και ΑΝΤΙΤΥΠΑ.ΚΩΔΙΚΟΣΒΙΒΛΙΟΥ).
Αυτή η σύνταξη χρησιμοποιείτε συχνά σε διατυπώσεις υποερωτημάτων για την αποφυγή ασαφειών αναφορικά με τους πίνακες στους οποίους ανήκουν οι στήλες
Συσχετιζόμενο υποερώτημα ονομάζεται εκείνο του οποίου η τιμή εξαρτάται από κάποια μεταβλητή που παίρνει την τιμή της από το εξωτερικό ερώτημα.
Έτσι ένα τέτοιο υποερώτημα πρέπει να εκτελείται κατ' επανάληψη (μία φορά για κάθε τιμή της μεταβλητής), αντί για μία μόνο φορά.
Ένα παράδειγμα συσχετισμένου υποερωτήματος που αφορά την ανάκτηση των βιβλιοθηκών έχουν παραγγείλει το βιβλίο με κωδικό Β109.
Φαίνεται από το παράδειγμα ότι το εσωτερικό ερώτημα δεν μπορεί εκτελεστεί μια μόνο φορά διότι εξαρτάται από μια μεταβλητή (την ΠΑΡΑΓΓΕΛΙΕΣ.ΑΡΙΘΜΟΣΠΑΡΑΓΓΕΛΙΑΣ).
Η τιμή της μεταβλητής αυτής αλλάζει καθώς το σύστημα εξετάζει διαφορετικές γραμμές του πίνακα ΠΑΡΑΓΓΕΛΙΕΣ ο οποίος εμφανίζεται στο εξωτερικό ερώτημα.
Ετσι, εννοιολογικά η διαδικασία εκτέλεσης του ερωτήματος ακολουθεί τα ακόλουθα βήματα: α) Το σύστημα εξετάζει κάποια γραμμή του πίνακα ΠΑΡΑΓΓΕΛΙΕΣ, έστω τη γραμμή Π107.
Έτσι, η μεταβλητή ΠΑΡΑΓΓΕΛΙΕΣ.ΑΡΙΘΜΟΣΠΑΡΑΓΓΕΛΙΑΣ παίρνει την τιμή Π107 οπότε το σύστημα εκτελεί το υποερώτημα και επιστρέφεται το σύνολο (Β239, Β226).
Τώρα, το σύστημα μπορεί να ολοκληρώσει την επεξεργασία του για τη γραμμή Π107.
Επιλέγει την τιμή της στήλης ΒΙΒΛΙΟΘΗΚΗ για τη γραμμή Π107, δηλαδή την ΑΧ, τότε και μόνον τότε αν ο κωδικός βιβλίου Β109 περιέχεται σ' αυτό το σύνολο (κάτι που δεν ισχύει). β) Κατόπιν το σύστημα συνεχίζει επαναλαμβάνοντας την ίδια διαδικασία για άλλη γραμμή παραγγελίας μέχρις ότου εξεταστούν όλες οι γραμμές του πίνακα ΠΑΡΑΓΓΕΛΙΕΣ.
Κατ' αυτόν τον τρόπο, θα επιστραφούν τελικά οι τιμές ΑΧ (από τη γραμμή Π089) και ΝΡ (από τη γραμμή Π137) της στήλης ΒΙΒΛΙΟΘΗΚΗ του πίνακα ΠΑΡΑΓΓΕΛΙΕΣ.
Τα Ποσοτικοποιημένα κατηγορήματα (quantified predicates) που μπορούν να χρησιμοποιηθούν σε υποερωτήματα είναι τα ANY, ALL, EXISTS Τα ANY, ALL, προηγούνται ενός υποερωτήματος και χρησιμοποιούνται όταν το υποερώτημα είναι πιθανό να έχει ώς αποτέλεσμα την επιστροφή δύο ή περισσοτέρων τιμών.
Το κατηγόρημα ANY καθορίζει ότι μια γραμμή θα επιλεγεί από το εξωτερικό ερώτημα αν η σύγκριση είναι αληθής για μία τουλάχιστον (κάποια) από τις τιμές που επιστρέφονται από το υποερωτημα.
Αντίθετα, το κατηγόρημα ALL καθορίζει ότι μια γραμμή θα επιλεγεί από το εξωτερικό ερώτημα αν η σύγκριση είναι αληθής για όλες (κάθε μία από) τις τιμές που επιστρέφονται από το υποερωτημα.
Παρακάτω φαίνεται ένα παράδειγμα χρήσης του ALL που αφορά την ανάκτηση των αριθμών των παραγγελιών που περιέχουν τουλάχιστον ένα βιβλίο σε αριθμό αντιτύπων μεγαλύτερο από κάθε αριθμό αντιτύπων στον οποίο παραγγέλλονται βιβλία από την παραγγελία Π137.
Το κατηγόρημα EXISTS (NOT EXISTS) χρησιμοποιείται για να ελέγχεται η ύπαρξη κάποιας τιμής ή συνθήκης.
Επιστρέφει αληθές (true) όταν το υποερώτημα δεν είναι κενό.
Συχνά, το EXISTS (ή NOT EXISTS) χρησιμοποιείται με ένα συσχετισμένο υποερωτημα.
Το παρακάτω παράδειγμα χρήσης του EXISTS. αφορά την ανάκτηση των τίτλων βιβλίων που περιέχονται σε μία τουλάχιστον παραγγελία (οι κωδικοί τους υπάρχουν και στους δύο πίνακες).
Το παρακάτω παράδειγμα χρήσης του NOT EXISTS. αφορά την ανάκτηση των τίτλων βιβλίων που δεν περιέχονται σε καμία παραγγελία. (οι κωδικοί τους υπάρχουν στον πίνακα ΒΙΒΛΙΟ αλλά δεν υπάρχουν στον πίνακα ΑΝΤΙΤΥΠΑ των παραγγελιών).
Ψευδώνυμο ή μεταβλητή σχέσης ονομάζεται η απόδοση ενός πίνακα που εμφανίζεται σε μια δήλωση SQL με άλλο όνομα.
Το ψευδώνυμο ορίζεται στην πρόταση FROM κατά την ακόλουθη σύνταξη: FROM < όνομα πίνακα > < ψευδώνυμο > ι Ένα ψευδώνυμο εμφανίζεται μετά το όνομα του πίνακα χωρίς την παρεμβολή κόμματος.
Τα ψευδώνυμα ονομάτων πινάκων στην πρόταση FROM ονομάζονται και μεταβλητές σχέσης ή μεταβλητές εγγραφών.
Τα ψευδώνυμα χρησιμοποιούνται στις διατυπώσεις ερωτημάτων (ή υποερωτημάτων) κυρίως για τρεις λόγους:
για την αναπαράσταση εικονικών αντιγράφων του ίδιου πίνακα σε ένα ερώτημα ώστε να είναι δυνατή η εκτέλεση του ερωτήματος (υποχρεωτική χρήση που επιβάλλεται από το είδος του ερωτήματος).
Το παρακάτω παράδειγμα αφορά την ανάκτηση όλων των ζευγών από κωδικούς βιβλίων με ίδιο θέμα και με την πρώτη τιμή του κάθε ζεύγους μικρότερη από τη δεύτερη
Τα ψευδώνυμα που χρησιμοποιούνται για τον πίνακα ΒΙΒΛΙΟ είναι τα FIRST και SECOND.
Η λογική αυτού του ερωτήματος είναι: Πρέπει να εξεταστούν όλα τα δυνατά ζεύγη των γραμμών των βιβλίων, μια από το πρώτο αντίγραφο του ΒΙΒΛΙΟ και μια από το δεύτερο, και να ανακτηθούν εκείνα που αντιστοιχούν σε βιβλία με το ίδιο θέμα (π.χ. μαθηματικά) και με την πρώτη τιμή μικρότερη από τη δεύτερη.
για την αναπαράσταση εικονικών αντιγράφων του ίδιου πίνακα με συσχετιζόμενο υποερώτημα ώστε να αποδοθεί χωρίς ασάφειες το ερώτημα (χρήση για την καλύτερη διατύπωση του ερωτήματος).
Το παρακάτω παράδειγμα αφορά την ανάκτηση εκείνων των βιβλίων των οποίων η αξία είναι μεγαλύτερη από τη μέση αξία των βιβλίων που έχουν το ίδιο θέμα.
Εδώ χρησιμοποιούνται τα ψευδώνυμα Β1 και Β2 του πίνακα ΒΙΒΛΙΟ.
για την απόδοση ονομάτων μεγάλου μήκους (προαιρετική χρήση για διευκόλυνση της διατύπωσης του ερωτήματος).
Προσθήκη δεδομένων σε έναν πίνακα γίνεται με την εντολή INSERT INTO σύμφωνα με τη γενική σύνταξη: INSERT INTO όνομα_πίνακα [(πεδίο1[, πεδίο2[, ...]])] VALUES (τιμή1[, τιμή2[, ...]) Υπάρχουν πολλές περιπτώσεις όπως οι (α) την εισαγωγή μίας εγγραφής σε έναν πίνακα προσδιορίζουμε την εγγραφή όπως: INSERT INTO όνομα_πίνακα VALUES (value1, value2,....) ή INSERT INTO όνομα_πίνακα (column1, column2,...) VALUES (value1, value2,....) (β) Για την μαζική εισαγωγή πολλών εγγραφών γράφουμε το ερώτημα SQL που το αποτέλεσμα του θα εισάγεται.
INSERT INTO table_name (column1, column2,...) SELECT-FROM-WHERE ή Το script εισαγωγής δεδομένων στους πίνακες ΒΙΒΛΙΟ, ΠΑΡΑΓΓΕΛΙΕΣ, ΑΝΤΙΤΥΠΑ
Αν δεν είναι γνωστή η τιμή ενός πεδίου π.χ. η τιμή ενός βιβλίου και πρέπει να εισαχθεί η τιμή NULL (κενό) τότε χρησιμοποιείται η σύνταξη Αν θέλετε να εισάγετε τα δεδομένα με διαφορετική σειρά εισαγωγής τότε χρησιμοποιήστε τη σύνταξη INSERT INTO ΒΙΒΛΙΟ(Τιτλος, ΚωδικοςΒιβλιου, Θεμα, Τιμη)
Αν ο τύπος ενός πεδίου είναι αυτόματη αρίθμηση π.χ. ο κωδικός Βιβλίου τότε δεν χρειάζεται εισαγωγή τιμής για αυτό το πεδίο και η αντίστοιχη σύνταξη παραβλέπει την εισαγωγή στοιχείων στο πεδίο αυτό INSERT INTO ΒΙΒΛΙΟ(Τιτλος, Θεμα, Τιμη)
Αν χρειάζεται μαζική εισαγωγή δεδομένων από έναν πίνακα σε έναν άλλον, για παράδειγμα από τον πίνακα ΒΙΒΛΙΟ(ΚωδικοςΒιβλιου, Τιτλος, Θεμα, Τιμη) σε έναν άλλο πίνακα που υπάρχει ήδη στη βάση δεδομένων, για παράδειγμα στον υποθετικό πίνακα ΒΙΒΛΙΑΠΛΗΡΟΦΟΡΙΚΗΣ(ΚωδικοςΒιβλιου, Τιτλος, Τιμη) τότε χρησιμοποιείται η σύνταξη INSERT INTO ΒΙΒΛΙΑΠΛΗΡΟΦΟΡΙΚΗΣ (ΚωδικοςΒιβλιου, Τιτλος, Τιμη) SELECT ΚωδικοςΒιβλιου, Τιτλος, Τιμη WHERE ΘΕΜΑ = ‘Πληροφορική’
Αλλαγή σε στοιχεία γίνεται με την εντολή UPDATE σύμφωνα με τη σύνταξη: UPDATE όνομα_πίνακα SET πεδίο = νέα_τιμή WHERE κριτήρια;
Αν ένα πεδίο είναι τύπου αυτόματης αρίθμησης τότε δεν δέχεται ενημέρωση, δηλαδή δεν γίνεται να αλλάξει.
Δεν μπορούμε να ενημερώσουμε, δηλαδή να αλλάξουμε μία τιμή ενός πρωτεύοντος κλειδιού σε έναν πίνακα, εάν αυτό έχει συστετιζόμενες εγγραφές σε άλλον πίνακα και υπάρχουν οι περιορισμοί ακεραιότητας αναφορών.
Αν για παράδειγμα ένα πεδίο, το Α1, είναι πρωτεύον κλειδί στον πίνακα Α και ξένο κλειδί σε έναν άλλον πίνακα Β και υπάρχουν περιορισμοί αναφορικής ακεραιότητας των τιμών των ξένων κλειδιών, δηλαδή έχουμε δηλώσει κατά την δημιουργία του πίνακα Β τον περιορισμό foreign key(Α1) references Α(Α1) , τότε για να μπορούμε να αλλάξουμε κάποια τιμή του στον πίνακα Α θα πρέπει να υπάρχει στον περιορισμό αυτό η πρόταση on update cascade.
Κατά την διαγραφή γραμμών μπορούμε να σβήσουμε μόνο ολόκληρες εγγραφές και όχι συγκεκριμένα πεδία (για το κάθε πεδίο ξεχωριστά απλώς το θέτουμε με την εντολή update ίσο με null) Διαγραφή γραμμών από έναν πίνακα γίνεται με την εντολή DELETE με τη σύνταξη: DELETE FROM όνομα_πίνακα WHERE κριτήρια Σβήνει όλες τις εγγραφές του πίνακα για τις οποίες ισχύει το κατηγόρημα της πρότασης where.
Προσοχή γιατί όταν λείπει η πρόταση where σβήνονται όλες οι εγγραφές ενός πίνακα.
Κατά την διαγραφή απαιτείται μεγάλη προσοχή γιατί διαγράφονται ολόκληρες οι εγγραφές και δεν γίνεται εύκολα επαναφορά Η διαγραφή εξαρτάται και από τους αναφορικούς περιορισμούς των ξένων κλειδιών που έχουν οριστεί κατά την δημιουργία της βάσης δεδομένων.
Συνήθως μία βάση δεδομένων δεν επιτρέπει να διαγράψουμε μία εγγραφή εάν αυτή έχει συσχετιζόμενες εγγραφές σε άλλους πίνακες και αυτό γίνεται για λόγους ακεραιότητας των δεδομένων.
Πρέπει πρώτα να διαγραφούν οι συσχετιζόμενες εγγραφές.
Για παράδειγμα δεν θα μπορούμε να διαγράψουμε την παραγγελία (‘Π107’,‘28/11/2002’,‘ΑΧ’) με την εντολή επειδή υπάρχουν τα συσχετιζόμενα αντίτυπα παραγγελίας, τα (‘Π107’, ‘Β239’, 2) και (‘Π107’, ‘Β226’, 1).
Πρέπει πρώτα να διαγράψουμε αυτά τα δύο.
Έστω το παράδειγμα βάσης δεδομένων για παραγγελίες βιβλιοθηκών
Να βρεθούν τα Βιβλία Πληροφορικής ή Φυσικής με τιμή μεγαλύτερη από 45.
Να βρεθούν από τον Πίνακα ΠΑΡΑΓΓΕΛΙΕΣ τα Ονόματα των Βιβλιοθηκών που δεν αρχίζουν από ‘Α’.
Να εμφανίζονται από τον Πίνακα ΒΙΒΛΙΟ οι Τιμές των Βιβλίων αυξημένες κατά 20% και να επιστρέφει τα Βιβλία Πληροφορικής με Τιμή μεγαλύτερη από 50.
Να βρεθεί από τον Πίνακα ΑΝΤΙΤΥΠΑ το Άθροισμα του Αριθμού Αντιτύπων της Παραγγελίας ‘Π107’.
Να βρεθεί από τον Πίνακα ΑΝΤΙΤΥΠΑ η μέγιστη τιμή του Αριθμού Αντιτύπων ανά Κωδικό Βιβλίου εκτός από αυτά της Παραγγελίας ‘Π107’.
Να βρεθούν οι Αριθμοί Παραγγελιών που περιέχουν τουλάχιστον ένα Βιβλίο ‘Πληροφορικής’.
Εναλλακτικά μπορεί να εξαχθεί από τη σύζευξη των δύο πινάκων
Να βρεθούν οι Βιβλιοθήκες που δεν έχουν παραγγείλει το Βιβλίο με Κωδικό ‘Β109’.
Να βρεθούν οι τίτλοι των Βιβλίων που περιέχονται σε μία τουλάχιστον Παραγγελία.
Να βρεθούν οι τίτλοι των Βιβλίων που δεν περιέχονται σε καμία Παραγγελία.
Να αυξηθούν οι τιμές των βιβλίων κατά 10%.
Να διαγράφει το Βιβλίο με Κωδικό ‘Β134’
Να δημιουργηθεί ένα νέο αντίγραφο πίνακα από τον πίνακα ΒΙΒΛΙΟ δίχως τη στήλη των Κωδικών Βιβλίων με ταξινόμηση πρώτα ανά ΘΕΜΑ και έπειτα ανά ΤΙΤΛΟ
Αρκετά χρήσιμο ερώτημα.
Σε αντίθεση με την SQL που στη σύνταξη της θυμίζει περισσότερο τις συμβατικές γλώσσες προγραμματισμού, η QBE είναι βασισμένη σε μία εντελώς διαφορετική φιλοσοφία.
Η φιλοσοφία της QBE είναι να είναι απλή και φιλική προς τους χρήστες και να τους δίνει τη δυνατότητα να υποβάλλουν τα ερωτήματα με τρόπο που προσεγγίζει τους πίνακες αποτελεσμάτων που γνωρίζουν.
Το όνομα QBE σημαίνει Query By Example και η γλώσσα ερωτήσεων στηρίζεται στον σχεσιακό λογισμό πεδίων (relational calculus).
Οι ερωτήσεις δίνονται υπό μορφή παραδειγμάτων με δισδιάστατη σύνταξη.
Η QBE αναπτύχθηκε από την IBM ως εναλλακτικός τρόπος υποβολής ερωτήσεων στο σύστημα DB2.
Υπάρχουν αρκετές διαφορές στον τρόπο που χρησιμοποιείται η QBE από σύστημα σε σύστημα.
Θα δούμε έτσι μόνο τις βασικές αρχές της, όπως αρχικά προσδιορίστηκαν στην πρώτη έκδοση της γλώσσας.
Στην QBE χρησιμοποιούνται πίνακες ερωτήσεων για να υποβληθεί η ερώτηση δίνοντας ένα παράδειγμα για το πως θέλουμε να είναι η απάντηση, δηλαδή τα ερωτήματα μοιάζουν με πίνακες.
Η απάντηση δίνεται πάλι σε πίνακες απάντησης που είναι ίδιοι με τους πίνακες ερωτήσεων.
Έστω ότι ο χρήστης ήθελε να υποβάλλει μία ερώτηση στον πίνακα ΦΟΙΤΗΤΕΣ.
Τότε το Σύστημα Διαχείρισης Βάσεων Δεδομένων θα του εμφάνιζε ένα πίνακα ερώτησης της μορφής:
Εστω λοιπόν ότι θέλουμε να δούμε τα ονοματεπώνυμα και τα πατρώνυμα όλων των φοιτητών.
Ο χρήστης στον παραπάνω πίνακα έχει δώσει ένα παράδειγμα μιας απάντησης στην μορφή που θέλει.
Να εμφανιστούν δηλαδή οι στήλες ΟΝΟΜΑ ,ΕΠΩΝΥΜΟ, ΠΑΤΡΩΝΥΜΟ από τον πίνακα ΦΟΙΤΗΤΕΣ.
Σε κάποιες εκδόσεις της QBE, για να εκτυπωθεί μία στήλη χρειαζόταν το πρόθεμα «Ρ.» πριν από το παράδειγμα.
Μπορούν να δοθούν περιορισμοί στην εκτύπωση των αποτελεσμάτων δηλαδή να ορίστούν συνθήκες στη γλώσσα ερωτήσεων QBE.
Όπως και στην πρόταση WHERE στην SQL.
Εκεί μία συνθήκη που ακολουθούσε το WHERE και προσδιόριζε ποιές εγγραφές θα εμφανισθούν.
Στην QBE οι συνθήκες ορίζονται με παρόμοιο τρόπο μόνο που όλα γίνονται με παράδειγμα στον πίνακα ερώτησης.
Για παράδειγμα να εμφανιστούν τα ονοματεπώνυμα των φοιτητών που γεννήθηκαν μετά την 20 Αυγούστου 1985.
Ο πίνακας ερώτησης στην QBE είναι:
Δίχως το «Ρ.» πριν από την ημερομηνία γέννησης θα εμφανιστεί μόνο το ονοματεπώνυμο.
Στις συνθήκες της γλώσσας ερωτήσεων ερωτήσεων QBE μπορούμε να χρησιμοποιήσουμε όλους τους τελεστές που χρησιμοποιούσαμε και στην SQL, δηλαδή τους αριθμητικούς τελεστές, τους τελεστές σύγκρισης >, <, =, >=, <= και <> , καθώς και τους τελεστές IN, BETWEEN AND, LIKE, IS NULL Οι συνθήκες που βρίσκονται στην ίδια γραμμή ενώνονται με τον τελεστή AND
Οι συνθήκες σε διαφορετικές γραμμές ενώνονται με τον τελεστή OR.
Στα περισσότερα Συστήματα Διαχείρισης Βάσεων Δεδομένων που χρησιμοποιούν σήμερα QBE υπάρχει κάποιο γραφικό περιβάλλον για τη διευκόλυνση των χρηστών.
Έτσι ονομάζεται Graphical QBE.
Με τη χρήση τέτοιου περιβάλλοντος ο χρήσης μπορεί πολύ εύκολα να υλοποιήσει εντολές ερωτήσεων σε QBE.
Η Microsoft Access είναι ένα σύστημα διαχείρισης σχεσιακών βάσεων δεδομένων που συνδυάζει τη μηχανή σχεσιακών βάσεων Jet με ένα γραφικό interface και εργαλεία τα οποία επιτρέπουν τη γρήγορη ανάπτυξη εφαρμογών από το χρήστη.
Από το παράθυρο της βάσης δεδομένων μπορείτε να δημιουργείτε, τροποποιείτε και εμφανίζετε οποιονδήποτε από τους έξι τύπους αντικειμένων όπως περιγράφονται παρακάτω:
Τα δεδομένα απεικονίζονται σε δισδιάστατους πίνακες (σχέσεις) με τις στήλες να αντιστοιχούν στα πεδία και τις γραμμές στις εγγραφές.
Εξάγει δεδομένα από τον πίνακα βασιζόμενο σε κριτήρια τα οποία παρέχει ο χρήστης.
Τα ερωτήματα επιτρέπουν στον χρήστη να βλέπει πεδία από περισσότερους του ενός πίνακες.
Εμφανίζει δεδομένα από ένα πίνακα ή ερώτημα, χρησιμοποιώντας, μία καθοριζόμενη από το χρήστη ειδική μορφή.
Οι φόρμες δίνουν στους χρήστες την δυνατότητα να εμφανίζουν, να καταχωρούν, να επεξεργάζονται και να εκτυπώνουν τα δεδομένα.
Οι φόρμες μπορούν να χρησιμοποιούνται για την εμφάνιση δεδομένων από περισσότερους του ενός πίνακες ή ερωτήματα, και μπορούν να σχεδιάζονται ώστε να δείχνουν πανομοιότυπες με τις έντυπες φόρμες.
Εμφανίζει και εκτυπώνει δεδομένα από ένα πίνακα ή ερώτημα, χρησιμοποιώντας, μία καθοριζόμενη από το χρήστη ειδική μορφή.
Δεν μπορείτε να επεξεργαστείτε τα δεδομένα που εμφανίζει μια αναφορά.
Οι αναφορές μπορούν να περιέχουν δεδομένα από περισσότερους του ενός πίνακες ή ερωτήματα, καθώς επίσης και υπολογιζόμενα πεδία τα οποία βασίζονται σε δεδομένα που περιέχονται στους πίνακες.
Αυτοματοποιεί κοινές ενέργειες βάσεων δεδομένων, εκτελώντας μία ομάδα βημάτων τα οποία καθορίζει ο χρήστης.
Αυτοματοποιεί πολύπλοκες λειτουργίες τις οποίες δεν μπορούν να εκτελέσουν οι μακροεντολές.
Οι λειτουργικές μονάδες είναι γραμμένες με την γλώσσα προγραμματισμού Visual Basic.
Μία βάση δεδομένων της Access είναι ένα αρχείο με επέκταση “.mdb” το οποίο μπορεί να αποθηκευτεί σε οποιοδήποτε κατάλογο στον σκληρό δίσκο.
Το μέγιστο μέγεθος μίας βάσης δεδομένων της Access είναι 2 gigabytes, ενώ το μέγιστο πλήθος αντικειμένων που μπορεί να έχει είναι 32.768.
Δεν ανοίγετε ποτέ μία βάση δεδομένων όπως κάνετε με ένα αρχείο.
Δεν μπορείτε να τη φορτώσετε στην μνήμη RAM.
Απλά κάνετε μία σύνδεση με τη βάση (μέσω ενός driver).
Στην Access μπορείτε να το συμπεράνετε αυτό από τρία βασικά σημεία: α) κατά τη δημιουργία μίας νέας βάσης σας ζητά πρώτα να την αποθηκεύσετε, β) δεν υπάρχει επιλογή αποθήκευσης της βάσης με άλλο όνομα, και γ) από το προσωρινό αρχείο κλειδώματος εγγραφών (αυτό με κατάληξη .ldb) που δημιουργείται όταν ανοίγει μία σύνδεση με τη βάση.
Οι πίνακες μίας βάσης δεδομένων αποτελούν τα κυριότερα αντικείμενά της.
Το μέγιστο μέγεθος χωρητικότητας που καταλαμβάνει ένας πίνακας είναι 2 gigabytes και το όνομα του μπορεί να έχει το πολύ 64 χαρακτήρες μήκος.
Σε μία βάση Access μπορούν να είναι ανοιχτοί την ίδια χρονική περίοδο μέχρι 2048 πίνακες.
Ο μέγιστος αριθμός πεδίων ενός πίνακα είναι 255 και των ευρετηρίων του 32.
Το μέγιστο πλήθος χαρακτήρων του ονόματος του πεδίου είναι 64 και το μέγιστο πλήθος σε χαρακτήρες των εγγραφών του είναι 2000.
Η σχεσιακή μηχανή της Ms Access είναι η Microsoft Jet (Joined Engine Technology) Database Engine και περιέχεται σε ένα μόνο driver (MSJT4032.DLL).
Η κύρια μορφή αρχείων της Jet engine είναι τα αρχεία με κατάληξη .mdb καθώς αυτά είναι της MS Access.
Η Jet υποστηρίζει όμως ένα πλήθος εξωτερικών διαφορετικών αρχείων και πηγών δεδομένων.
Μέσω της Jet μπορείτε να προσπελάσετε τρεις κατηγορίες πηγών δεδομένων: · εγγενή αρχεία MDB της MS Access · Αρχεία τρίτων κατασκευαστών dBASE, Btrieve, Paradox, και FoxPro · πηγές δεδομένων ODBC για πρόσβαση σε SQL Server, Sybase, Oracle κ.α.
Μέσω της Jet μπορείτε να κάνετε λήψη εξωτερικών δεδομένων ή απλή σύνδεση σε αυτές τις πηγές για να πάρετε ή να αλλάξετε τα δεδομένα τους.
Είναι δυνατή επίσης η ταυτόχρονη εκτέλεση δηλώσεων SQL σε ετερογενείς πηγές δεδομένων και αρχεία.
Παρακάτω παρουσιάζονται μερικά παραδείγματα από τον SQL editor της Access: Queries σε άλλες βάσεις δεδομένων της Access FROM [C:\Documents and Settings\JOHN\Desktop\ΒΑΣΕΙΣ\CustomersExample.mdb].Customers;
Queries σε βάσεις δεδομένων DBASE
Queries σε βάσεις δεδομένων Paradox4
Queries σε βάσεις MySQL μέσω πηγής δεδομένων ODBC με όνομα DSN ‘MySqlCustomers’
Queries σε βάσεις δεδομένων MySQL με DSNLess πηγή δεδομένων ODBC (δίχως να δημιουργήσουμε DSN χρησιμοποιούμε το default ‘MyODBCsample’, απλά πρέπει να ορίσουμε το DATABASE, το UserID και το Password)
Για κείμενο μέχρι 255 χαρακτήρες, για αριθμούς: Byte = από 0 έως 255, Integer =από –32768 έως 32767,Πως θα εμφανίζονται τα δεδομένα αφού καταχωρηθούν, Σύμφωνα με ποιας μορφής πρότυπο θα εισάγονται τα δεδομένα Η επικεφαλίδα.
Αν δε δώσουμε τιμή έχει την ονομασία του πεδίου Αυτόματη εισαγωγή τιμής στο πεδίο πριν την καταχώρηση στοιχείων από το χρήστη Καθορισμός πεδίου ορισμού του πεδίου π.χ.
Between 0 And 2000 Το μήνυμα λάθους που θα εμφανίζεται όταν η τιμή είναι εκτός πεδίου ορισμού Αν το πεδίο μπορεί να αφήνεται κενό Αν η τιμή του πεδίου μπορεί να είναι μηδενικού μήκους Ορισμός ευρετηρίου (index) και ανοχή (ή όχι) διπλοεγγραφών (διπλότυπα) Σύμπτυξη του πεδίου σύμφωνα με τους κανόνες του Unicode
Κατά τη σχεδίαση μιας φόρμας διακρίνουμε ορισμένες περιοχές σχεδίασης:
Τίτλους, ημερομηνίες, πλήκτρα εντολών στο πάνω μέρος της 1ης σελίδας Χρήση για επικεφαλίδες στηλών στο πάνω μέρος κάθε σελίδας Όσες εγγραφές χωρούν στη σελίδα Αριθμοί σελίδων, ημερομηνίες στο κάτω μέρος κάθε σελίδας Για σύνολά, μέσες τιμές κλπ μία φορά στο τέλος
Κατά τη σχεδίαση μιας έκθεσης διακρίνουμε ορισμένες περιοχές σχεδίασης:
Στην αρχή μιας ομαδοποίησης εγγραφών (μέχρι 10 επίπεδα).
Χρήση: στην εμφάνιση του πεδίου σύμφωνα με το οποίο γίνεται η ομαδοποίηση
Στο τέλος μιας ομαδοποίησης εγγραφών.
Χρήση: στην εμφάνιση αθροίσματος ή μέσου όρου των τιμών που ομαδοποιούνται
Μοναδικός αύξων (προσαυξανόμενος κατά 1) που καταχωρείται αυτόματα κατά την προσθήκη μιας εγγραφής. 2 byte ανά χαρακτήρα Κανένας έως 255 χαρακτήρες.
Κείμενο ή συνδυασμός κειμένου και αριθμών, όπως διευθύνσεις.
Επίσης αριθμοί που δεν απαιτούν υπολογισμούς, όπως αριθμοί τηλεφώνων, κωδικοί ανταλλακτικών ή ταχυδρομικοί κωδικοί.
Τιμές Yes και No.
Πεδία που περιέχουν μόνο μία ή δύο τιμές, όπως Ναι/Όχι, Αληθές/Ψευδές,
Ένας ακέραιος αριθμός μεταξύ 0 και 255.
Ένας κλιμακωτός αριθμός μεταξύ Νομισματικές τιμές.
Ακρίβεια 15 ψηφίων αριστερά της υποδιαστολής και 4 ψηφίων δεξιά της υποδιαστολής.
Μια τιμή ημερομηνίας ή ώρας μεταξύ των ετών 100 και 9999.
Ημερομηνία και ώρα.
Μια τιμή κινητής υποδιαστολής απλής ακρίβειας που παίρνει τιμή από – 3.402823E38 έως – 1.401298E-45 για τις αρνητικές τιμές, από 1.401298E-45 έως 3.402823E38 για τις θετικές τιμές, και 0.
Αριθμητικά δεδομένα που χρησιμοποιούνται σε μαθηματικούς υπολογισμούς
Μια τιμή κινητής υποδιαστολής διπλής ακρίβειας που παίρνει τιμή από – 1.79769313486232E308 έως – 4.94065645841247E-324 για τις αρνητικές τιμές, από 4.94065645841247E-324 έως 1.79769313486232E308 για τις θετικές τιμές, και 0.
Ένας ακέραιος αριθμός μικρού μήκους μεταξύ – 32,768 και 32,767.
Αριθμός (ακέραιος μεγάλου μήκους)
Ένας ακέραιος αριθμός μεγάλου μήκους μεταξύ – 2,147,483,648 και 2,147,483,647.
Ένας ακριβής αριθμητικός τύπος δεδομένων που περιέχει τιμές από 10^28 - 1 έως - 10^28 - 1.
Μπορείτε να προσδιορίσετε τόσο την ακρίβεια (1 - 28) όσο και την κλίμακα (0 - καθορισμένη ακρίβεια).
Η προεπιλεγμένη ακρίβεια και κλίμακα είναι 18 και 0, αντιστοίχως.
Επίμηκες κείμενο και αριθμοί, όπως σημειώσεις ή περιγραφές.
Μέχρι 1 gigabyte το ανώτερο.
Χρησιμοποιείται για αντικείμενα OLE.
Αντικείμενα (όπως έγγραφα, λογιστικά φύλλα, εικόνες, ήχοι ή άλλα ψηφιακά δεδομένα),
Η σχεσιακή μηχανή της Ms Access είναι η Microsoft JET (Joined Engine Technology) Database Engine και περιέχεται στον driver MSJT4032.DLL που είναι εγκατεστημένος στον υπολογιστή σας.
Η σχεσιακή μηχανή του SQL Server είναι υπηρεσία συστήματος και αποτελείται από πολλές υπομονάδες για την διαχείριση των βάσεων δεδομένων.
Ο Microsoft SQL Server Ο Microsoft SQL Server είναι ένα ολοκληρωμένο σύστημα βάσεων δεδομένων και ανάλυσης για συστήματα επαγγελματικών βάσεων δεδομένων, ηλεκτρονικού εμπορίου και αποθήκης δεδομένων με δυνατότητα κλιμάκωσης.
Δημιουργήθηκε με σύμπραξη της Microsoft και της SYBASE.
Ο SQL Enterprise Manager αποτελεί το πρωτεύων διαχειριστικό εργαλείο των βάσεων δεδομένων του SQL Server (δείτε το στα εργαστήρια).
Τόσο οι διαχειριστές όσο και οι τελικοί χρήστες με πρόσβαση στον SQL Server μπορούν να χρησιμοποιήσουν τον Enterprise Manager.
Επιλέγοντας τον εγγεγραμμένο server (στην περίπτωση μας ο LOCAL), εμφανίζονται τα αντικείμενα από τα οποία αποτελείται ο server, που μας δίνουν την δυνατότητα ελέγχου και διαχείρισης των λειτουργιών του.
Αν δεν φαίνεται κανένας server στον υπολογιστή σας τότε με την επιλογή New SQL Server Registration (εμφανίζεται είτε από το μενού εντολών είτε με δεξί κλικ πάνω στο SQL Server Group), μπορείτε να εγγράψετε έναν νέο.
Αν το κάνετε και είστε σε δίκτυο με άλλους servers θα δείτε ότι μπορείτε να εγγράψετε και κάποιον από αυτούς.
Ο SQL Server είναι σύστημα βάσεων δεδομένων τύπου Server και υποστηρίζει το πρότυπο ODBC.
Ο Enterprise Manager είναι ένα διαχειριστικό εργαλείο από τα client tools.
Σημειώνουμε πάλι ότι δεν ανοίγετε μία βάση δεδομένων όπως κάνετε με ένα αρχείο.
Δεν μπορείτε να τη φορτώσετε στην μνήμη RAM.
Απλά ανοίγετε μία σύνδεση (connection) με τη βάση ή το server (μέσω ενός driver).
Αν ανοίξετε τον SQL Enterprise Manager επιλέξτε disconnect και έπειτα connect για να ανανεώσετε τη σύνδεση.
Για κάθε βάση δεδομένων δημιουργούνται δυο κύρια αρχεία, το αρχείο δεδομένων (data file με επέκταση “.MDF” ) και το αρχείο ημερολογίου συναλλαγών (LogFile με επέκταση “.LDF” ).
Μπορείτε να προσθέσετε και άλλα.
Για τα αρχεία αυτά το μέγεθος είναι απεριόριστο και καθορίζεται κατά την δημιουργία της βάσης.
Το μέγιστο πλήθος βάσεων που επιτρέπεται να υπάρχουν ταυτόχρονα σε ένα διακομιστή είναι 32.767, και το μέγιστο πλήθος των αντικειμένων που μπορούν να υπάρχουν σε μία βάση είναι 2.147.483.647.
Τα μήκη ονόματος χρήστη (user name) καθώς και της συνθηματικής λέξης (password). μπορεί να είναι μέχρι 128 χαρακτήρες.
Τα αντικείμενα εμφανίζονται τόσο στο δένδρο με τους φακέλους και υποφακέλους στο αριστερό παράθυρο του Enterprise Manager, όσο και στο δεξί του με την μορφή εικονιδίων.
Για να ανοίξετε ένα φάκελο κάντε κλικ στο σύμβολο (+) του διακομιστή ή διπλό κλικ στο φάκελο και έτσι θα φανούν όλα τα αντικείμενα στο αμέσως χαμηλότερο λογικό επίπεδο.
Το αντικείμενο Databases περιέχει όλες τις βάσεις δεδομένων.
Σε αυτές τις βάσεις καθώς και σε κάθε νέα που δημιουργείται από τον χρήστη υπάρχουν διάφορα αντικείμενα : · Stored Procedures (αποθηκευμένες διαδικασίες) · User Defined Data Types (Τύποι δεδομένων οριζόμενοι από τον χρήστη) · User Defined Functions (Συναρτήσεις οριζόμενες από τον χρήστη) · Full-text indexes (κατάλογοι αναζήτησης πλήρους κειμένου) Επιλέγοντας δεξί κλικ στο “Databases” και έπειτα “New Database”
Εμφανίζεται το παρακάτω παράθυρο και στην καρτέλα General δίνεται ένα όνομα για τη βάση δεδομένων σας Στην καρτέλα Data Files μπορείτε να δείτε ότι το πρωτεύον αρχείο δεδομένων δημιουργείται αυτόματα και του δίνεται το όνομα της βάσης δεδομένων σας ως πρόθεμα.
Το πρωτεύον αρχείο δεδομένων έχει .mdf επέκταση.
Οποιαδήποτε άλλα αρχεία δημιουργείτε επιπρόσθετα στο πρωτεύον αρχείο, θα είναι δευτερεύοντα αρχεία και θα τους δοθούν αυτομάτως η επέκταση .ndf.
Όλα τα αρχεία που θα δημιουργηθούν εδώ θα τοποθετηθούν στο πρωτεύον filegroup.
Ο SQL Server μπορεί αυτόματα να αυξάνει το μέγεθος της βάσης δεδομένων όταν χρειαστεί, που σας βοηθά την επιβάρυνση της συντήρησης.
Γενικά, προτείνεται να επιλέξετε το χαρακτηριστικό της αυτόματης αύξησης του αρχείου (Automatically Grow The Database Files) διότι απαιτεί μικρή επιβάρυνση στην επίδοση.
Διαφορετικά, θα χρειαστεί να ρυθμίσετε χειροκίνητα το μέγεθος της βάσης δεδομένων: είτε με καθορισμένα blocks MB είτε με ποσοστό του τρέχοντος μεγέθους.
Θυμηθείτε πως το αρχείο της βάσης θα μεγαλώσει μόνο όταν χρειάζεται.
Μπορείτε επίσης να περιορίσετε την βάση δεδομένων σε ένα maximum μέγεθος ή να την αφήσετε να μεγαλώνει χωρίς περιορισμό.
Στην καρτέλα Transaction Log μπορείτε να δείτε πληροφορίες για το transaction log αρχείο.
Το transaction log περιέχει μια εγγραφή με όλες τις μεταβολές της βάσης δεδομένων για δυνατότητα ανάνηψης σε περίπτωση βλάβης του συστήματος.
Το πρώτο transaction log αρχείο δημιουργείται αυτόματα και παίρνει το όνομα της βάσης για πρόθεμα και έχει επέκταση .ldf.
Μπορείτε να αποδεχθείτε το όνομα ή να πληκτρολογήσετε ένα διαφορετικό.
Μπορείτε να προσθέσετε επιπλέον αρχεία αν χρειάζεται.
Δημιουργία νέας βάσης δεδομένων με την SQL: Ανοίγουμε το εργαλείο “SQL Query Analyzer” και γράφουμε την εντολή: CREATE DATABASE ΌνομαΒάσηςΔεδομένων;
Στη συνέχεια πατάμε το πράσινο play κουμπί στην μπάρα εργαλείων, είτε το F5.
Ο πίνακας αποτελεί το σημαντικότερο αντικείμενο μιας βάσης δεδομένων.
Το όνομα του πρέπει να είναι μοναδικό μέσα σε μία βάση.
Το μέγιστο πλήθος του ονόματος σε χαρακτήρες είναι 128.
Ένας πίνακας μπορεί να έχει μέγιστο πλήθος 1024 πεδία, από τα οποία το καθένα έχει 128 χαραχτήρες σαν μέγιστο πλήθος.
Για τις εγγραφές δεν υπάρχει συγκεκριμένο μέγιστο πλήθος.
Το μέγιστο μήκος του ονόματος ενός ευρετηρίου μπορεί να είναι μέχρι 128 χαρακτήρες.
Ο μέγιστος αριθμός ευρετηρίων σε ένα πίνακα μπορεί να φτάσει τα 250 και ο αριθμός των πεδίων σε ένα ευρετήριο τα 16 πεδία.
Ο μέγιστος αριθμός πινάκων σε ένα ερώτημα μπορεί να είναι μέχρι 256 πίνακες και ο μέγιστος αριθμός πεδίων ανά δήλωση SELECT είναι 4096.
Ο αριθμός των φωλιασμένων υπό-ερωτημάτων μπορεί αν είναι 32 και ο μέγιστος αριθμός σχέσεων σε μια βάση δεδομένων είναι 253.
Το μέγιστο μήκος του ονόματος μίας όψης είναι 128.
Το μεγαλύτερο μέγεθος ενός ερωτήματος είναι 16777216 ενώ τα αναδρομικά ερωτήματα ανέρχονται στα 40.
Οι τύποι δεδομένων που υποστηρίζει ο Microsoft SQL Server : Δυαδικά δεδομένα σταθερού μήκους.
Ακέραιος αριθμός με τιμή 1 ή 0 Καθορισμένου μήκους χαρακτήρας non-unicode με ένα ανώτατο 8.000.
Στοιχεία non-unicode μεταβλητού-μήκους με μέγιστο τα 8.000 bytes.
Στοιχεία ημερομηνίας και ώρας σταθερής ακρίβειας αριθμητικά στοιχεία από το -10^38 + 1 μέχρι 10^38 –1.
Αριθμοί κινητής υποδιαστολής από -1,79E + 308 μέχρι 1,79E + 308.
Ακέραιος αριθμός από -2^31 (-2.147.483.648) μέσω 2^31 - 1 (2.147.483.647).
Δυαδικά στοιχεία μεταβλητού-μήκους με μήκος 2^31 - (2.147.483.647) bytes.
Νομισματικές τιμές στοιχείων μεταξύ -2^63 (-922,337,203,685,477.5808) και 2^63 - 1 (+ 922,337,203,685,477.5807), Καθορισμένου μήκους στοιχεία Unicode με μέγιστο μήκος 4.000 χαρακτήρων.
Στοιχεία Unicode μεταβλητού-μήκους με μέγιστο μήκος 4.000 χαρακτήρων.
Στοιχεία Unicode μεταβλητού-μήκους με μέγιστο μήκος 2^30 -1 (1.073.741.823) χαρακτήρες.
Αριθμητικά στοιχεία κινητής υποδιαστολής με κλίμακα από -3.40E + 38 μέχρι 3.40E + 38, Ακέραιος αριθμός από -2^15 (-32.768) μέχρι 2^15 - 1 (32.767).
Στοιχεία non-unicode μεταβλητoύ-μήκους με μέγιστο μήκος 2^31 -1 (2.147.483.647) χαρακτήρες.
Ακέραιος αριθμός από 0 μέχρι 255, Δυαδικά στοιχεία μεταβλητού-μήκους με μέγιστο μήκος 8.000 bytes.
Ο SQL Query Analyzer από το πακέτο των client tools του SQL Server είναι ένα εργαλείο με γραφικό περιβάλλον (GUI) που επιτρέπει τον σχεδιασμό, έλεγχο, και την εκτέλεση Transact-SQL δηλώσεων, stored procedures, batches, και scripts.
Η εκκίνησή του γίνεται είτε από το Start->Programs->Microsoft SQL Server-> Query Analyzer είτε μέσα από τον Enterprise Manager (Tools-> SQL Query Analyzer) ή από command line με την εκτέλεση του isqlw.Εάν είστε συνδεδεμένοι σε έναν server, ο Query Analyzer θα συνδεθεί σε αυτόν.
Ο SQL Query Analyzer Ο SQL Query Analyzer είναι ένα γραφικό εργαλείο που επιτρέπει: · Να δημιουργήσετε ερωτήματα SQL και να τα εκτελέσετε σε διακομιστές (servers) βάσεων δεδομένων από το Query window · Να δημιουργήσετε γρήγορα αντικείμενα βάσεων δεδομένων (πίνακες κλπ) από προκαθορισμένα sql scripts (Templates) · Nα εισάγετε γραμμές σε πίνακα, να τις διορθώσετε / διαγράψετε με scripts · Να αντιγράψτε τα υπάρχοντα αντικείμενα βάσεων δεδομένων (Object Browser) · Να εκτελέστε ή διορθώσετε τις αποθηκευμένες διαδικασίες (T-SQL Debugger) · Να διορθώστε τα προβλήματα απόδοσης ερώτησης (Εμφανίζεται σχέδιο εκτέλεσης των ερωτημάτων, παρουσιάζεται ίχνος κεντρικών υπολογιστών)
To γραφικό περιβάλλον του Query Analyzer αποτελείται από τρία βασικά παράθυρα: Στο αριστερό παράθυρο βρίσκεται ο Object Browser που συνδέεται με τους υπάρχοντες Database Servers και προβάλει όλα τα αντικείμενα (τις βάσεις δεδομένων και τα Common Objects) που μπορεί να χρησιμοποιήσει ο χρήστης με τη μορφή φακέλων.
Ανοίγετε ένα φάκελο με κλικ στο σύμβολο (+) ή διπλό κλικ στο φάκελο.
Στο δεξί πάνω παράθυρο βρίσκεται το Query window που χρησιμοποιείται για την σύνταξη (edit), λεκτική ανάλυση (parse) και την εκτέλεση (execute) των Transact-SQL δηλώσεων.
Ο κώδικας που γράφετε μέσα στον Editor χρωματίζεται με βάση την κατηγορία στην οποία ανήκει.
Ο πίνακας που ακολουθεί δείχνει τα χρώματα και το τι σημαίνουν:
Στο κάτω αριστερό παράθυρο βρίσκεται η περιοχή παρουσίασης αποτελεσμάτων, όπου βλέπουμε τα αποτελέσματα ενός ερωτήματος αλλά και την απόδοση του ερωτήματος.
Μπορείτε είτε να εκτελέσετε ολόκληρα script ή μόνο επιλεγμένες SQL δηλώσεις: · Εκτελείτε ένα ολοκληρωμένο script δημιουργώντας το ή ανοίγοντας το, στον Editor και πατώντας το κουμπί F5 ή το κουμπί στην γραμμή εργαλείων. · Εκτελείτε μόνο επιλεγμένες SQL δηλώσεις, τονίζοντας τις γραμμές του κώδικα στον Editor και πατώντας το κουμπί F5 ή το κουμπί στην γραμμή εργαλείων.
Ανάλυση και Βελτιστοποίηση Ερωτημάτων Ένα από τα πιο σημαντικά χαρακτηριστικά και δυνατότητες που προσφέρει ο Query Analyzer είναι η ανάλυση και Βελτιστοποίηση Ερωτημάτων.
Παρέχει εργαλεία που βοηθάνε τον χρήστη να αναλύσει τα ερωτήματα για την βέλτιστη απόδοση τους.
Ο Query Optimizer είναι ένα εσωτερικό module της βάσης δεδομένων το οποίο προσπαθεί να βρει το βέλτιστο πλάνο εκτέλεσης για κάθε T-SQL δήλωση.
Ο Query Optimizer αναλύει κάθε T-SQL δήλωση, ψάχνει για τον αριθμό των πιθανών πλάνων εκτέλεσης (Execution Plan) και υπολογίζει το κόστος του κάθε πλάνου, σε σχέση με τους πόρους που είναι απαραίτητοι και το χρόνο επεξεργασίας, και επιλέγει το λιγότερο ακριβό πλάνο εκτέλεσης.
Επιλέγοντας Show Query Execution Plan ή Show Estimated Execution Plan σε ένα ερώτημα.
To Εκτιμώμενο Πλάνο Εκτέλεσης παρέχει πρόσβαση σε επιπρόσθετα δεδομένα.
Για να τις δείτε, κρατήστε το ποντίκι πάνω στο εικονίδιο της λειτουργίας.
Εμφανίζεται ένα pop-up παράθυρο που περιέχει τις πρόσθετες πληροφορίες, όπως φαίνεται και στο επόμενο σχήμα.
Το παράθυρο περιέχει τις παρακάτω πληροφορίες: · Physical Operation/Logical Operation Οι φυσικές και λογικές λειτουργίες που εκτελούνται από το ερώτημα, όπως index scans, joins, select, nested loops, aggregations κ.ά. · Estimated Row Count O αριθμός των σειρών που ο query optimizer υπολογίζει ότι θα ανακτηθούν από την λειτουργία. · Estimated Row Size Το εκτιμώμενο μέγεθος των ανακατωμένων σειρών σε bytes. · Estimated I/O Cost Οι εκτιμώμενοι Input/Output πόροι που θα χρησιμοποιηθούν · Estimated CPU Cost Ο εκτιμώμενος χρόνος CPU για αυτή την λειτουργία. · Estimated Number of Executes Ο εκτιμώμενος αριθμός φορών που θα εκτελεστεί αυτή η λειτουργία κατά τη διάρκεια της εκτέλεσης. · Estimated Cost Το κόστος της λειτουργίας όπως αυτό υπολογίζεται από τον query optimizer.
Αυτό το κόστος εμφανίζεται ως ποσοστό του συνολικού κόστους του συνολικού κόστους. · Estimated Subtree Cost Το εκτιμώμενο κόστος εκτέλεσης των προηγουμένων και αυτού του συγκεκριμένου τμήματος.
Ο SQL Server υποστηρίζει εκτός των άλλων και μηχανισμούς ερεθισμών ή σκανδάλων (triggers), που επιβάλλουν περιορισμούς διαδικαστικής ακεραιότητας.
Trigger είναι ένας ειδικός τύπος αποθηκευμένης διαδικασίας που ενεργοποιείται αυτόματα από τον SQL Server όταν τροποποιείται μια γραμμή χρησιμοποιώντας τις διαταγές INSERT (προσθήκη), UPDATE (ενημέρωση) ή DELETE (διαγραφή).
Το πλεονέκτημα μιας διαδικασίας-σκανδάλης είναι ότι ο SQL Server την καλεί αυτόματα όποτε εκτελείται η διαταγή για την οποία έχει οριστεί.
Ένα σύστημα βάσεων δεδομένων χειρίζεται δύο τύπους περιορισμών ακεραιότητας: · Περιορισμούς δηλωτικής ακεραιότητας (δηλαδή primary key constraint, foreign key constraint και check constraint τα οποία ορίζονται κατά την δημιουργία ή αλλαγή ενός πίνακα), που ορίζονται χρησιμοποιώντας τις προτάσεις CREATE ΤΑΒLΕ και ALTER ΤΑΒLΕ. · Περιορισμούς διαδικαστικής ακεραιότητας (ο χειρισμός τους γίνεται με triggers) Για παράδειγμα η δημιουργία ενός trigger στον πίνακα Employees, στον SQL Server:
Με αυτό το trigger αποτρέπουμε τις διπλοεγγραφές στον πίνακα Employees καθώς δε μπορεί να υπάρχουν δύο εργαζόμενοι με τον ίδιο κωδικό (EmployeeCode).
Όταν εισάγουμε δύο φορές τον ίδιο εργαζόμενο το σύστημα θα μας εμφανίσει μήνυμα για την ύπαρξη διπλής εγγραφής.
Είναι κλασικό παράδειγμα για τον έλεγχο των διπλοεγραφών όταν δεν αρκεί ένα index, και δείχνει τρία πράγματα: α) τα γεγονότα-ενέργειες στα οποία θα συμβεί ο trigger (insert, update, delete), β) την συνθήκη που θα ελέγξει (if exists (select)), γ) τις εντολές που θα εκτελέσει begin .. raiserror.., rollback transaction.. end.
Επίσης ο SQL Server στα client tools παρέχει ένα πολύτιμο εργαλείο το DTS για την μεταφορά βάσεων δεδομένων από Access σε SQL Server, από MySQL σε SQL Server, Oracle σε SQL Server και πολλά άλλα συστήματα βάσεων δεδομένων καθώς και αρχεία.
Επικοινωνία Μέσα στον SQL Server Ο διακομιστής βάσης δεδομένων του SQL Server έχει δυο κύρια μέρη: την σχεσιακή μηχανή (relational engine - RE) και τη μηχανή αποθήκευσης (storage engine - SE), όπως φαίνεται στην Εικόνα.
Αυτή η επικοινωνία μεταξύ της σχεσιακής μηχανής και της μηχανής αποθήκευσης γίνετε μέσω διασυνδέσεων OLE-DB, που επιτρέπει στη σχεσιακή μηχανή να επεξεργάζεται ερωτήματα από οποιαδήποτε πηγή δεδομένων που έχει τέτοιες διασυνδέσεις.
Linked Servers (Συνδεδεμένοι Διακομιστές) Μια εξωτερική πηγή δεδομένων (OLE DB ή ODBC) μπορεί να χρησιμοποιηθεί μέσω του SQL Server αν δηλωθεί σαν συνδεμένος διακομιστής (Linked Server).
Ο συνδεδεμένος διακομιστής τότε θα δείχνει στην εξωτερική πηγή δεδομένων.
Αυτή η εξωτερική πηγή δεδομένων μπορεί να είναι MySQL, MSAccess, Oracle ή σχεδόν οποιοδήποτε άλλη βάση δεδομένων συμπεριλαμβανομένων και διαφορετικών SQL servers.
Με έναν linked server, τα δεδομένα που είναι κατανεμημένα σε απομακρυσμένες τοποθεσίες να ανακτηθούν, ενωθούν και συνδυαστούν με τα τοπικά δεδομένα.
Ενώ θα ήταν βολικό όλα τα δεδομένα μιας επιχείρησης να βρίσκονται συγκεντρωμένα σε μια τοποθεσία, υπάρχουν πολλά εμπόδια όπως οι εφαρμογές προμηθευτών που χτίζονται για ένα συγκεκριμένο κατάστημα στοιχείων, σύνολα δεδομένων πάρα πολύ μεγάλα για ένα μόνο κεντρικό υπολογιστή, απαρχαιωμένες εφαρμογές flat αρχείων που το κόστος απαγορεύει να αλλάξουν.
Εάν έχουμε ένα πολύ μεγάλο σύνολο δεδομένων, τότε ίσως μπορούν να υπάρξουν οφέλη στην κατάτμηση των δεδομένων, και στη μετακίνηση τους σε διαφορετικούς servers.
Στη συνέχεια με τη χρήση διανεμημένων κατατμημένων προβολών (distributed partitioned views) παρουσιάζουμε τα δεδομένα ως μια ενιαία πηγή.
Σ’ αυτή τη περίπτωση, οι linked servers είναι η τεχνολογία που το καθιστά ικανό.
Για να δημιουργήσουμε ένα Linked Server φτιάχνουμε πρώτα ένα Data Source Name για κάθε μία απομακρυσμένη βάση δεδομένων.
Έπειτα στον SQL Server με δεξί κλικ πάνω στο εικονίδιο Linked Servers επιλέγουμε New Linked Server.
Στη συνέχεια συμπληρώνουμε τα πεδία Linked Server βάζοντας το όνομα που θέλουμε να έχει ο Linked Server και για Provider name επιλέγουμε «Microsoft OLE DB Provider for ODBC Drivers».
Στο πεδίο Data source γράφουμε το όνομα του Data source που δημιουργήσαμε στην αρχή το οποίο δείχνει στην βάση δεδομένων.
Όπως φαίνεται και στην εικόνα επαναλάβαμε την διαδικασία αυτή για να συνδέσουμε τις βάσεις που βρίσκονται σε διαφορετικές τοποθεσίες και συστήματα και να φτιάξουμε μία κατανεμημένη βάση δεδομένων μέσω του SQL Server.
Παράδειγμα Δημιουργίας προβολής VW_SalesByEmployee Η προβολή (view) εμφανίζει ως μια ενιαία πηγή όλες τις πωλήσεις των πωλητών και από τις τέσσερις τοποθεσίες των Linked Servers.
Τα πεδία είναι ο κωδικός εργαζόμενου, το ονοματεπώνυμο εργαζόμενου, όνομα εταιρίας και οι συνολικές πωλήσεις.
Η MySQL είναι ένα multithreaded, multi-user σύστημα διαχείρισης βάσεων δεδομένων που έχει περισσότερες από 10 εκατομμύρια εγκαταστάσεις.
Έχει γίνει η ποιο δημοφιλής βάση δεδομένων ανοιχτού κώδικα παγκοσμίως λόγω της γρήγορης απόδοσής της, της υψηλής αξιοπιστίας και της εύκολης χρήσης.
Ακόμη τρέχει σε περισσότερα από 20 λειτουργικά όπως Linux, Windows, OS/X, HP-UX, AIX, Netware.
Από την έκδοση MySQL 5.0 και έπειτα, ένα από τα ποιο χρήσιμα χαρακτηριστικά είναι η υποστήριξη αποθηκευμένων διαδικασιών της SQL-3 που επιτρέπουν την αποθήκευση του κώδικα SQL στην βάση δεδομένων του server, επιτρέποντας τους χρήστες και τις εφαρμογές να καλέσουν αυτές τις διεργασίες με τα κατάλληλα ορίσματα χωρίς γνώση της προηγούμενης κατάστασης της SQL.
Η MySQL υποστηρίζεται τώρα από μια ενιαία κερδοσκοπική εταιρία, τη σουηδική επιχείρηση MySQL ΑΒ η οποία κρατά τα πνευματικά δικαιώματα στο μεγαλύτερο μέρος του codebase.
Αυτό είναι παρόμοιο με το πρότυπο jBoss και με το πώς το ελεύθερο ίδρυμα λογισμικού χειρίζεται τα πνευματικά δικαιώματα στα προγράμματά του, και ανόμοιο με το πώς το Apache πρόγραμμα το πραγματοποιεί, όπου το λογισμικό αναπτύσσεται από μια δημόσια κοινότητα και τα πνευματικά δικαιώματα στο codebase κατέχονται από τους μεμονωμένους συντάκτες του.
Για να διαχειριστεί κανείς τις MySQL βάσεις δεδομένων μπορεί να χρησιμοποιήσει το συμπεριλαμβανόμενο εργαλείο command-line (εντολές: mysql και mysqladmin).
Έχει πολλά γραφικά εργαλεία διαχείρισης όπως το MySQL Control Center (δείτε το στα εργαστήρια) ή το Mascon που περιλαμβάνεται και σε διανομές Linux.
Από το επίσημο site μπορείτε να πάρετε και τα MySQL Αdministrator και MySQL Query Browser.
Και τα δύο από τα εργαλεία GUI συμπεριλαμβάνονται τώρα σε μια συσκευασία αποκαλούμενη MySQL GUI tools.
Η MySQL είναι δημοφιλής και για τις εφαρμογές Ιστού.
Η δημοτικότητά της ως εφαρμογή Ιστού είναι πολύ δεμένη με τη δημοτικότητα της PHP, η οποία συνδυάζεται συχνά με MySQL.
Το Wikipedia τρέχει MediaWiki λογισμικό, το οποίο χρησιμοποιεί επίσης το PHP και μια βάση δεδομένων MySQL.
Η MIMER είναι ένα σχεσιακό σύστημα διαχείρισης βάσεων δεδομένων (RDBMS) που αναπτύσσεται από την Sysdeco Mimer στην Ουψάλα, Σουηδία.
Η MIMER είναι μια μηχανή βάσεων δεδομένων υψηλής απόδοσης, όπου προσφέρει τη ρυθμιζόμενη απόδοση, συμπεριλαμβανομένης της υποστήριξης multi-processor, και με τη διαθεσιμότητά του μέσω της 100% προσαρμογής της στα πρότυπα της SQL και της ODBC (Open DataBase Connectivity) προγραμματιστικής διασύνδεσης.
Μια βάση δεδομένων MIMER μπορεί να προσεγγιστεί από έναν μεγάλο αριθμό διαφορετικών εργαλείων ανάπτυξης εφαρμογών.
Μπορείτε να κατεβάσετε δωρεάν όλο το πακέτο (είναι σχετικά μικρό σε μέγεθος) και να κάνετε την εγκατάσταση οπότε θα εγκατασταθεί και το παρακάτω πολύ χρήσιμο εργαλείο που ονομάζεται QBE Vision Query Builder με το οποίο συνδέεστε σε οποιαδήποτε σχεσιακή βάση δεδομένων υποστηρίζει ODBC και τις διαχειρίζεστε όπως θα κάνατε με έναν Database manager, όπου θα βλέπετε user tables, system tables, views και store procedures.
Σε αντίθεση με τα περισσότερα άλλα προϊόντα RDBMS, η MIMER είναι ακριβώς το ίδιο σε όλες τις πλατφόρμες (καμία έκδοση light για PCs), από μικρά lap-top με windows 95/98 , σε έναν μεγάλο επιχειρηματικό κεντρικό υπολογιστή Unix.
Αυτό το καθιστά πιθανό να αναπτύξει μια εφαρμογή με τη βάση δεδομένων που αποθηκεύεται στο lap-top σας, και έπειτα εύκολα να μεταφέρει τη βάση δεδομένων προς έναν μεγαλύτερο κεντρικό υπολογιστή χωρίς να πρέπει να αλλαχτεί μια ενιαία γραμμή κώδικα.
Υπάρχουν δύο τύποι βάσεων δεδομένων, συστημάτων (System) και χρηστών (users).
Οι βάσεις δεδομένων συστημάτων περιέχουν τις πληροφορίες συστημάτων που χρησιμοποιούνται από τους διαχειριστές των βάσεων δεδομένων.
Αυτές οι βάσεις δεδομένων που καθορίζονται κατά την δημιουργία είναι οι: SYSDB, που περιέχει τους πίνακες ευρετηρίων των στοιχείων TRANSDB, που χρησιμοποιείται για τη συναλλαγή των στοιχείων LOGDB, που χρησιμοποιείται για την αναγραφή της συναλλαγής SQLDB, που χρησιμοποιείται στο χειρισμό της συναλλαγής και για την προσωρινή αποθήκευση των εσωτερικών πινάκων εργασίας.
Οι βάσεις δεδομένων χρηστών περιέχουν τους πίνακες που καθορίζονται από τους αρμόδιους χρήστες.
Το σύστημα διαχείρισης σχεσιακών βάσεων δεδομένων Oracle είναι από τα επικρατέστερα έως σήμερα (δείτε την εγκατάσταση στα εργαστήρια).
Σχεδιάστηκε για ταυτόχρονη πρόσβαση σε μεγάλες κατανεμημένες βάσεις δεδομένων.
Η βάση δεδομένων διαιρείται σε ένα ή περισσότερα λογικά κομμάτια που είναι γνωστά ως tablespaces .Ένα tablespace χρησιμοποιείται για να συγκεντρώσει τα δεδομένα.
Το μέγιστο μέγεθος ενός datafile είναι 32GB (gigabytes).
Ο μέγιστος αριθμός datafiles ανά tablespace είναι 1,022.
Το μέγιστο μέγεθος ενός tablespace είναι 32TB (terabyte).
Ο Oracle Enterprise Manager είναι το πρωτεύον εργαλείο διαχείρισης των βάσεών της.
Το περιβάλλον SQL * Plus Worksheet χρησιμοποιείται για την άμεση εκτέλεση δηλώσεων SQL και εμφάνιση αποτελεσμάτων.
Ένας συγκεντρωτικός πίνακας πωλήσεων (SALES) σε βάση δεδομένων της Oracle.
Η SQLite είναι ένα εικονικό σύστημα διαχείρισης σχεσιακών βάσεων δεδομένων (δεν χρειάζεται να εκτελείται ξεχωριστή διεργασία του Server - δηλαδή λειτουργεί με κλήσεις APΙ σε ένα αρχείο DLL) που είναι αποθηκευμένο σε μια σχετικά μικρή βιβλιοθήκη C.
Δημιουργήθηκε από τον D.
Επειδή η SQLite είναι serverless μπορεί να ενσωματωθεί σε μία εφαρμογή χρησιμοποιώντας μόνο την SQLite library.
Στην SQLite2 οι εγγραφές αποθηκεύονται ως κείμενο ASCII.
Η έκδοση 3 ενισχύει τα παραπάνω παρέχοντας τη δυνατότητα να αποθηκεύονται οι ακέραιοι και πραγματικοί αριθμοί με ένα συμπαγέστερο σχήμα, ενώ επιτρέπει και την αποθήκευση τύπων Blob.
Τα περισσότερα προγράμματα διαχείρισης βάσεων δεδομένων αυτού του τύπου διανέμονται δωρεάν όπως ο SQLite Analyzer ή ο SQLite Database Browser Μια βάση της SQLite3 είναι ένα αρχείο συνήθως με επέκταση “.db”, αν και χρησιμοποιούνται διάφορες επεκτάσεις.
Περιορισμοί σχετικά με το πλήθος χαρακτήρων στα ονόματα του πίνακα και των πεδίων του δεν υπάρχουν.
Οι εγγραφές σε έναν πίνακα της SQLite3 αποθηκεύονται σύμφωνα με έναν από τους παρακάτω τύπους:
Η εγγραφή είναι κενή Η εγγραφή είναι ακέραιος αριθμός, που αποθηκεύεται σε 1 ..2 ..3 ..4 ..6, ή 8 bytes ανάλογα με το μέγεθος της εγγραφής Η εγγραφή είναι κινητής υποδιαστολής, που αποθηκεύεται ως 8-byte αριθμός κινητής υποδιαστολής Η εγγραφή είναι κείμενο, που αποθηκεύεται χρησιμοποιώντας την κωδικοποίηση βάσεων δεδομένων (UTF-8, UTF-16BE ή UTF-16-LE) Η εγγραφή αποθηκεύεται ακριβώς όπως εισήχθη
Όπως στην SQLite2, και στην SQLite3 οποιοδήποτε πεδίο στη βάση δεδομένων, εκτός από έναν INTEGER σαν πρωτεύον κλειδί, μπορεί να αποθηκεύσει οποιοδήποτε εγγραφή.
Οι κατηγορίες αποθήκευσης ορίζονται αρχικά ως εξής: Εγγραφές που είναι τμήμα εντολών SQL, θεωρούνται ΚΕΙΜΕΝΟ εάν εσωκλείονται από τα ενιαία ή διπλά quotes, ΑΚΕΡΑΙΟΣ αν είναι αριθμός χωρίς το δεκαδικό μέρος ή τον εκθέτη, ΠΡΑΓΜΑΤΙΚΟΣ εάν είναι αριθμός με ένα δεκαδικό μέρος ή έναν εκθέτη και ΜΗΔΕΝΙΚΟΣ εάν η εγγραφή είναι κενή.
Στην SQLite3, ο τύπος μιας εγγραφής συνδέεται με η ίδια την εγγραφή και όχι με το πεδίο ή τη μεταβλητή στις οποίες η εγγραφή αποθηκεύεται (αυτό καλείται manifest typing) σε αντίθεση με άλλες μηχανές βάσεων δεδομένων SQL που γνωρίζουμε.
Δηλαδή σε μία στήλη ενός πίνακα, μπορούμε να αποθηκεύσουμε δεδομένα από όλους τους τύπους δεδομένων.
Προκειμένου να μεγιστοποιηθεί η συμβατότητα μεταξύ της SQLite και των άλλων μηχανών σχεσιακών βάσεων δεδομένων, υποστηρίζεται η έννοια της "συγγένειας τύπων" στα πεδία.
Με τη "συγγένεια τύπων" ενός πεδίου, εννοούμε τον καταλληλότερο τύπο δεδομένων για τα στοιχεία που αποθηκεύονται στο πεδίο.
Το κλειδί στην SQLite είναι ότι ο τύπος προτείνεται, δεν απαιτείται.
Θεωρητικά όμως πάντα το πεδίο μπορεί να αποθηκεύσει οποιοδήποτε τύπο δεδομένων.
Λαμβάνοντας υπόψη όμως αυτή τη δυνατότητα επιλογής, τα πεδία θα προτιμήσουν να χρησιμοποιήσουν κάποιον τύπο δεδομένων έναντι κάποιου άλλου.
Ο προτιμότερος τύπος αποθήκευσης για ένα πεδίο είναι αυτό που καλείται "συγγένεια".
Σε κάθε πεδίο βάσης δεδομένων της SQLite3, ορίζεται μια από τις ακόλουθες συγγένειες τύπων:
Ένα πεδίο με τη συγγένεια ΚΕΙΜΕΝΩΝ αποθηκεύει όλα τα στοιχεία χρησιμοποιώντας τους τύπους NULL, ΚΕΙΜΕΝΟ ή BLOB.
Εάν το αριθμητικό στοιχείο παρεμβάλλεται σε ένα πεδίο με τη συγγένεια ΚΕΙΜΕΝΩΝ μετατρέπεται σε κείμενο πριν αποθηκευτεί.
Ένα πεδίο με ΑΡΙΘΜΗΤΙΚΗ συγγένεια, μπορεί να περιέχει εγγραφές χρησιμοποιώντας και τους 5 τύπους αποθήκευσης.
Όταν κείμενο παρεμβάλλεται σε πεδίο ΑΡΙΘΜΟΥ, γίνεται μια προσπάθεια να το μετατρέψει σε ακέραιο ή έναν πραγματικό αριθμό προτού να το αποθηκευτεί.
Εάν η μετατροπή είναι επιτυχής, η εγγραφή αποθηκεύεται σαν ΑΚΕΡΑΙΟΣ ή ΠΡΑΓΜΑΤΙΚΟΣ .Εάν η μετατροπή δεν μπορεί να εκτελεστεί, η εγγραφή αποθηκεύεται σαν ΚΕΙΜΕΝΟ.
Καμία προσπάθεια δεν γίνεται για μετατροπή των τιμών NULL ή τιμών BLOB.
Ένα πεδίο που χρησιμοποιεί τη συγγένεια ΑΚΕΡΑΙΩΝ ΑΡΙΘΜΏΝ συμπεριφέρεται με τον ίδιο τρόπο όπως ένα πεδίο με την ΑΡΙΘΜΗΤΙΚΗ συγγένεια.
Ένα πεδίο με τη συγγένεια NONE δεν προτιμά καμία κατηγορία αποθήκευσης.
Δεν επιχειρείται καμία προσπάθεια μετατροπής των εγγραφών προτού αυτές εισαχθούν.
Η βιβλιοθήκη της SQLite αναγνωρίζει τις περισσότερες από τις εντολές της στάνταρ SQL-2 καθώς και πολλές από το πρότυπο SQL-3.
Ένα θεμελιώδες χαρακτηριστικό της προσέγγισης σχεσιακών βάσεων δεδομένων είναι το ότι ένα σύστημα βάσης δεδομένων δεν περιέχει μόνο την ίδια τη βάση αλλά και τον πλήρη ορισμό ή την περιγραφή αυτής που ονομάζεται σχήμα.
Όταν ορίζουμε μια νέα βάση δεδομένων, προσδιορίζουμε μόνο το σχήμα της βάσης δεδομένων στο DBMS (DataBase Management System).
Έτσι η περιγραφή της βάσης δεδομένων (database schema) ορίζεται κατά το σχεδιασμό της και δεν αναμένεται να αλλάζει συχνά.
Αυτός ο ορισμός αποθηκεύεται στον κατάλογο (catalog) του συστήματος ή λεξικό δεδομένων.
Η έννοια του σχήματος εισήχθη στην SQL για να ομαδοποιηθούν πίνακες και άλλα δομικά στοιχεία που ανήκουν στην ίδια εφαρμογή βάσης δεδομένων.
Ένα σχήμα SQL (SQL schema) αναγνωρίζεται από το όνομα σχήματος (schema name) και περιλαμβάνει κάποια ταυτότητα εξουσιοδότησης για την αναγνώριση του χρήστη ή του λογαριασμού που κατέχει το σχήμα, καθώς και περιγραφείς (descriptors) για κάθε στοιχείο του σχήματος.
Ο κατάλογος περιέχει πάντοτε ένα ειδικό σχήμα που λέγεται INFORMATION_SCHEMA, που περιέχει πληροφορίες όπως η δομή κάθε αρχείου, εγγραφές, ονόματα των αρχείων, τύποι δεδομένων, ο τύπος και η μορφή αποθήκευσης κάθε στοιχειώδους δεδομένου, καθώς και διάφοροι περιορισμοί επί των δεδομένων.
Το σχήμα πληροφοριών εισήχθη αρχικά στο πρότυπο SQL92.
Παρέχει τις προβολές σχήματος πληροφοριών έτσι ώστε οι εφαρμογές που αναπτύχθηκαν για άλλα συστήματα βάσεων δεδομένων να μπορούν να κάνουν χρήση του κατάλογου συστήματος του συστήματος διαχείρισης βάσεων, χωρίς να χρειάζεται να τον χρησιμοποιήσουν απευθείας.
Αυτές οι πρότυπες προβολές χρησιμοποιούν διαφορετική ορολογία από το σύστημα, οπότε όταν κάποιος ερμηνεύει ονόματα στηλών, πρέπει να γνωρίζει ότι κατάλογος = βάση δεδομένων, σχήμα = ιδιοκτήτης, και πεδίο τιμών = τύπος δεδομένων που ορίζεται από τον χρήστη (δηλαδή catalog = database, schema = owner, domain = user-defined data type).
Οι παρακάτω ενότητες παρέχουν μια περιγραφή των τριών σημαντικότερων προβολών σχημάτων πληροφοριών στον SQL Server. lnformation_schema.tables: Η προβολή lnformation_schema.tables περιέχει μια γραμμή για κάθε πίνακα στην τρέχουσα βάση δεδομένων, στον οποίο ο χρήστης έχει πρόσβαση.
Η προβολή επαναφέρει τις πληροφορίες από τον πίνακα συστήματος sysobjects. lnformation_schema.views: Η προβολή Information_schema.views περιέχει μια γραμμή για κάθε προβολή στην τρέχουσα βάση δεδομένων που είναι προσπελάσιμη από τον χρήστη.
Η προβολή επαναφέρει πληροφορίες για τους πίνακες συστήματος sysobjects και syscomments. lnformation_schema.columns: Η προβολή lnformation_schema.columns περιέχει μια γραμμή για κάθε στήλη στην τρέχουσα βάση δεδομένων, που είναι προσπελάσιμη από τον χρήστη.
Η προβολή επαναφέρει τις πληροφορίες από τους πίνακες συστήματος sysobjects, systypes και syscomments.
Ο κατάλογος δηλαδή είναι η θέση όπου είναι αποθηκευμένα τα σχήματα όλων των ειδών (εξωτερικό, εννοιολογικό, εσωτερικό), καθώς και όλες οι αντίστοιχες απεικονίσεις (εξωτερική/εννοιολογική, εννοιολογική/εσωτερική).
Οι πληροφορίες που περιέχονται σ' αυτόν τον κατάλογο λέγονται μετα-δεδομένα (meta-data) δηλ. "δεδομένα για τα δεδομένα".
Τα μεταδεδομένα (μετάφραση του όρου metadata, ο οποίος σχηματίζεται από την ελληνική λέξη μετά και τη λατινική λέξη data "δεδομένα") είναι δεδομένα τα οποία περιγράφουν άλλα δεδομένα - τη δομή της κυρίως βάσης.
Κατά κανόνα, ένα σύνολο μεταδεδομένων περιγράφει ένα άλλο σύνολο δεδομένων, το οποίο είναι μια πηγή.
Ο κατάλογος χρησιμοποιείται από το DBMS (DataBase Management System) και περιστασιακά από τους χρήστες της βάσης δεδομένων που χρειάζονται πληροφορίες για τη δομή της βάσης.
Το DBMS δεν γράφεται για κάποια συγκεκριμένη εφαρμογή και, επομένως, πρέπει να αναφέρεται στον κατάλογο για να γνωρίζει τη δομή των αρχείων σε μια συγκεκριμένη βάση δεδομένων.
Το DBMS πρέπει να εργάζεται εξ ίσου καλά με οποιοδήποτε αριθμό εφαρμογών βάσεων δεδομένων - για παράδειγμα μια πανεπιστημιακή βάση δεδομένων, μια τραπεζική βάση δεδομένων ή τη βάση δεδομένων μιας επιχείρησης- εφόσον ο ορισμός των βάσεων δεδομένων αποθηκεύεται στον κατάλογο.
Δηλαδή ο κατάλογος του συστήματος αποτελεί ο ίδιος μια «μικρο-βάση δεδομένων».
Ένα από τα πιο βολικά χαρακτηριστικά των σχεσιακών συστημάτων διαχείρισης βάσεων δεδομένων είναι ότι, σ' ένα τέτοιο σύστημα, ο ίδιος ο κατάλογος αποτελείται από πίνακες (για την ακρίβεια, από πίνακες συστήματος, που ονομάζονται έτσι για να τους ξεχωρίζουμε από τους συνηθισμένους πίνακες του χρήστη).
Έτσι, οι χρήστες μπορούν να ερευνούν τον κατάλογο ακριβώς με τον ίδιο τρόπο που ερευνούν τα δικά τους δεδομένα.
Για παράδειγμα, ο κατάλογος κατά κανόνα περιέχει δύο πίνακες συστήματος, που ονομάζονται TABLES (πίνακες) και COLUMNS (στήλες), των οποίων σκοπός είναι να περιγράφουν τους πίνακες που είναι γνωστοί στο σύστημα και τις στήλες αυτών των πινάκων.
Για τη βάση δεδομένων τμημάτων (DEPT) και υπαλλήλων (EMP), οι πίνακες TABLES και COLUMNS θα μπορούσαν να είναι σε γενικές γραμμές όπως στην παρακάτω εικόνα.
Από τον πίνακα TABLES φαίνεται ότι ο πίνακας DEPT έχει τρεις στήλες και τρεις εγγραφές, και ο πίνακας EMP έχει 4 στήλες και 4 εγγραφές.
Στον πίνακα COLUMNS φαίνονται επίσης και τα ονόματα των γνωρισμάτων (στηλών) και τα πρωτεύοντα και ξένα κλειδιά.
Οι πληροφορίες που αποθηκεύονται γενικά σε ένα κατάλογο μπορούν να περιλαμβάνουν περιγραφές των ονομάτων των πινάκων (σχέσεων), των ονομάτων των γνωρισμάτων, των τύπων δεδομένων των γνωρισμάτων, των πρωτευόντων κλειδιών, των ξένων κλειδιών και των άλλων τύπων περιορισμών καθώς και του εξωτερικού επιπέδου για τις όψεις και εσωτερικού περιγραφές για τις δομές αποθήκευσης και τα ευρετήρια.
Συμπεριλαμβάνονται πληροφορίες σχετικά με την ασφάλεια και τις διαδικασίες, πληροφορίες που προσδιορίζουν τη δικαιοδοσία προσπέλασης των χρηστών στους πίνακες και τις όψεις, καθώς και τους δημιουργούς ή ιδιοκτήτες κάθε πίνακα.
SQL Server (οι πίνακες συστήματος -system tables- στη βάση test2) MS Access (οι πίνακες συστήματος -system tables- στη βάση TrioMotors)
MySQL (οι πίνακες συστήματος στο information_schema )
MimerSQL βάσεις δεδομένων (οι πίνακες συστήματος -system tables-)
Η τυποποίηση Open DataBase Connectivity (ODBC) ορίζει έναν τρόπο για να επικοινωνεί ένα πρόγραμμα με έναν διακομιστή βάσης δεδομένων.
Το ODBC ορίζει ένα περιβάλλον προγραμματισμού εφαρμογής (application program interface – API) που επιτρέπει σε εφαρμογές που είναι γραμμένες σε διάφορες γλώσσες προγραμματισμού όπως C, C++, C#, Visual Basic, Borland Delphi, Java να έχουν πρόσβαση στις βάσεις δεδομένων.
Οι εφαρμογές χρησιμοποιούν ODBC για να ανοίξουν μια σύνδεση με μια βάση δεδομένων, να στείλουν ερωτήματα SQL και άλλες εντολές και να πάρουν αποτελέσματα.
Κάθε σύστημα βάσης δεδομένων που υποστηρίζει ODBC παρέχει μια βιβλιοθήκη που πρέπει να συνδεθεί με το πρόγραμμα-πελάτη.
Όταν το πρόγραμμα-πελάτης κάνει μια κλίση ODBC API, ο κώδικας της βιβλιοθήκης επικοινωνεί με τον διακομιστή για να κάνει την απαιτούμενη ενέργεια και να πάρει τα αποτελέσματα.
Απαραίτητη προϋπόθεση για να γίνει η επικοινωνία είναι να υπάρχουν εγκαταστημένοι οι ODBC drivers.
Αφού γίνει η εγκατάσταση πρέπει να δημιουργήσουμε ένα DSN ( Data Source Name ) που είναι το όνομα που επιλέγουμε για την σύνδεση με την βάση.
Ένα DSN είναι ένα αναγνωριστικό το οποίο καθορίζει μια πηγή δεδομένων για ένα πρόγραμμα οδήγησης ODBC.
Επιλέγετε : Πίνακας Ελέγχου -> Εργαλεία Διαχείρισης -> Πηγές δεδομένων ODBC καρτέλα DSN χρήστη ή DSN συστήματος ή DSN αρχείου και το κουμπί προσθήκη Στο παράθυρο διαλόγου Δημιουργία αρχείου προέλευσης δεδομένων, επιλέξτε ένα όνομα προγράμματος οδήγησης και ακολουθήστε τις οδηγίες του οδηγού.
Για να δημιουργήσουμε ένα DSN συστήματος (το βλέπουν όλοι οι χρήστες):
Πίνακας Ελέγχου->Εργαλεία Διαχείρισης->Πηγές δεδομένων ODBC->DSN συστήματος.
Για καινούριο DSN, πατάμε Προσθήκη και ανοίγει το επόμενο πλαίσιο διαλόγου.
Επιλέγουμε από τη λίστα τον driver της Microsoft Access.
Έπειτα ανοίγει το παρακάτω πλαίσιο διαλόγου, όπου γράφουμε το Όνομα προέλευσης δεδομένων, δηλαδή ένα όνομα για το νέο DSN.
Επίσης πρέπει να επιλέξουμε από το κουμπί Επιλογή τη βάση δεδομένων που θα δείχνει το DSN.
Πατάμε OK και το νέο DSN έχει δημιουργηθεί.
Μία τυπική συμβολοσειρά σύνδεσης (connection string) για αυτόν τον ODBC driver είναι η:
Για να δημιουργήσουμε ένα νέο DSN σε SQL Server, κάνουμε τα εξής :
Ακολουθούμε τα βήματα 1 και 2, όπως παραπάνω και επιλέγουμε SQL Server.
Στο πλαίσιο Όνομα πληκτρολογούμε το όνομα του νέου DSN και στο πλαίσιο Διακομιστής το διακομιστή SQL που θα συνδεθούμε.
Αν είναι τοπικά γράψτε (local).
Στη συνέχεια εμφανίζει το παρακάτω πλαίσιο διαλόγου όπου αλλάζουμε τις ρυθμίσεις σύμφωνα με τα δικά μας δεδομένα.
Έπειτα ορίζουμε ποια θέλουμε να είναι η προεπιλεγμένη βάση δεδομένων μας.
Εδώ πρέπει να αλλάξετε από την master στην δικιά σας
Έπειτα, πατώντας επόμενο και Τέλος μας εμφανίζει το παρακάτω πλαίσιο, όπου μπορούμε να δοκιμάσουμε το αρχείο προέλευσης δεδομένων, για να δούμε αν ολοκληρώθηκε με επιτυχία.
Μία τυπική συμβολοσειρά σύνδεσης (connection string) για τον ODBC driver του SQL Server είναι η: Για να δημιουργήσουμε ένα DSN σε MySQL, κάνουμε τα εξής :
Ακολουθούμε τα βήματα 1 και 2, όπως πριν και επιλέγουμε MySQL ODBC 3.51 Driver.
Στη συνέχεια εμφανίζεται το παρακάτω πλαίσιο διαλόγου όπου κάνουμε τις απαραίτητες ρυθμίσεις.
Αφού αλλάξετε τα server, user, password και database στα δικά σας τότε πατώντας στο κουμπί Test βλέπετε αν η σύνδεση έχει γίνει με επιτυχία ή όχι.
Μία τυπική συμβολοσειρά σύνδεσης (connection string) για τον ODBC driver της MySQL είναι η: Για να δημιουργήσουμε ένα DSN σε Mimer, κάνουμε τα εξής :
Ακολουθούμε τα βήματα 1 και 2, όπως πριν και επιλέγουμε MIMER
Στη συνέχεια, εμφανίζεται το παρακάτω πλαίσιο διαλόγου όπου ορίζουμε το όνομα που θα έχει το νέο μας DSN και τη βάση δεδομένων που θα χρησιμοποιήσουμε.
Μία τυπική συμβολοσειρά σύνδεσης (connection string) για τον ODBC driver της Mimer SQL είναι η:
Το μοντέλο Οντοτήτων-Συσχετίσεων (τετράγωνα ( οντότητες, ρόμβοι ( συσχετίσεις)
Η συσχέτιση των φοιτητών με τα μαθήματα είναι πολλά προς πολλά.
Έτσι θα δημιουργήσουμε τρεις πίνακες για αυτή τη βάση δεδομένων όπου θα καταχωρούμε πληροφορίες για τους φοιτητές, τα μαθήματα και τις βαθμολογίες.
ΣΥΜΒΑΣΕΙΣ ΟΝΟΜΑΤΟΛΟΓΙΑΣ: Το όνομα κάθε αντικειμένου της βάσης δεδομένων μπορεί να έχει μέχρι 64 χαρακτήρες.
Δεν μπορεί να περιέχει σύμβολα όπως , : ; ! ( ) [ ] { } .’ ή να αρχίζει με κενό.
Επίσης, για λόγους συμβατότητας, κατά την ονομασία: αποφεύγετε τα σύμβολα πράξεων: + - * / \ % ^, ξεκινάτε ένα όνομα πάντα με χαρακτήρα και όχι με αριθμό π.χ.
Ερωτ1 και όχι 1Ερωτ, αποφεύγετε τα ονόματα και συνώνυμα των τύπων δεδομένων π.χ.
Υπάρχουν δύο μέθοδοι δημιουργίας πίνακα (στην Access, MySQL, SQL Server, Oracle κλπ).
Μέσω ενός γραφικού περιβάλλοντος από μια εφαρμογή πελάτη (client) ή χρησιμοποιώντας κώδικα SQL.
Η πρώτη μέθοδος είναι πιο εύχρηστη αλλά η δεύτερη είναι πιο πρακτική επειδή θα γράψετε μόνο μία φορά τον κώδικα SQL και θα μπορείτε να τον εκτελέσετε ξαναδημιουργώντας τη βάση όσες φορές θέλετε.
Θα δούμε και τις δύο μεθόδους.
Δημιουργία του πίνακας "Φοιτητες" (Δημιουργία πίνακα σε προβολή σχεδίασης) με πρωτεύον κλειδί το πεδίο ΚωδΦοιτητη (επιλέγουμε το πεδίο ΚωδΦοιτητη και έπειτα δίνουμε την εντολή Επεξεργασία->Πρωτεύον κλειδί. θα εμφανιστεί ένα εικονίδιο κλειδιού.
Αυτόματα δημιουργείται και ένα ευρετήριο (index).
Οι εγγραφές του πίνακα Φοιτητες
Δημιουργία του πίνακα "Μαθηματα" με πρωτεύον κλειδί το πεδίο ΚωδΜαθηματος (Από της Ιδιότητες πεδίου αλλάζετε το μέγεθος πεδίου) Οι εγγραφές του πίνακα Μαθηματα
Δημιουργία του πίνακα "Βαθμολογιες" με πρωτεύον κλειδί τα δύο πεδία ΚωδΜαθηματος, ΚωδΦοιτητη. (Σημείωση: Για να ορίσετε τα δύο πεδία ως πρωτεύον κλειδί, τα επιλέγετε από το πλάι και δίνετε την εντολή Επεξεργασία->Πρωτεύον Κλειδί.
Αριστερά από τα ονόματα των δύο πεδίων θα εμφανιστεί το εικονίδιο κλειδιού).
Παρατηρήστε ότι και τα δύο πεδία αποτελούν το πρωτεύον κλειδί του πίνακα βαθμολογίες το οποίο δέχεται μοναδικές τιμές, αλλά και ότι το κάθε ένα πεδίο ξεχωριστά είναι ξένο κλειδί αφού είναι πρωτεύον κλειδί σε άλλον πίνακα.
Οι εγγραφές του πίνακα Βαθμολογιες
Σημείωση: Παρατηρήστε πως συνδέεται μία εγγραφή από έναν πίνακα με μία εγγραφή από έναν άλλο πίνακα (π.χ. το Μαθημα με Κωδικο 1 με τον Φοιτητή με ΚωδΦοιτητη 3 );
Με ένα ζεύγος τιμών των πρωτευόντων κλειδιών τους { 1, 3 }.
Αυτά τα ζεύγη τιμών των πρωτευόντων κλειδιών {τιμήΑ, τιμήΒ} που στην ουσία το κάθε ένα συνδέει ένα μέλος του συνόλου Α με ένα μέλος του συνόλου Β ονομάζονται σχέσεις και οι βάσεις δεδομένων σχεσιακές βάσεις δεδομένων.
Το πρώτο χαρακτηριστικό των σχέσεων είναι ότι μεταβάλλονται με το χρόνο (εισαγωγές, διαγραφές, ενημερώσεις).
Παρατηρήστε επίσης πως συνδέονται δύο Πίνακες;
Η σύνδεση δύο πινάκων επιτυγχάνεται µε τα κοινά πεδία τιμών τους (πρωτεύον κλειδί στον έναν, ξένο στον άλλον).
Δύο ή περισσότεροι πίνακες συνδέονται μεταξύ τους με τα κοινά πεδία τιμών τους.
Το πρωτεύον κλειδί του ενός που είναι ξένο στον άλλον.
Δηλαδή κάθε τιμή ξένου κλειδιού που καταχωρείται θα πρέπει να υπάρχει σαν τιμή πρωτεύοντος κλειδιού.
Για να δημιουργήσουμε τους περιορισμούς αναφορικής ακεραιότητας επιλέγουμε την εντολή Εργαλεία-Σχέσεις.
Στη συνέχεια επιλέγουμε έναν-έναν τους τρεις Πίνακες και πατάμε προσθήκη στο παράθυρο.
Σημείωση: Αυτό δεν είναι το μοντέλο Οντοτήτων-Συσχετίσεων Είναι βέβαια ένα πολύ παραστατικό διάγραμμα που μας διευκολύνει, δείχνοντας τη συνολική δομή της βάσης,
Σέρνουμε από τον κάθε πίνακα το Πρωτεύον κλειδί, (που φαίνεται με τα έντονα γράμματα) στο αντίστοιχό του ξένο κλειδί στον άλλο πίνακα.
Σέρνουμε το πεδίο ΚωδΦοιτητη από τον πίνακα Φοιτητες στο πεδίο ΚωδΦοιτητη του πίνακα Βαθμολογιες.
Εμφανίζεται το παρακάτω παράθυρο επεξεργασίας σχέσεων : Στο παράθυρο επεξεργασίας σχέσεων της εικόνας θα επιλέξουμε την Ενεργοποίηση Ακεραιότητας αναφορών.
Τώρα ο ΚωδΦοιτητη που θα εισάγουμε στον Πίνακα Βαθμολογιες θα απαιτείται να υπάρχει ήδη στον Συσχετιζόμενο Πίνακα Φοιτητες (σε διαφορετική περίπτωση η βάση θα στείλει ένα μήνυμα σφάλματος).
Με τον ίδιο τρόπο δημιουργούνται οι υπόλοιποι περιορισμοί.
Σημείωση: Όταν ορίζουμε σχέσεις ανάμεσα στα πεδία πρέπει πάντα να φροντίζουμε να έχουν τον ίδιο τύπο δεδομένων.
Ο τύπος αυτόματη αρίθμηση είναι ακέραιος μεγάλου μήκους. σημαίνει ‘ένα προς πολλά’, δηλαδή ένας φοιτητής μπορεί να συνδεθεί με πολλές εγγραφές μαθημάτων.
Προσδιορίζεται αυτόματα με βάση τον ορισμό των δύο πεδίων, όταν ένα μόνο από τα δύο είναι πρωτεύον κλειδί ή έχει ευρετήριο μοναδικής τιμής.
Όταν και τα δύο πεδία είναι πρωτεύοντα κλειδιά ή έχουν ευρετήριο μοναδικής τιμής ο τύπος είναι ‘ένα προς ένα’ και όταν κανένα από τα δύο δεν είναι πρωτεύον κλειδί ή δεν έχει ευρετήριο μοναδικής τιμής τότε ο τύπος είναι ‘αόριστος’.
Δίχως την Ενεργοποίηση Ακεραιότητας αναφορών εμφανίζεται μόνο μία γραμμή συνδέσμου.
Αυτός ο σύνδεσμος ονομάζεται έμμεσος καθορισμός συνθήκης σύζευξης για ερωτήσεις που περιλαμβάνουν τους δύο πίνακες.
Αν δηλαδή αργότερα κατά τον γραφικό σχεδιασμό ενός ερωτήματος δεν ορίσετε συνθήκη σύζευξης μεταξύ των δύο πινάκων, τότε εκτελείται αυτή που προκαθορίσατε στο παράθυρο σχέσεων (το ίδιο συμβαίνει για τις φόρμες, υποφόρμες και εκθέσεις).
Αν προσπαθήσετε τώρα να εισάγετε στον πίνακα Βαθμολογίες μία τιμή ξένου κλειδιού, π.χ.
ΚωδΦοιτητη 100, η οποία δεν υπάρχει σαν τιμή πρωτεύοντος κλειδιού στον πίνακα Φοιτητες θα πάρετε το μήνυμα You cannot add or change a record because a related record is required in table ‘Φοιτητες’ Να δημιουργήσετε τη φόρμα "φορμΦοιτητες" (επιλέγετε δημιουργία φόρμας σε προβολή σχεδίασης)
Έπειτα πατάμε Προβολή-Ιδιότητες στη Γραμμή εντολών και επιλέγουμε στο παράθυρο «Φόρμα» την Προέλευση εγγραφών να είναι από τον πίνακα «Φοιτητες»
Κλείνουμε το παράθυρο της προβολής ιδιοτήτων της Φόρμας και εμφανίζεται δίπλα στη φόρμα το παρακάτω παράθυρο της λίστας πεδίων που θα είναι δεσμευμένα στη φόρμα. (Αν δεν εμφανίζεται η λίστα πεδίων δώστε την εντολή Προβολή->Λίστα πεδίων) Επιλέγουμε, με το ποντίκι και κρατώντας πατημένο το SHIFT, όλα τα πεδία από τη λίστα πεδίων (το παράθυρο "Φοιτητες") και τα σέρνουμε πάνω στη φόρμα
Τότε η φόρμα θα γίνει όπως το παρακάτω παράθυρο.
Κάθε πλαίσιο κειμένου δεσμευμένο στο αντίστοιχο πεδίο εισάγεται με την ετικέτα του)
Αποθηκεύστε την φόρμα με όνομα φορμΦοιτητες.
Να δημιουργήσετε τη φόρμα "φορμΜαθηματα" για την καταχώρηση δεδομένων στον πίνακα "Μαθηματα" επαναλαμβάνοντας τα παραπάνω Να γίνει η φόρμα "φορμΒαθμολογιες" για τις καταχωρήσεις στον πίνακα "Βαθμολογιες" με τη χρήση του οδηγού και να έχει διάταξη πίνακα Επιλέγουμε Δημιουργία φόρμας με τη χρήση του οδηγού και Στην επιλογή Πίνακες/Ερωτήματα επιλέγουμε τον πίνακα Βαθμολογιες και εισάγουμε όλα τα πεδία πατώντας και πατάμε επόμενο όπου επιλέγουμε διάταξη Πίνακα (θα δείχνει όλες τις εγγραφές). πατάμε επόμενο και διαλέγουμε ένα στυλ για τη φόρμα.
Πατάμε επόμενο και δίνουμε για τίτλο φόρμας το όνομα "φορμΒαθμολογιες".
Να κάνετε την φόρμα ‘φορμΒαθμολογιες’ δευτερεύουσα στη φόρμα των φοιτητών (Σημείωση) Οι Φοιτητες εγγράφονται σε πολλά Μαθηματα, άρα θα χρησιμοποιήσουμε την παραπάνω φόρμα σαν δευτερεύουσα φόρμα (ή αλλιώς υποφόρμα) στη φόρμα καταχώρησης των φοιτητών.
Ανοίγουμε τη φόρμα φορμΦοιτητες σε προβολή σχεδίασης (επιλέγουμε τη φόρμα και το κουμπί Σχεδίαση ) και σέρνουμε με το ποντίκι τη φόρμα φορμΒαθμολογιες μέσα στη φόρμα φορμΦοιτητες.
Επιλέγουμε Ερωτήματα και Δημιουργία ερωτήματος σε προβολή σχεδίασης , Προσθήκη τον πίνακα Φοιτητες και Κλείσιμο, Έπειτα Προβολή->SQL
Να δημιουργηθεί ερώτημα που να εμφανίζει όλα τα στοιχεία των φοιτητών. (Ο αστερίσκος * εμφανίζει στο αποτέλεσμα όλα τα πεδία)
Να δημιουργηθεί ερώτημα που να εμφανίζει όλα τα στοιχεία του φοιτητή με ΚωδΦοιτητη 3.
Εμφανίστε όλα τα στοιχεία (τα πεδία) των Φοιτητών με ΚωδΦοιτητη μεγαλύτερο του 3.
Εμφανίστε όλα τα στοιχεία των Φοιτητών με ΚωδΦοιτητη διάφορο του 3.
Εμφανίστε όλα τα στοιχεία των Φοιτητών με ΚωδΦοιτητη μικρότερο ή ίσο του 3 ταξινομημένα κατά Επωνυμο με αύξουσα σειρά
ΣΗΜΕΙΩΣΗ: στην πρόταση order by γράφονται τα ονόματα πεδίων σύμφωνα με τα οποία θα γίνει η ταξινόμηση του αποτελέσματος – η προεπιλογή είναι αύξουσα σειρά.
ΕρωτΛισταΜαθηματων.
Εμφανίστε από τον πίνακα μαθηματα τα πεδία ΚωδΜαθηματος, Μαθημα, ΔιδακτικεςΜοναδες. select ΚωδΜαθηματος, Μαθημα, ΔιδακτικεςΜοναδες (ΣΗΜΕΙΩΣΗ) Επειδή δεν είναι δυνατόν να θυμόμαστε τους κωδικούς Μαθημάτων, δημιουργούμε ερώτημα αναζήτησης των κωδικών αυτών από τον αντίστοιχο πίνακα, και αποθηκεύουμε το ερώτημα με όνομα "ερωτΛισταΜαθηματων".
Να μετατρέψετε σε Σύνθετο πλαίσιο (combo box) το πεδίο ΚωδΜαθηματος στη φόρμα "φορμΒαθμολογιες" Το σύνθετο πλαίσιο συνδυάζει τις λειτουργίες ενός πλαισίου κειμένου και ενός πλαισίου λίστας (θα τα δείτε αναλυτικά στο επόμενο εξάμηνο στον Borland C++ Builder).
Ανοίγουμε σε προβολή σχεδίασης τη φόρμα "φορμΒαθμολογιες" και σβήνουμε το πεδίο ΚωδΦοιτητη και την ετικέτα του.
Μεγαλώνουμε το πεδίο ΚωδΜαθηματος και την ετικέτα του όπως παρακάτω
Το πεδίο ΚωδΜαθηματος θα το μετατρέψουμε σε σύνθετο πλαίσιο.
Το επιλέγουμε με δεξί κλικ και επιλέγουμε Αλλαγή σε -> Σύνθετο πλαίσιο
Όπως είναι επιλεγμένο πατάμε στη γραμμή εντολών Προβολή->Ιδιότητες και στο παράθυρο ιδιοτήτων επιλέγουμε η προέλευση γραμμής να γίνεται από το ερώτημα ερωτΛισταΜαθηματων
Πριν κλείσουμε το προηγούμενο παράθυρο επιλέγουμε την καρτέλα Μορφή και αλλάζουμε τις ιδιότητες όπως στην παρακάτω εικόνα
Κλείνουμε το παράθυρο ιδιοτήτων και πατάμε στη γραμμή εντολών Προβολή->Φόρμας.
Πρέπει να έχει διαμορφωθεί όπως παρακάτω.
Τώρα μπορούμε, ανοίγοντας την φόρμαΦοιτητες, να επιλέγουμε από το σύνθετο πλαίσιο τα Μαθηματα της δευτερεύουσας φόρμας σύμφωνα με το όνομά τους και να καταχωρείτε αυτόματα ο κωδικός τους στον πίνακα Βαθμολογιες. (Αυτό σημαίνει η επιλογή Δεσμευμένη στήλη 1 στην καρτέλα ιδιοτήτων του σύνθετου πλαισίου).
Προσθήκη Πλαίσιου υπολογισμού: Στη φόρμα "φορμΒαθμολογιες" να προσθέσετε στο υποσέλιδο φόρμας ένα πλαίσιο κειμένου (ab() από την εργαλειοθήκη που να υπολογίζει το Πλήθος Μαθημάτων ( στο πλαίσιο κειμένου =COUNT(*) )
Δείτε πως έγινε η φόρμαΦοιτητες.
Για περισσότερες συναρτήσεις δείτε τις ΜAX, MIN, SUM, AVG, COUNT.
Εισάγετε στη φόρμα Φοιτητες το όνομα και Επωνυμο σας.
Έπειτα επιλέξτε κάθε ένα από τα Μαθηματα και καταχωρήστε τον αντίστοιχο βαθμό σας.
Αποθηκεύσετε και τρέξτε τα παρακάτω SQL Scripts για την δημιουργία της βάσης.
ΚωδΦοιτητη integer not null , Ονομα varchar(30) not null , Επωνυμο varchar(30) not null , [Νομος/Περιοχη] varchar(20) , constraint PK_Fititi primary key (ΚωδΦοιτητη) );
ΚωδΜαθηματος integer not null , Μαθημα varchar(30) not null , constraint PK_Mathimatos primary key (ΚωδΜαθηματος) );
ΚωδΜαθηματος integer not null , constraint PK_Engrafis primary key (ΚωδΜαθηματος, ΚωδΦοιτητη) );
ΚωδΚαθηγητη integer not null , constraint PK_Kathigiti primary key (ΚωδΚαθηγητη) ); constraint PK_Didaskalias primary key (ΚωδΚαθηγητη, ΚωδΜαθηματος, ΕτοςΔιδασκαλιας) );
Στην MS Access εισάγετε τα δεδομένα μαζικά με λήψη από εξωτερικά αρχεία κειμένου στα οποία τα δεδομένα είναι οριοθετημένα με στηλοθέτες (tab) με την εντολή Αρχείο->Λήψη εξωτερικών δεδομένων->Εισαγωγή.
Στον SQL SERVER με το πρόγραμμα Import and Export Data (επιλέγοντας για Data Source : Text File, έπειτα εντοπίζοντας το κάθε ένα αρχείο txt και εισάγοντάς το στην βάση που δημιουργήσατε στον αντίστοιχο πίνακα) Για τον πίνακα Φοιτητες: Αρχείο->Λήψη εξωτερικών δεδομένων-> Εισαγωγή.
Ο πίνακας ΕγγραφεςΜαθηματων έχει δύο ξένα κλειδιά.
Το ξένο κλειδί ΚωδΜαθηματος πρέπει να αναφέρεται στις υπάρχουσες τιμές του πρωτεύοντος κλειδιού του πίνακα Μαθηματα Το ίδιο πρέπει να ισχύει για το ξένο κλειδί ΚωδΦοιτητη του πίνακα ΕγγραφεςΜαθηματων που θα αναφέρεται στο πρωτεύον κλειδί του πίνακα Φοιτητες Τ06.
Δημιουργία περιορισμού ξένου κλειδιού στον πίνακα ΕγγραφεςΜαθηματων alter table ΕγγραφεςΜαθηματων add constraint FK_FititisEgrafeteMathima foreign key (ΚωδΜαθηματος) references Μαθηματα (ΚωδΜαθηματος); alter table ΕγγραφεςΜαθηματων add constraint FK_MathimaEgrafeteFitits foreign key (ΚωδΦοιτητη) references Φοιτητες (ΚωδΦοιτητη);
Τ08.
Δημιουργία περιορισμού ξένου κλειδιού στον πίνακα ΔιδασκαλιεςΜαθηματων alter table ΔιδασκαλιεςΜαθηματων add constraint FK_MathimaDidaskeiKathigitis foreign key (ΚωδΚαθηγητη) references Καθηγητες (ΚωδΚαθηγητη); alter table ΔιδασκαλιεςΜαθηματων add constraint FK_KathigitisDidaskeiMathima foreign key (ΚωδΜαθηματος) references Μαθηματα (ΚωδΜαθηματος);
ΣΗΜΕΙΩΣΕΙΣ: Οι περιορισμοί μπορούν να οριστούν και κατά τη δημιουργία πίνακα με την εντολή create table.
Ένα ξένο κλειδί σε έναν πίνακα, δείχνει σε ένα πρωτεύον κλειδί σε έναν άλλο πίνακα.
Οι περιορισμοί ξένου κλειδιού αποτρέπουν ενέργειες που αφήνουν «εκκρεμείς» γραμμές με τιμές ξένων κλειδιών σε πρωτεύοντα κλειδιά που δεν υπάρχουν σε άλλους πίνακες (ακεραιότητα αναφορών).
Η χρήση του ON DELETE στον τέλος του περιορισμού ελέγχει την ενέργεια που θα πραγματοποιηθεί κατά την απόπειρα διαγραφής γραμμής στην οποία υπάρχει στήλη που δείχνεται από ξένο κλειδί σε άλλο πίνακα.
Υπάρχουν οι εξής επιλογές:NO ACTION: αποτρέπεται η διαγραφή και προβάλλεται μήνυμα λάθους (προεπιλογή).CASCADE: διαγράφει τη γραμμή και προκαλεί διαγραφή όλων των γραμμών σε άλλους πίνακες, οι οποίες περιέχουν ξένα κλειδιά προς την τιμή κλειδιού της διαγραμμένης στήλης.
Αντίστοιχοι περιορισμοί μπορούν να ορισθούν και για την περίπτωση μεταβολής του κύριου κλειδιού, μέσω της πρότασης ON UPDATE. *Σε κάθε βάση δεδομένων αν δημιουργούμε τους περιορισμούς αυτούς γραφικά, σύροντας τα πεδία από τον ένα πίνακα στον άλλο, τα ονόματα των περιορισμών (σχέσεων) δίνονται αυτόματα.
Μία συσχέτιση ένα-προς-πολλά, όπως η Φοιτητες-ΕγγραφεςΜαθηματων (ένας φοιτητής-πολλές εγγραφές μαθημάτων, όπου ο κωδικός Φοιτητή του πίνακα ΕγγραφεςΜαθηματων είναι ξένο κλειδί στον πίνακα Φοιτητες ) που έχει δημιουργηθεί γραφικά από το παράθυρο των σχέσεων στην MS Access (Εργαλεία-Σχέσεις) , ή των διαγραμμάτων στον SQL Server (επιλογή Diagrams) μπορούμε να τη διαγράψουμε με την δήλωση SQL: alter table ΕγγραφεςΜαθηματων drop constraint ΦοιτητεςΕγγραφεςΜαθηματων ; **Σε κάθε βάση δεδομένων όταν ορίζουμε το πρωτεύον κλειδί σε προβολή σχεδίασης πίνακα, το Ονομα του περιορισμού για το πρωτεύον κλειδί ορίζεται αυτόματα σαν PrimaryKey.
Η ακόλουθη δήλωση SQL διαγράφει το πρωτεύον κλειδί στον πίνακα Φοιτητες : alter table Φοιτητες drop constraint PrimaryKey;
Το σχεσιακό μοντέλο δεδομένων αποτελείται από δομές (σχέσεις), δομικούς περιορισμούς (πρωτεύοντος κλειδιού, ακεραιότητας οντότητας, αναφορικής ακεραιότητας ξένων κλειδιών), και σχεσιακές πράξεις (σχεσιακή άλγεβρα).
Σύμφωνα με αυτές τις πράξεις συντάσσονται και οι προτάσεις της γλώσσας SQL.
Δημιουργήστε ερώτημα εισαγωγής που να προσθέτει ένα νέο μάθημα insert into Μαθηματα(ΚωδΜαθηματος, Μαθημα, ΔιδακτικεςΜοναδες) Η πράξη της εισαγωγής (insert into – values – ) είναι μονομελής, δηλαδή εφαρμόζεται σε μία μόνο σχέση, και προσθέτει νέες εγγραφές.
Οι συμβολοσειρές περικλείονται σε εισαγωγικά, ενώ οι αριθμοί όχι.
Δεν χρειάζεται να εισάγουμε τα πεδία τύπου αυτόματης αρίθμησης.
Β01α.
Εισάγετε στον πίνακα Φοιτητες τον Κωδικο, Ονομα, Επωνυμο, πολη και εξαμηνο σας.
Αλλάξτε τις Διδακτικές μονάδες του μαθήματος της Στατιστικής από 3 σε 4. where Μαθημα = ‘Στατιστική’;
Η πράξη της ενημέρωσης (update – set – where) είναι μονομελής και αλλάζει την τιμή, ή τις τιμές των γνωρισμάτων των εγγραφών που ικανοποιούν μία ή περισσότερες λογικές συνθήκες.
Β02α.
Αλλάξτε το εξάμηνό σας σε ένα μεγαλύτερο.
Διαγράψτε το μάθημα της Στατιστικής. delete from Μαθηματα Η πράξη της διαγραφής (delete from – where –) είναι μονομελής και αφαιρεί εγγραφές που ικανοποιούν μία ή περισσότερες λογικές συνθήκες.
Προσέξτε ότι διαγράφεται ολόκληρη η εγγραφή, ή οι εγγραφές που ικανοποιούν την πρόταση where, καθώς και ότι δεν υπάρχει επαναφορά.
Παρακάτω θα δούμε όλες τις πράξεις που ξεκινούν με την πρόταση select.
Εμφανίστε το Μάθημα και τις ΔιδακτικέςΜονάδες από τον πίνακα ΜΑΘΗΜΑΤΑ. select Μαθημα, ΔιδακτικεςΜοναδες Η πράξη της προβολής (select – from) είναι μονομελής, δηλαδή εφαρμόζεται σε μία σχέση, και δημιουργεί μία καινούργια.
Η καινούργια σχέση έχει λιγότερα γνωρίσματα (πεδία) από την αρχική.
Επιλέξτε όλα τα στοιχεία των μαθημάτων που έχουν 3 διδακτικές μονάδες select * from Μαθηματα where ΔιδακτικεςΜοναδες = 3;
Η πράξη της επιλογής (select – from – where) είναι μονομελής.
Επιλέγει τις εγγραφές που ικανοποιούν που ικανοποιούν μία ή περισσότερες λογικές συνθήκες στην πρόταση where.
Οι λογικές συνθήκες συνδυάζονται με τους λογικούς τελεστές not, and, or.
Η ΠΡΟΤΑΣΗ WHERE: Τελεστές Σύγκρισης στις λογικές συνθήκες:
Επίσης οι αριθμητικοί τελεστές + - * / σε αριθμητικές εκφράσεις.
Επίσης οι τελεστές σύγκρισης Like, BetweenAnd, in, is Null.
Εμφανίστε όλα τα στοιχεία (τα πεδία) των Φοιτητών με ΚωδΦοιτητη μεγαλύτερο του 3
Εμφανίστε όλα τα στοιχεία των Φοιτητών με ΚωδΦοιτητη μικρότερο ή ίσο του 3 ταξινομημένα κατά Επωνυμο με αύξουσα σειρά
Ο αστερίσκος * στην πρόταση select προβάλει όλα τα πεδία.
Στην πρόταση from ορίζουμε τα ονόματα των πινάκων.
Στην πρόταση where γράφονται οι λογικές συνθήκες επιλογής των σειρών.
Επιλέγετε κάθε εγγραφή για την οποία η where βγαίνει αληθής.
Εμφανίστε όλα τα στοιχεία των Φοιτητών με ΚωδΦοιτητη διάφορο του 3
Εμφανίστε όλα τα στοιχεία των Φοιτητών του ‘Γ’ Εξαμηνου
Εμφανίστε τις ΕγγραφεςΜαθηματων με ΚωδΜαθηματος μεγαλύτερο ή ίσο του 3
Εμφανίστε τους Φοιτητες του Γ εξαμήνου με ΚωδΦοιτητη μεγαλύτερο ή ίσο του 3 ταξινομημένα ανά Επώνυμο με αύξουσα σειρά (τελεστής and).
Εμφανίστε τους Φοιτητες που δεν βρίσκονται στο Α ή στο Γ Εξαμηνο (τελεστές not, or).
Αλφαριθμητικό μεταβλητού μήκους (από 0 έως n), με μέγιστο μήκος n οριζόμενο από τον χρήστη.
Ακέραιος (Στη σχεδίαση πίνακα της MS Access λέγεται Ακέραιος μεγάλου μήκους) Μικρός ακέραιος, με εύρος τιμών από -32,768 έως 32,767.
Στη σχεδίαση πίνακα της MS Access λέγεται ακέραιος Πολύ μικρός ακέραιος (0 έως 255).
Στη σχεδίαση πίνακα της MS Access λέγεται Byte Πραγματικός αριθμός, απλής ακρίβειας Πραγματικός αριθμός, διπλής ακρίβειας Ημερομηνία και ώρα της μορφής Π.χ. ‘2002-10-22 09:05:32.75’
ΣΗΜΕΙΩΣΗ: Για λόγους συμβατότητας οι πίνακες και τα πεδία τους στα SQL Scripts πρέπει γενικά να γράφονται αν όχι με Αγγλικά ονόματα τουλάχιστον με αγγλικούς χαρακτήρες.
Τα Scripts θα εκτελούνται έτσι σε μία πληθώρα συστημάτων βάσεων δεδομένων όπως MS Access, MS SQL Server, Sybase, MySQL, MimerSQL, Oracle κλπ (στην Oracle ο integer είναι ο τύπος number) Η γενική σύνταξη δημιουργίας πίνακα create table Όνομα -Πίνακα ( Όνομα -πεδίου1 τύπος-δεδομένων1, Όνομα -πεδίου2 τύπος-δεδομένων2,
ALTER TABLE <όνομα πίνακα> ADD COLUMN <όνομα πεδίου> τύπος δεδομένων ALTER TABLE <όνομα πίνακα> DROP COLUMN <όνομα πεδίου> Αλλαγή τύπου δεδομένων πεδίου ALTER TABLE <όνομα πίνακα> ALTER COLUMN <όνομα πεδίου> νέος τύπος δεδομένων ALTER TABLE <όνομα πίνακα> ADD CONSTRAINT <όνομα περιορισμού> ορισμός περιορισμού ALTER TABLE <όνομα πίνακα> DROP CONSTRAINT <όνομα περιορισμού>
ΕΡΩΤΗΜΑΤΑ SQL.
Η σύνταξη ενός ερωτήματος επιλογής SQL αποτελείται από έξι προτάσεις: SELECT [ DISTINCT ] ονόματα πεδίων, αριθμητικών εκφράσεων, ή και συναθροιστικές συναρτήσεις ονόματα πινάκων ή και συνθήκες σύζευξης μεταξύ τους συνθήκες επιλογής ή και συνθήκες σύζευξης σε πεδία και αριθμητικές εκφράσεις] ονόματα πεδίων σύμφωνα με τα οποία θα γίνει ομαδοποίηση ] συνθήκες περιορισμού των γραμμών που επιστρέφονται μετά από μία ομαδοποίηση ] ονόματα πεδίων σύμφωνα με τα οποία θα γίνει ταξινόμηση] Μια επερώτηση αποτιμάται πρώτα με την εφαρμογή της WHERE πρότασης, μετά των GROUP-BY και HAVING (προαιρετικά), και τέλος της SELECT πρότασης– με ταξινόμηση των σειρών στην απάντηση αν απαιτείται από την πρόταση ORDER BY ή διαγραφή διπλών τιμών με το DISTINCT (προαιρετικά).
Να γίνει ερώτημα που να εμφανίζει ποιοι Φοιτητες του Γ εξαμήνου με ΚωδΦοιτητη μεταξύ 3 και 6 είναι από την Περιοχή Αττικής ταξινομημένα ανά Επώνυμο με αύξουσα σειρά.
ΚωδΦοιτητη >= 3 and ΚωδΦοιτητη <= 6 and [Νομος/Περιοχη]="Αττική" Οι αγκύλες [ ] χρησιμοποιούνται για να περικλείσουν ονόματα πεδίων όταν αυτά περιέχουν σύμβολα ή κενά (στην MS Access και MS SQL Server).
Οι απλές λογικές συνθήκες σύγκρισης μπορούν να συνδυαστούν δημιουργώντας μία σύνθετη λογική έκφραση χρησιμοποιώντας τους λογικούς τελεστές not, and, or στην πρόταση where (το κατηγόρημα).
Η σειρά των λογικών πράξεων είναι πρώτα η άρνηση (τα not), έπειτα η σύζευξη (τα and) και τέλος η διάζευξη (or).
Με παρενθέσεις αλλάζει η σειρά.
Ποιοι Φοιτητες βρίσκονται στο Α ή στο Γ Εξαμηνο (τελεστής OR στα κριτήρια).
Ποιοι Φοιτητες δεν βρίσκονται στο Α ή στο Γ Εξαμηνο (τελεστές NOT, OR).
Ποιοι Φοιτητες εκτός του Α ή Β εξαμήνου μένουν στην Πολη = ‘Αθήνα’ Εκτός από τους τελεστές συγκρίσεων = , < , <= , <> , > , >= , η γλώσσα SQL περιλαμβάνει και άλλους τελεστές που χρησιμοποιούνται σε συνθήκες συγκρίσεις και λογικές εκφράσεις.
Περιλαμβάνει εγγραφές με τιμή πεδίου εντός της ορισμένης κλίμακας Αποκλείει εγγραφές με τιμή πεδίου εντός της ορισμένης κλίμακας Περιλαμβάνει εγγραφές με πεδίο συμβολοσειράς που να ταιριάζει στον τύπο Αποκλείει εγγραφές με πεδίο συμβολοσειράς που να ταιριάζει στον τύπο Περιλαμβάνει εγγραφές με τιμή πεδίου που περιέχετε σε ορισμένη λίστα Αποκλείει εγγραφές με τιμή πεδίου που περιέχετε σε ορισμένη λίστα
Αποκλείει εγγραφές με τιμή κενή (null) στο πεδίο σύγκρισης
Βρείτε τους Φοιτητες με ΚωδΦοιτητη μεταξύ 3 και 6
ΚωδΦοιτητη between 3 and 6 Βρείτε τους Φοιτητες με Επωνυμο που αρχίζει από Π
Η σύγκριση με συμβολοσειρές γίνεται χρησιμοποιώντας το Like, not Like.
Ο αστερίσκος * (ή το ποσοστό % στον SQL Server) αντιστοιχεί σε οποιαδήποτε συμβολοσειρά.
Το ερωτηματικό ? (ή το _) αντιστοιχεί σε οποιαδήποτε χαρακτήρα.
Τα εισαγωγικά “ ” χρησιμοποιούνται για να περικλείσουν μια συμβολοσειρά.
Ποιοι Φοιτητες βρίσκονται στο Α ή στο Γ Εξαμηνο
Βρείτε αν υπάρχει Φοιτητής που έχει κενή τιμή στο Τηλεφωνο (δεν έχει δώσει Τηλεφωνο).
Αν δεν υπάρχει η παρακάτω δήλωση SQL δεν θα επιστρέψει τίποτα.
Όλα τα στοιχεία Φοιτητών από την Δελοπούλου μέχρι και τον Νάκη (Between "Δελοπούλου" And "Νάκης" στα κριτήρια) Ο τελεστής Between And , χρησιμοποιείται σε κάθε διατεταγμένο σύνολο.
Όλα τα στοιχεία Φοιτητών με κωδικούς 1 ή 3 ή 4 ή 7 (χρήση του in(1, 3, 4, 7) ) Ο τελεστής in (not in) ελέγχει αν μία τιμή ανήκει (ή όχι) σε ένα σύνολο από τιμές.
Τα στοιχεία των Καθηγητών με Επώνυμο που αρχίζει από M (τελεστής Like στα κριτήρια)
Τα στοιχεία των Καθηγητών που έχουν κενή τιμή στο πεδίο τηλέφωνο (τελεστής is Null)
Τα στοιχεία των Καθηγητών που έχουν τηλέφωνο (is not Null) αλλά όχι εσωτερικο (is Null) Είναι πιθανό για τις γραμμές ενός πίνακα να έχουν τιμή null (κενή τιμή) σε κάποιο πεδίο.
Μία κενή τιμή είναι μία ειδική σταθερά που αναπαριστά μία τιμή που δεν υπάρχει ή είναι άγνωστη.
Null τιμές εμφανίζονται και στην εξωτερική σύζευξη δύο πινάκων.
Το αποτέλεσμα σύγκρισης με μια τιμή null είναι unknown (ούτε true, ούτε false).
Επίσης το αποτέλεσμα οποιασδήποτε αριθμητικής έκφρασης είναι null όταν κάποια τιμή που περιλαμβάνει είναι null.
Τότε η πρόταση where βγαίνει false και η σειρά δεν επιλέγεται.
Ο τελεστής is null (is not null) μπορεί να χρησιμοποιηθεί σε μια συνθήκη για να ελέγξουμε αν μια τιμή είναι null και να ανακτήσουμε την αντίστοιχη σειρά.
Βρείτε τα στοιχεία των Φοιτητών του Β ή Γ εξαμήνου, με κωδικούς από 3 μέχρι και 7, στην Πόλη της Αθήνας και Επώνυμο που αρχίζει από Π (τελεστές Between..And, Like, in).
Βρείτε τα στοιχεία των Φοιτητών που δεν είναι στο Β ή Γ εξάμηνο (not in (‘Β’;’Γ’)), που δεν έχουν κωδικούς από 3 μέχρι και 7 και μένουν σε Πόλεις εκτός της Αθήνας και έχουν Επώνυμο που δεν αρχίζει από το γράμμα Π (Στην πρόταση WHERE o τελεστής NOT εισάγεται είτε μπροστά από κάθε τελεστή είτε μπροστά από κάθε συνθήκη σύγκρισης).
Στα προηγούμενα παραδείγματα τα ερωτήματα ανάκλησης δεδομένων ήταν σε έναν πίνακα.
Η χρήση περισσότερων πινάκων αντιστοιχεί στην σύζευξη που είναι σύνθετη πράξη δηλαδή ορίζεται από μία Προβολή, ένα Καρτεσιανό γινόμενο και μία Επιλογή των σειρών που ικανοποιούν τη συνθήκη σύζευξης (τα κοινά πεδία ίσα -αφού δύο πίνακες συνδέονται μεταξύ τους με κοινά πεδία τιμών).
Επιστρέφει στο αποτέλεσμα τα γνωρίσματα (πεδία) και των δύο αρχικών, και τις εγγραφές στις οποίες οι τιμές του κοινού πεδίου σύμφωνα με το οποίο γίνεται η σύζευξη είναι ίσες (εσωτερική σύζευξη).
ΣΥΖΕΥΞΗ.
Εμφανίστε τα Επωνυμο, Ονομα και τους τελικούς βαθμούς των Φοιτητών (τα πεδία Επωνυμο και Ονομα βρίσκονται στον πίνακα Φοιτητες και το πεδίο ΤελικοςΒαθμος βρίσκεται στον πίνακα ΕγγραφεςΜαθηματων) Επωνυμο, Ονομα, ΤελικοςΒαθμος
Φοιτητες.ΚωδΦοιτητη = ΕγγραφεςΜαθηματων.ΚωδΦοιτητη
Η σύζευξη εμφάνισε τον Τελικό Βαθμό και δίπλα από τα Επωνυμο και Ονομα Φοιτητή.
Αυτά είναι τα πραγματικά δεδομένα της βάσης.
Αυτός ο τύπος σύζευξης ονομάζεται εσωτερική σύζευξη (inner join) δύο πινάκων.
Η σύζευξη έχει έτσι και δικό της τελεστή ‘join’.
Υπάρχουν τέσσερις τύποι σύζευξης: εσωτερική (όπως η παραπάνω), αριστερή, δεξιά και πλήρης.
Συντάσετε εύκολα ερωτήματα σύζευξης πινάκων αν βλέπετε το διάγραμμα της βάσης δεδομένων.
Ποια Μαθήματα διδάχθηκαν το ΕτοςΔιδασκαλιας 2001 (σύζευξη δύο πίνακες)
Εμφανίστε τα Επωνυμο, Ονομα από τους Καθηγητες το ΕτοςΔιδασκαλιας από τις ΔιδασκαλιεςΜαθηματων τους και το Μαθημα από τα Μαθηματα τους (σύζευξη τρεις πίνακες)
Ποιοι Καθηγητές έχουν διδάξει το μάθημα ‘Αγγλικά’ ή το μάθημα ‘Ηλεκτρονικά’ το ΕτοςΔιδασκαλιας 2001 (σύζευξη τρεις πίνακες)
Εμφανίστε τα Επωνυμο, Ονομα το πεδίο Μαθημα και τους τελικούς βαθμούς των Φοιτητών (τα πεδία Επωνυμο και Ονομα βρίσκονται στον πίνακα Φοιτητες, το πεδίο Μαθημα βρίσκεται στον πίνακα Μαθηματα και το ΤελικοςΒαθμος βρίσκεται στον πίνακα ΕγγραφεςΜαθηματων) Επωνυμο, Ονομα, Μαθημα, ΤελικοςΒαθμος Φοιτητες , Μαθηματα, ΕγγραφεςΜαθηματων Μαθηματα.ΚωδΜαθηματος = ΕγγραφεςΜαθηματων.ΚωδΜαθηματος and Φοιτητες.ΚωδΦοιτητη = ΕγγραφεςΜαθηματων.ΚωδΦοιτητη Δίχως τις δύο συνθήκες σύζευξης στην πρόταση where εμφανίζεται το καρτεσιανό γινόμενο.
Εμφανίστε τα ΚωδΦοιτητή, Όνομα και Επώνυμο των Φοιτητών που πέρασαν το Μάθημα ‘Αγγλικά’ (σύζευξη τρεις πίνακες) Δ7ΗΛΕΚΤΡΟΝΙΚΑ.
Εμφανίστε τα ΚωδΦοιτητή, Όνομα και Επώνυμο των Φοιτητών που πέρασαν το Μάθημα ‘Ηλεκτρονικά’ (σύζευξη τρεις πίνακες)
Από τη θεωρία συνόλων η ένωση (union) παίρνει δυο σχέσεις (σύνολα) Α και Β, και δημιουργεί μία καινούργια.
Ωστόσο στις δύο αρχικές υπάρχει ένας περιορισμός: πρέπει να είναι συμβατές, δηλαδή να έχουν τα ίδια γνωρίσματα (πεδία).
Η καινούργια σχέση έχει τις εγγραφές που περιέχονται είτε στην πρώτη σχέση Α, είτε στη δεύτερη Β, είτε και στις δύο.
Εμφανίστε τα ΚωδΦοιτητη, Ονομα και Επωνυμο των Φοιτητών που πέρασαν είτε τα ‘Αγγλικά’, είτε τα ‘Ηλεκτρονικά’, είτε και τα δύο.
Προσέξτε ότι ένωσε τα στοιχεία των δύο συνόλων και διατήρησε στο αποτέλεσμα μόνο τις μοναδικές εγγραφές (όχι δύο φορές την ίδια εγγραφή).
Για την τήρηση διπλοτύπων χρησιμοποιείται η union all.
Τα σύνολα περικλείονται με παρενθέσεις για λόγους ευκρίνειας.
Δ08α.
Εμφανίστε τα Όνομα και Επώνυμο των Καθηγητών και των Φοιτητών σε ενιαία λίστα Από τη θεωρία συνόλων η πράξη της τομής είναι διμελής, δηλαδή παίρνει δυο σχέσεις (σύνολα) Α και Β, και δημιουργεί μία καινούργια.
Πάλι οι δύο αρχικές σχέσεις πρέπει να είναι συμβατές.
Η καινούργια σχέση έχει τις εγγραφές που περιέχονται και στην πρώτη σχέση Α, και στη δεύτερη Β.
Εμφανίστε τα ΚωδΦοιτητη, Ονομα και Επωνυμο των Φοιτητών που έχουν περάσει και τα ‘Αγγλικά’ και τα ‘Ηλεκτρονικά’ (δηλαδή αυτούς που υπάρχουν και στην Δ6ΑΓΓΛΙΚΑ και στην Δ7ΗΛΕΚΤΡΟΝΙΚΑ) (select ΚωδΦοιτητη from Δ7ΗΛΕΚΤΡΟΝΙΚΑ);
Η διαφορά δύο σχέσεων έχει τις εγγραφές που περιέχονται στην πρώτη σχέση Α, αλλά όχι στη δεύτερη Β.
Αυτό σημαίνει ότι το αποτέλεσμα της Α – B δεν είναι ίδιο με το αποτέλεσμα της Β – Α.
Εμφανίστε τα ΚωδΦοιτητη, Ονομα και Επωνυμο των Φοιτητών που έχουν περάσει τα ‘Αγγλικά’ αλλά όχι τα ‘Ηλεκτρονικά’ (στο ερώτημα Δ09 θα αντικαταστήσετε το in με not in).) Στον SQL Server αντιγράψτε τα αρχεία Bookstore_Data.mdf και Bookstore_Log.ldf από τον φάκελο Data στον φάκελό σας Για να κάνεται προσάρτηση αυτών των αρχείων ως τη δικιά σας βάση Bookstore από τον Enterprise Manager : δεξί κλικ στο εικονίδιο Databases και All tasks->Attach Database και επιλέγετε το MDF file από τον φάκελό σας W:\database\Baseis_1\...
Έπειτα ανοίγετε τη βάση Bookstore, επιλέγετε Diagrams (διαγράμματα) και δεξί κλικ και New Database Diagram.
Στον wizard κάνετε Add τους πίνακες της βάσης Bookstore (όχι τους-sys-) στο διάγραμμα και σέρνετε τα πρωτεύοντα κλειδιά στα αντίστοιχα ξένα.
ΝΑ ΕΙΣΑΓΕΤΕ ΑΠΟ ΜΙΑ ΕΓΓΡΑΦΗ ΣΤΑ ΒΙΒΛΙΑ ΚΑΙ ΤΟΥΣ ΠΕΛΑΤΕΣ (προσέχετε τις τιμές των ξένων κλειδιών): επιλέξτε Tables και ανοίγετε έναν πίνακα με δεξί κλικ και Open Table->Return all raws.
Περιορισμός αναφορικής ακεραιότητας των ξένων κλειδιών σημαίνει ότι κάθε τιμή ξένου κλειδιού που καταχωρείται θα πρέπει να ελέγχεται εάν υπάρχει σαν τιμή πρωτεύοντος κλειδιού στον συσχετιζόμενο πίνακα.
Αν δεν υπάρχει τότε η βάση (ή ο driver) θα στείλει μία εξαίρεση (Exception).
Στην MSAccess αφού αντιγράψετε το αρχείο Bookstore.mdb στον φάκελό σας και το ανοίξετε επιλέξτε Εργαλεία-Σχέσεις.
Έπειτα Εμφάνιση πίνακα και προσθήκη τους Πίνακες και σύρετε τα πρωτεύοντα κλειδιά στα αντίστοιχα ξένα με Ενεργοποίηση Ακεραιότητας αναφορών.
Ο Enterprise Manager είναι το κύριο διαχειριστικό εργαλείο των βάσεων δεδομένων του SQL Server.
Επιλέγοντας τον εγγεγραμμένο server (στην περίπτωση μας ο LOCAL), εμφανίζονται τα αντικείμενα από τα οποία αποτελείται.
Για να δημιουργήσετε μία νέα βάση επιλέξτε Δεξί κλικ στο “Databases” και “New Database”.
Κάθε βάση δεδομένων έχει δυο κύρια αρχεία, το αρχείο δεδομένων (με επέκταση “.MDF”) και το αρχείο ημερολογίου συναλλαγών (με επέκταση “.LDF” ).
Αντιγράψτε πρώτα τα αρχεία Bookstore_Data.mdf και Bookstore_Log.ldf στον φάκελό σας.
Για να κάνετε προσάρτηση της δικιά σας βάσης Bookstore επιλέξτε το πράσινο βελάκι και έπειτα δεξί κλικ στο εικονίδιο Databases και All tasks->Attach Database και επιλέξετε το αρχείο Bookstore_Data.mdf από τον φάκελό σας W:\database\Baseis_1\...
Αν αυτή η βάση είναι ήδη προσαρτημένη μπορείτε να κάνετε πρώτα Detach Database.
Επειτα ανοίγετε τον SQL Query Analyzer.
Προσέχετε η επιλεγμένη βάση να είναι η Bookstore συντάσσετε το κάθε ένα ερώτημα SQL το εκτελείτε με το πράσινο play κουμπί στην μπάρα εργαλείων ή to F5 και το αποθηκεύετε στον φάκελό σας (File->Save As) ως αρχείο με κατάληξη .sql.
ΝΑ ΑΠΟΘΗΚΕΥΤΟΥΝ ΤΑ ΠΑΡΑΚΑΤΩ ΕΡΩΤΗΜΑΤΑ SQL . (Στην MSAccess από τον SQL Editor.
Στον MS SQL Server από τον Query Analyzer συνδέεστε στη βάση, συντάσσετε το κάθε ένα ερώτημα SQL το εκτελείτε με execute ή F5 και το αποθηκεύετε στον φάκελό σας ως αρχείο με κατάληξη .sql.
Στην Oracle από το SQL*Plus WorkSheet)
Βρείτε όλα τα στοιχεία των Βιβλίων με τιμή ίση με 2500
Βρείτε όλα τα στοιχεία των Βιβλίων με Γλωσσα = ‘Ελληνική’ Εμφανίστε τα πεδία ΚωδΠελατη, Επωνυμο, Ονομα, Διευθυνση από τον πίνακα ΠΕΛΑΤΕΣ ταξινομημένα πρώτα κατά Επωνυμο με αύξουσα σειρά και έπειτα κατά Ονομα με φθίνουσα σειρά.
ΚωδΠελατη, Επωνυμο, Ονομα, Διευθυνση order by Επωνυμο, Ονομα desc; (Η ταξινόμηση –order by- γίνεται πάντα τελευταία.
Δεν είναι σχεσιακή πράξη δηλώνει απλά ότι η σειρά εμφάνισης των εγγραφών στο τελικό αποτέλεσμα θα είναι αύξουσα asc ως προς το πεδίο Επωνυμο -προεπιλογή και το asc μπορεί να παραλείπεται- και φθίνουσα desc ως προς το Ονομα) Εμφανίστε ΚωδΒιβλιου και Τιμη αυξημένη κατά 40%. select ΚωδΒιβλιου, Τιμη + Τιμη * 40/100 as [Τιμή πώλησης] Το as είναι ο τελεστής μετονομασίας.
Οι αγκύλες [ ] χρησιμοποιούνται για να περικλείσουν ονόματα πεδίων όταν αυτά περιέχουν κενό διάστημα ή σύμβολα, (μόνο στην MS Access και MS SQL Server- στις Oracle, MySQL χρησιμοποιούνται τα μονά εισαγωγικά ' ' για να περικλείσουν ονόματα).
Οι γνωστοί αριθμητικοί τελεστές + - * / χρησιμοποιούνται σε αριθμητικές εκφράσεις.
Εμφανίστε Επωνυμο και Ονομα Πελατών σε ενιαίο πεδίο Επωνυμο + '-' + Ονομα as Ονοματεπωνυμο Προσέξτε ότι εδώ το + χρησιμοποιείται σαν τελεστής συννένωσης πεδίων κειμένου (όπως η συνάρτηση concat στη γλώσσα C).
Στην C++ είναι ο ίδιος τελεστής + που χρησιμοποιείται για συννένωση αλφαριθμητικών.
Παρατηρείστε όμως εδώ ότι για συγκεκριμένες σειρές θα επιστρέψει κενό (NULL) στο αποτέλεσμα.
Είναι αυτοί οι πελάτες που έχουν κενή τιμή στο πεδίο Ονομα.
Οι απλές λογικές συνθήκες σύγκρισης μπορούν να συνδυαστούν δημιουργώντας μία σύνθετη λογική έκφραση χρησιμοποιώντας τους λογικούς τελεστές not , and , or στην πρόταση where.
Η σειρά των λογικών πράξεων είναι πρώτα η άρνηση (τα not), έπειτα η σύζευξη (τα and) και τέλος η διάζευξη (τα or).
Με παρενθέσεις αλλάζει η σειρά τους.
Βρείτε τα βιβλία με έτος έκδοσης μεταξύ 1991 και 1994 που έχουν περισσότερες από 500 σελίδες, τιμή μικρότερη από ή ίση με 4500 και είναι γραμμένα σε γλώσσα διάφορη του Αγγλικά (χρηση του and).
Εμφανίστε όλα τα στοιχεία των βιβλίων με έτος έκδοσης το 1991 ή το 1994 ή το 1997 (χρήση του or) Εμφανίστε όλα τα στοιχεία των βιβλίων με έτος έκδοσης εκτός των 1991 , 1994 , 1997.(χρήση των or , not) Βρείτε όλα τα στοιχεία των βιβλίων που έχουν πάνω από 500 Σελίδες και Τιμή μικρότερη του 4500 και είναι γραμμένα σε Γλώσσα διάφορη του Αγγλικά, ή αυτών των βιβλίων που δεν έχουν έτος έκδοσης μεταξύ 1991 και 1994, ταξινομημένα κατά Τίτλο. (με σύνθεση των τελεστών not, and, or) Επιτρέπουν να αναφερθούμε σε μια σχέση (πίνακα) με περισσότερα από ένα ονόματα (ψευδώνυμα πίνακα).
Μπορούμε σε ένα ερώτημα να χρησιμοποιούμε τέτοιες μεταβλητές εγγραφών ορίζοντάς τες στην πρόταση FROM.
Μπορούμε ακόμη με αυτές τις μεταβλητές να χρησιμοποιήσουμε τον ίδιο πίνακα δύο φορές σε ένα ερώτημα (συγκρίνοντας κάθε μία με όλες τις εγγραφές του).
ΜΕΤΟΝΟΜΑΣΙΑ Βρείτε όλες τις τιμές των βιβλίων εκτός από την μεγαλύτερη
Δείτε το αποτέλεσμα του παραπάνω ερωτήματος.
Η στήλη β1.Τιμη θα πρέπει να έχει όλες τις τιμές εκτός από την μεγαλύτερη.
Γενικά, η SQL έχει σχεδιαστεί κατά τρόπο ώστε τα ερωτήματα να εκτελούνται βάσει μεταβλητών εγγραφών (ψευδώνυμα πίνακα).
Αν δεν προσδιορίζονται τότε η SQL υποθέτει την ύπαρξη ψευδωνύμων πίνακα που ταυτίζονται με τα ονόματα των αντίστοιχων πινάκων.
Για παράδειγμα το ερώτημα select εκτελείται από την SQL σαν να είχε διατυπωθεί όπως παρακάτω
Περιλαμβάνει εγγραφές με τιμή κενή (null) στο πεδίο σύγκρισης
Βρείτε τα βιβλία με ΕτοςΕκδοσης μεταξύ 1991 και 1994 (χρήση του between and) Βρείτε τα βιβλία με Τιτλο που αρχίζει από Α (με χρήση του like) Το ταίριασμα συμβολοσειρών χρησιμοποιώντας το Like, not Like.
Ο αστερίσκος * στην Ms Access (ή το ποσοστό % στον SQL Server και Oracle) αντιστοιχεί σε οποιαδήποτε συμβολοσειρά.
Βρείτε τα βιβλία που έχουν ΕτοςΕκδοσης ή το 1991 ή το 1994 ή το 1997 (με χρήση του in())
Βρείτε τα στοιχεία των πελατών που έχουν κενή τιμή στο πεδίο Ονομα (χρήση is null)
Βρείτε τους πελάτες σε χώρα την Ελλάδα που δεν έχουν κενό το πεδίο ΑΦΜ και έχουν επώνυμο που αρχίζει από Α ή Γ αποκλείοντας αυτούς με Κωδικό πελάτη μεταξύ 1 και 12.
ΣΥΖΕΥΞΗ.
Εμφανίστε όλα τα στοιχεία των βιβλίων με Εκδότη με Επωνυμια = ‘Κλειδάριθμος’ ταξινομημένα κατά τιτλο ΒΙΒΛΙΑ.*, ΕΚΔΟΤΕΣ.Επωνυμια ΒΙΒΛΙΑ.ΚωδΕκδοτη = ΕΚΔΟΤΕΣ.ΚωδΕκδοτη and Επωνυμια = ‘Κλειδάριθμος’
Εμφανίστε τα στοιχεία των βιβλίων της κατηγοριας με ΟνομαΚατηγοριας ‘Αστυνομικά’ ταξινομημένα κατά Τιτλο με αύξουσα σειρά (σύζευξη δύο πίνακες –βιβλια με κατηγοριες)
Εμφανίστε όλα τα στοιχεία των βιβλίων του συγγραφεα με ονοματεπωνυμο = ‘Βερν Ιούλιος’ (σύζευξη δύο πίνακες –βιβλια με συγγραφείς) Η συναθροιστική πράξη της σχεσιακής άλγεβρας (πράξη σύνοψης) παίρνει ένα σύνολο τιμών μιας στήλης και επιστρέφει μία μεμονωμένη τιμή ως αποτέλεσμα.
Η SQL έχει 5 κύριες συναθροιστικές συναρτήσεις (max, min, avg, count, sum).
Την Ελάχιστη, Μέγιστη και Μέση Τιμη όλων των Βιβλίων select min(Τιμη) as Ελαχιστη_Τιμη, max(Τιμη) as Μεγιστη_Τιμη, avg(Τιμη) as Μεση_Τιμη το as είναι ο τελεστής μετονομασίας.
Στην πρόταση select ορίζει ψευδώνυμα.
Πρέπει όμως να επαναλάβετε τη συνάρτηση γιατί δεν μπορείτε να χρησιμοποιήσετε το ψευδώνυμο.
Την Μέγιστη Τιμη των Βιβλίων με ΕτοςΕκδοσης = 1985
Πόσα Βιβλία υπάρχουν (η συνάρτηση count επιστρέφει το πλήθος εγγραφών) select count(*) as Πληθος
Την μέση τιμη των βιβλιων ανα ΕτοςΕκδοσης, ταξινομημενα ανα μέση τιμη select ΕτοςΕκδοσης, avg(Τιμη) as ΜεσηΤιμη order by avg(Τιμη);
Μπορούμε να εφαρμόσουμε τις συναθροιστικές συναρτήσεις όχι μόνο σε ένα σύνολο, αλλά και σε ομάδες (υποσύνολα του αρχικού συνόλου).
Οι ομάδες προσδιορίζονται χρησιμοποιώντας την πρόταση group by Όνομα-πεδίου.
Επιστρέφεται μια τιμή για κάθε ομάδα. (Ομάδα = οι σειρές με ίδια τιμή στο πεδίο ομαδοποίησης) Η πρόταση group by δημιουργεί υποομάδες εγγραφών σύμφωνα με κάποιο κοινό γνώρισμα και οι συναθροιστικές συναρτήσεις εφαρμόζονται σε κάθε τέτοια υποομάδα.
Η τελευταία πρόταση, order by, κάνει ταξινόμηση του τελικού αποτελέσματος
Μπορείτε να αποθηκεύσετε ένα ερώτημα SQL σαν προβολή (view) όπως παρακάτω: SELECT Κωδικος, Επωνυμο, Ονομα FROM dbo.Εργαζομενοι;
Μπορείτε να αποθηκεύσετε ένα ερώτημα SQL ως αποθηκευμένη διαδικασία (store procedure) όπως παρακάτω:
SELECT Κωδικος, Επωνυμο FROM dbo.Εργαζομενοι;
Να δημιουργηθεί η βάση δεδομένων με τους παρακάτω πίνακες Τ1. create table ΕΡΓΑΖΟΜΕΝΟΙ ( constraint PK_Εργαζομενοι primary key (Κωδικος) );
Τ2. create table ΤΜΗΜΑΤΑ ( constraint PK_Τμηματα primary key (ΚωδΤμηματος) ); και στην καρτέλα General δίνετε ένα όνομα για τη βάση δεδομένων (για παράδειγμα db1_TRITH6_9_EPONYMO δηλαδή το τμήμα εργαστηρίου και το επώνυμο σας).
Στην καρτέλα Data Files μπορείτε να δείτε ότι το πρωτεύον αρχείο δεδομένων δημιουργείται αυτόματα και του δίνεται το όνομα της βάσης δεδομένων σας ως πρόθεμα.
Το πρωτεύον αρχείο δεδομένων έχει .mdf επέκταση.
Επιλέξτε το εικονίδιο Location και αλλάξτε το επιλέγοντας τον δικό σας κατάλογο ως το χώρο αποθήκευσής του.
Στην καρτέλα Transaction Log μπορείτε να δείτε πληροφορίες για το αρχείο ημερολογίου συναλλαγών.
Περιέχει μια εγγραφή με όλες τις μεταβολές της βάσης δεδομένων για δυνατότητα ανάνηψης σε περίπτωση βλάβης του συστήματος.
Το πρώτο transaction log αρχείο δημιουργείται αυτόματα και παίρνει το όνομα της βάσης για πρόθεμα και έχει επέκταση .ldf.
Επιλέξτε το εικονίδιο Location και αλλάξτε το επιλέγοντας τον δικό σας κατάλογο ως το χώρο αποθήκευσής του.
Αλλιώς μπορείτε ανοίγοντας τον SQL Query Analyzerνα χρησιμοποιήσετε την εντολή CREATE DATABASE όνομα_βάσης όπως το παρακάτω παράδειγμα:
Από τον Query Analyzer συνδέεστε στη δικιά σας βάση και αφού τρέξετε μία φορά το EmployeeDataScript.sql για τη φόρτωση των δεδομένων, συντάσσετε το κάθε ένα ερώτημα SQL το εκτελείτε με execute ή F5 και το αποθηκεύετε στον φάκελό σας.
Να δημιουργηθεί ερώτημα που να προβάλει Επωνυμο, Ονομα, Θεση των εργαζομένων με ΚωδΤμηματος=2 ταξινομημένα κατά Επωνυμο με αύξουσα σειρά (order by Επωνυμο asc, επειδή η προεπιλογή είναι αύξουσα –ascending order- το asc είναι προαιρετικό) Επωνυμο, Ονομα , Θεση (Στην πρόταση where γράφουμε τις λογικές συνθήκες με τις οποίες θα επιλεγούν οι σειρές) Εμφανίστε Θεση, Ονομα και Επωνυμο από τον πίνακα Εργαζομενοι με φθίνουσα ταξινόμηση (descending order) στο πεδίο Θεση και αύξουσα ταξινόμηση στο πεδίο Επωνυμο (order by Θεση desc, Επωνυμο;)
Τα Επωνυμο, Ονομα των εργαζομένων με Προισταμενος = 17
Εμφανίστε όλα τα στοιχεία των Πωλητών ( όπου Θεση=’Πωλητής’)
Εμφανίστε όλα τα στοιχεία των εργαζομένων στα Τμήματα με ΚωδΤμηματος 2 ή 4 αλλιώς μπορούμε να χρησιμοποιήσουμε την πρόταση where ΚωδΤμηματος in (2, 4);
Όλα τα στοιχεία των εργαζομένων εκτός των τμημάτων 2 ή 4 (χρήση του not in (2, 4); )
Το Επωνυμο, Ονομα των εργαζομένων με ΚωδΤμηματος 2 και Θεση ‘Δ/ντής’ ή ‘Πωλητής’ και μισθό μεγαλύτερο από 1000 και προμήθεια μεγαλύτερη από 400
Το Επωνυμο, Ονομα των εργαζομένων που δεν παίρνουν προμήθεια ταξινομημένα κατά Επωνυμο (χρήση του is null στο πεδίο Προμηθεια)
Το Επωνυμο, Ονομα , ΗμΠροσληψης των εργαζομένων που προσλήφθηκαν μέσα στην χρονική περίοδο από 1/1/1984 μέχρι και 1/1/1990 (χρήση του Between ...And...)
Τα Επωνυμο, Ονομα των εργαζομένων με Ονομα που αρχίζει από Γ (χρήση του Like) Το ταίριασμα συμβολοσειρών χρησιμοποιώντας το Like, not Like.
Ο αστερίσκος * στην Ms Access (ή το ποσοστό % στον SQL Server) αντιστοιχεί σε οποιαδήποτε συμβολοσειρά.
Το ερωτηματικό ? (ή το _) αντιστοιχεί σε οποιαδήποτε χαρακτήρα.
Ο ελάχιστος Μισθός όλων των εργαζομένων min(Μισθος) as Ελαχιστος_Μισθος
Το as είναι ο τελεστής μετονομασίας.
Στο select ορίζει ψευδώνυμα.
Ο ελάχιστος μισθός των εργαζομένων στο τμήμα με κωδικο 2 (συνδυασμός Β01 και Α01)
Ο ελάχιστος, ο μέγιστος και ο μέσος μισθός όλων των εργαζομένων min(Μισθος) as Ελαχιστος_Μισθος, max(Μισθος) as Μεγιστος_Μισθος, avg(Μισθος) as Μεσος_Μισθός
Ο ελάχιστος και ο μέγιστος μισθός κάθε Θέσης εργασίας min(Μισθος) as Ελαχιστος_Μισθος, max(Μισθος) as Μεγιστος_Μισθος
Η πρόταση group by δημιουργεί υποομάδες εγγραφών σύμφωνα με κάποιο κοινό γνώρισμα και οι συναθροιστικές συναρτήσεις εφαρμόζονται σε κάθε τέτοια υποομάδα.
Πόσοι Εργαζομενοι υπάρχουν καταχωρημένοι (μετράμε όλες τις σειρές) count(*) as Πληθος_Εργαζομενων
Πόσοι Πωλητές υπάρχουν (συνδυασμός Β05 και Α04)
Πόσα πληρώνουμε συνολικά για μισθούς των εργαζομένων sum(Μισθος) as Αθροισμα_Μισθων
Ποια η διαφορά του μέγιστου από τον ελάχιστο μισθό max(Μισθος) - min(Μισθος) as Διαφορα
Πόσοι Εργαζομενοι υπάρχουν σε κάθε Θεση εργασίας (ομαδοποίηση ανα Θεση) Θεση, count(Θεση) as Πληθος_Εργαζομενων (Η πρόταση group by δημιουργεί υποομάδες εγγραφών σύμφωνα με κάποιο γνώρισμα) Πόσοι Εργαζομενοι υπάρχουν σε κάθε Τμήμα (στο Β09 θέτουμε όπου Θεση το ΚωδΤμηματος) Ποιες θέσεις έχουν περισσότερους από έναν εργαζόμενους (στο Β09 προσθέτουμε την πρόταση having count(Θεση) >1 )
Βρείτε τους ΚωδΤμηματος για τα οποία το πλήθος Εργαζομένων εκτός από αυτούς που δεν έχουν Προμήθεια (Προμηθεια Is not null) είναι μεγαλύτερο ή ίσο με 2 (count(Επωνυμο)>=2), ταξινομημένα κατά ΚωδΤμηματος (Συμπληρώστε το παρακάτω)
( αν υπάρχει όνομα πεδίου στο select πρέπει να γραφεί και στο group by και η σύγκριση με count δεν γράφεται στο where , όσο και αν αυτό φαίνεται αρχικά σωστό, επειδή προυποθέτει ομαδοποίηση –δηλαδή group by- και έπειτα περιορισμό των αποτελεσμάτων, άρα πρόταση having)
Διορθώστε το παρακάτω ερώτημα (δείτε το μήνυμα σφάλματος) Προισταμενος, max(Μισθος) as Μεγιστος_Μισθος
Διορθώστε το παρακάτω ερώτημα (δείτε τα μηνύματα σφάλματος) Θεση, count(Θεση) as Πληθος_Εργαζομενων
Η σύνταξη ενός ερωτήματος SQL αποτελείται από έξι προτάσεις με την παρακάτω σειρά: select [ distinct ] ονόματα πεδίων, εκφράσεων, ή και συναθροιστικές συναρτήσεις
Μια επερώτηση αποτιμάται πρώτα με την εφαρμογή της where πρότασης, μετά των group by και having (προαιρετικά), και τέλος της select πρότασης – με ταξινόμηση των σειρών στην απάντηση από την order by πρόταση ή διαγραφή διπλών τιμών με το distinct.
Οι group by και having χρησιμοποιούνται μόνο με συναθροιστικές συναρτήσεις.
Τελεστές Σύγκρισης Στις Λογικές Συνθήκες των προτάσεων Where και Having :
Επίσης οι τελεστές Like, BetweenAnd, in, is Null.
Τα αποτελέσματα των συγκρίσεων μπορούν να συνδυαστούν χρησιμοποιώντας τους λογικούς τελεστές not , and , or..
Τα εισαγωγικά “ ” χρησιμοποιούνται για συγκρίσεις με συμβολοσειρές (κείμενο).
ΕΞΗΓΗΣΕΙΣ Συναθροιστικές Συναρτήσεις Η συναθροιστική πράξη της σχεσιακής άλγεβρας (πράξη σύνοψης) παίρνει ένα σύνολο τιμών και επιστρέφει μια μεμονωμένη τιμή ως αποτέλεσμα.
Η SQL έχει 5 built-in συναθροιστικές συναρτήσεις που εφαρμόζονται στο σύνολο των τιμών μιας στήλης ενός πίνακα (σχέση), και επιστρέφουν μία τιμή: avg(A) Μέση τιμή (μόνο σε αριθμούς) A το πεδίο min(A) Ελάχιστη τιμή (σε κάθε διατεταγμένο σύνολο) max(A) Μέγιστη τιμή (σε κάθε διατεταγμένο σύνολο) sum(A) Άθροισμα τιμών (μόνο σε αριθμούς) count(A) Πλήθος εγγραφών Συναθροιστικές Συναρτήσεις–Ομαδοποίηση (group by) Μπορούμε να εφαρμόσουμε τις συναθροιστικές συναρτήσεις όχι μόνο σε ένα σύνολο, αλλά και σε ομάδες (υποσύνολα του αρχικού συνόλου).
Οι ομάδες προσδιορίζονται χρησιμοποιώντας την πρόταση group by Όνομα -πεδίου.
Επιστρέφεται μια τιμή για κάθε ομάδα. (Ομάδα = οι σειρές με ίδια τιμή στο πεδίο ομαδοποίησης).
Ομαδοποίηση μπορεί να γίνει και ως προς περισσότερα πεδία που χωρίζονται με κόμμα.
Συναθροιστικές Συναρτήσεις –Πρόταση having Η πρόταση having συντάσσεται μετά την group by και περιέχει συνθήκες που περιορίζουν τις γραμμές που επιστρέφονται μετά από μία ομαδοποίηση (group by).
Προστέθηκε στην SQL επειδή η πρόταση where δεν μπορεί να χρησιμοποιηθεί για συγκρίσεις με αποτελέσματα συναθροιστικών συναρτήσεων (π.χ. avg(υπόλοιπο) > 1200) Πρέπει όμως να επαναλάβετε τη συνάρτηση γιατί δεν μπορείτε να χρησιμοποιήσετε το ψευδώνυμο της.
Το σχεσιακό μοντέλο δείχνει τη δομή της βάσης δεδομένων με το διάγραμμα περιορισμών αναφορικής ακεραιότητας να δείχνει με βέλη από που θα παίρνουν τις τιμές τους τα ξένα κλειδιά.
Παρατηρήστε πως συνδέονται δύο εγγραφές.
Ένας εργαζόμενος συνδέεται με ένα τμήμα με ένα ζεύγος τιμών {Κωδικος, ΚωδΤμηματος}.
Ένας εργαζόμενος συνδέεται με έναν προιστάμενο που είναι και αυτός εργαζόμενος με ένα ζεύγος τιμών {Κωδικος, Προισταμενος}.
Παρατηρήστε επίσης πως συνδέονται δύο Πίνακες;
Η σύνδεση δύο πινάκων επιτυγχάνεται µε τα κοινά πεδία τιμών τους (πρωτεύον κλειδί στον έναν, ξένο στον άλλον).
Μία σύνδεση γίνεται έτσι μέσω των κοινών πεδίων (π.χ.
ΚωδΤμηματος) που ανήκουν και στους δύο πίνακες.
Μπορούμε έτσι να εφαρμόσουμε την σύζευξη για να ενώσουμε τους δύο πίνακες.
Άρα σε τι χρησιμεύουν τα ξένα κλειδιά; "Δείχνουν" τις συσχετιζόμενες εγγραφές.
Στον SQL Server Enterprise Manager μπορείτε να κάνετε προσάρτηση της δικιά σας βάσης δεδομένων αν δεν υπάρχει ήδη από το προηγούμενο εργαστήριο επιλέγοντας το πράσινο βελάκι και έπειτα δεξί κλικ στο εικονίδιο Databases και All tasks->Attach Database και επιλέξετε το αρχείο .mdf από τον φάκελό σας που βρίσκεται στο W:\database\Baseis_1\....
Αλλιώς μπορείτε ανοίγοντας τον SQL Query Analyzerνα χρησιμοποιήσετε την εντολή CREATE DATABASE με την επιλογή for attach όπως το παρακάτω παράδειγμα:
Εμφανίστε τα Τμημα και Τοποθεσια από τον πίνακα Τμηματα (προβολή δύο στηλών από έναν πίνακα)
Εμφανίστε όλα τα στοιχεία των Τμημάτων με Τοποθεσια την ‘Αθήνα’ (επιλογή σειρών που ικανοποιούν τη συνθήκη επιλογής Τοποθεσια = ‘Αθήνα’) Εμφανίστε τα Επωνυμο, Ονομα και Τμημα από το καρτεσιανό γινόμενο των πινάκων Εργαζομενοι, Τμηματα Επωνυμο, Ονομα, Τμημα
(Δίχως συνθήκη σύζευξης εμφανίζει όλους τους δυνατούς συνδυασμούς των εγγραφών)
ΣΥΖΕΥΞΗ.
Βρείτε τα Επωνυμο, Ονομα εργαζομένων και το αντίστοιχο Τμημα όπου εργάζονται (σύζευξη 2 πινάκων με χρήση του κοινού τους πεδίου -ΚωδΤμηματος-)
Εργαζομενοι.ΚωδΤμηματος = Τμηματα.ΚωδΤμηματος (Συνθήκη σύζευξης: Απαιτεί οι τιμές των κοινών πεδίων στους δύο πίνακες να είναι ίδιες) Η σύζευξη πινάκων με χρήση των κοινών τους πεδίων, επιτρέπει την ανάκληση δεδομένων από περισσότερους πίνακες.
Είναι σύνθετη πράξη, δηλαδή ορίζεται με μία Προβολή, ένα Καρτεσιανό γινόμενο και μία Επιλογή των σειρών που ικανοποιούν τη συνθήκη σύζευξης.
ΣΥΖΕΥΞΗ.
Βρείτε Επωνυμο, Ονομα, και Τμημα των Διευθυντών (2 πίνακες, 1 συνθήκη σύζευξης, 1 συνθήκη επιλογής Θεση= 'Δ/ντής' ) ΣΥΖΕΥΞΗ.
Βρείτε όλα τα στοιχεία των εργαζομένων στην Τοποθεσια = 'Αθήνα' (2 πίνακες, 1 συνθήκη σύζευξης, 1 συνθήκη επιλογής) ΣΥΖΕΥΞΗ.
Βρείτε τα Επωνυμο, Ονομα, Θεση, Μισθος, Τμημα και Τοποθεσια των εργαζομένων στην Τοποθεσια=’Αθήνα’ με μισθό μεγαλύτερο του 1200 (2 πίνακες, 1 συνθήκη σύζευξης, 2 συνθήκες επιλογής) ΣΥΖΕΥΞΗ.
Βρείτε Επωνυμο, Ονομα, Μισθος, Τμημα όλων των εργαζομένων εκτός των πωλητών (Θεση <> 'Πωλητής'), ταξινομημένα ως προς Μισθό με φθίνουσα σειρά και έπειτα ως προς Ονομα με αύξουσα σειρά (2 πίνακες, 1 συνθήκη σύζευξης, 1 συνθήκη επιλογής) ΣΗΜΕΙΩΣΗ.
Αν έχετε δύο πίνακες στο from μην ξεχνάτε τη συνθήκη σύζευξης.
Για τα ονόματα πεδίων που είναι ίδια στους πίνακες του ερωτήματος χρησιμοποιούμε τη σύνταξη <Όνομα πίνακα>.<Όνομα πεδίου> όπως Τμηματα.ΚωδΤμηματος.
Η πρόταση της ταξινόμησης order by δεν αντιστοιχεί σε σχεσιακή πράξη, δηλώνει απλά ότι η σειρά εμφάνισης των εγγραφών θα είναι πρώτα ως προς το Μισθος φθίνουσα desc, και έπειτα ως προς Ονομα αύξουσα asc.
ΜΕΤΟΝΟΜΑΣΙΑ & ΣΥΖΕΥΞΗ.
Βρείτε το Επωνυμο, Ονομα, Τμημα, και Τοποθεσια των εργαζομένων (σύζευξη δύο πινάκων με μετονομασία τους) ε.Επωνυμο, ε.Ονομα, τ.Τμημα, τ.Τοποθεσια (το as είναι ο τελεστής μετονομασίας.
Στο from ορίζει μεταβλητές σχέσεων) ΜΕΤΟΝΟΜΑΣΙΑ & ΣΥΖΕΥΞΗ.
Για κάθε εργαζόμενο να βρεθούν το Επωνυμο, Ονομα, ΗμΠροσληψης καθώς και το Επωνυμο και ΗμΠροσληψης του Προϊσταμένου του (σύζευξη πίνακα με τον εαυτό του ορίζοντας δύο μεταβλητές ε και π ) ε.Επωνυμο, ε.Ονομα, ε.ΗμΠροσληψης,
Ποιοι Εργαζομενοι προσελήφθησαν μετά τον Προϊστάμενό τους (όπως η Δ10 σύζευξη πίνακα με τον εαυτό του με μία επιπλέον συνθήκη ε.ΗμΠροσληψης > π.ΗμΠροσληψης)
ΕΠΕΚΤΑΣΗ για υπολογιζόμενα πεδία.
Βρείτε το Επωνυμο, Ονομα, και Μισθο των εργαζομένων αυξημένο κατά 10% Επωνυμο, Ονομα, Μισθος * 110/100 as ΑυξησηΜισθου χρησιμοποιείται για οριζόντιους υπολογισμούς με υπολογιζόμενα πεδία.
Επεκτείνει τη λειτουργία της προβολής επιτρέποντας αριθμητικές εκφράσεις και τελεστές στην πρόταση select.
ΣΥΝΟΨΗ με συναθροιστικές συναρτήσεις.
Βρείτε το άθροισμα Μισθών και το άθροισμα Προμήθειας των Εργαζομένων select sum(Μισθος) as Αθροισμα_Μισθων, sum(Προμηθεια) as Αθροισμα_Προμηθειας
(Χρησιμοποιείται για κατακόρυφους υπολογισμούς με συναθροιστικές συναρτήσεις) Ενώ η επέκταση παρέχει έναν τρόπο για ‘οριζόντιους’ υπολογισμούς, κατά γραμμή, η σύνοψη εκτελεί την ανάλογη λειτουργία για ‘κατακόρυφους’ υπολογισμούς, κατά στήλη.
Η συναθροιστική πράξη παίρνει μια συλλογή τιμών και επιστρέφει μια μεμονωμένη τιμή ως αποτέλεσμα των συναρτήσεων avg(A), min(A) max(A), sum(A), count(A).
Για τα Τμήματα για τα οποία το πλήθος Εργαζομένων είναι μεγαλύτερο από 2 (count(Επωνυμο)>2), να εμφανίσετε (select) τα ΚωδΤμηματος, Τμημα, Τοποθεσια, και Άθροισμα Μισθων των Εργαζομένων τους αυξημένο κατά 10% ( sum(Μισθος) * 110/100), ταξινομημένα κατά Τοποθεσια. (θυμηθείτε ότι υπάρχουν 6 προτάσεις sql με συγκεκριμένη σειρά, ότι αν υπάρχουν δύο πίνακες πρέπει να έχουν 1 συνθήκη σύζευξης, αν υπάρχουν ονόματα πεδίων στο select πρέπει να γραφούν και στο group by, αν υπάρχει σύγκριση με count δεν γράφεται στο where, αν υπάρχει όνομα πεδίου κοινό στους δύο πίνακες πρέπει να δηλωθεί ως <Όνομα πίνακα>.<Όνομα πεδίου>)
ΤΕΛΕΣΤΗΣ ΕΣΩΤΕΡΙΚΗΣ ΣΥΖΕΥΞΗΣ (inner join).
Εμφανίστε τα Επωνυμο, Ονομα των εργαζομένων και το Τμημα στο οποίο εργάζονται (όπως το Δ04 αλλά με τη συνθήκη σύζευξης στην πρόταση from με τη σύνταξη ..inner join.. on..) Τμηματα inner join Εργαζομενοι on Εργαζομενοι.ΚωδΤμηματος = Τμηματα.ΚωδΤμηματος ; (Η σύνταξη <πίνακας1> inner join <πίνακας2> on <συνθήκη σύζευξης> επιτρέπει να γράφονται οι συνθήκες σύζευξης στην πρόταση from για να ξεχωρίζουν από τις άλλες συνθήκες επιλογής που γράφουμε στην πρόταση where).
Βρείτε το Επωνυμο, Ονομα, Μισθος, Τμημα και Τοποθεσια των εργαζομένων στην Τοποθεσία=’Θεσ/νίκη’ με Μισθο > 1000 (όπως το Δ15 με μία επιπλέον συνθήκη) Μια προέκταση της σύζευξης που αποτρέπει την απώλεια πληροφοριών.
Υπολογίζει πρώτα την εσωτερική σύζευξη (inner join) των δύο πινάκων και στη συνέχεια προσθέτει στο αποτέλεσμα τις εγγραφές του ενός πίνακα που δεν αντιστοιχούν με καμία από τις εγγραφές του άλλου (χρησιμοποιεί τα null σαν τιμές στα πεδία των αναντίστοιχων εγγραφών του άλλου πίνακα).
Τύποι Σύζευξης δύο πινάκων (Η λέξη OUTER προαιρετική): εσωτερική (φυσική) σύζευξη σημαίνει τις εγγραφές από τους δύο πίνακες όπου οι τιμές του κοινού πεδίου είναι ίδιες αριστερή εξωτερική σύζευξη σημαίνει όλες τις εγγραφές του αριστερού πίνακα και τις εγγραφές του δεξιού όπου οι τιμές του κοινού πεδίου είναι ίδιες δεξιά εξωτερική σύζευξη σημαίνει όλες τις εγγραφές του δεξιού πίνακα και τις εγγραφές του αριστερού όπου οι τιμές του κοινού πεδίου είναι ίδιες πλήρης εξωτερική σύζευξη Η ένωση (union) των δύο παραπάνω
Εμφανίστε τα Τμηματα.ΚωδΤμηματος και Εργαζομενοι.ΚωδΤμηματος από την αριστερή σύζευξη του πίνακα Τμηματα με τον Εργαζομενοι, ταξινομημένα κατά Εργαζομενοι.ΚωδΤμηματος με φθίνουσα σειρά.
Τμηματα.ΚωδΤμηματος , Εργαζομενοι.ΚωδΤμηματος Τμηματα left join Εργαζομενοι on Εργαζομενοι.ΚωδΤμηματος = Τμηματα.ΚωδΤμηματος Εργαζομενοι.ΚωδΤμηματος desc;
Στο αποτέλεσμα προσέξτε στην εγγραφή με Τμηματα.ΚωδΤμηματος = 3 την κενή τιμή (null) που έχει δίπλα στο πεδίο Εργαζομενοι.ΚωδΤμηματος.
Ποιο Τμημα δεν έχει εργαζόμενους (χρήση του is null στο προηγούμενο ερώτημα) Τμηματα.ΚωδΤμηματος, Τμηματα.Τμημα, Εργαζομενοι.ΚωδΤμηματος Τμηματα left join Εργαζομενοι on Τμηματα.ΚωδΤμηματος = Εργαζομενοι.ΚωδΤμηματος Εργαζομενοι.ΚωδΤμηματος is null;
Βρείτε τα Κωδικος, Επωνυμο, Ονομα των εργαζομένων και Επωνυμο του Προϊσταμένου τους.
Να συμπεριληφθούν και όσοι δεν έχουν Προϊστάμενο (αριστερή εξωτερική Σύζευξη πίνακα με τον εαυτό του, όπως η Δ10 αλλά με left join ) Υποερώτημα ονομάζεται οποιαδήποτε εντολή select είναι ενσωματωμένη (φωλιασμένη) σε άλλη select.
Χρησιμοποιείται όταν δεν γνωρίζουμε την τιμή σύγκρισης στο κατηγόρημα (πρόταση where).
Το πρώτο λέγεται εξωτερικό ερώτημα και το δεύτερο εσωτερικό υποερώτημα (φωλιασμένο).
Βρείτε τα Επωνυμο, Ονομα, Θεση, και Μισθος των εργαζομένων με το μεγαλύτερο Μισθό.
Επωνυμο, Ονομα, Θεση, Μισθος
Μισθος = (select max(Μισθος) from Εργαζομενοι);
Ποιοι Εργαζομενοι έχουν Μισθό μικρότερο από το μέσο μισθό.
Να προβάλλεται Επωνυμο, Ονομα, Θεση, Μισθος και Τμημα (όπως Ζ1 με σύζευξη δύο πινάκων στο εξωτερικό ερώτημα)
Βρείτε το Επωνυμο, Ονομα των εργαζομένων που έχουν Μισθό ίσο με το μισθό του Σταύρου, χωρίς να γνωρίζετε το μισθό του (where Μισθος = (select Μισθος from Εργαζομενοι where Επωνυμο ='Σταύρου') )
Τα Επωνυμο, Ονομα των εργαζομένων με προϊστάμενο τον Ψυχάρη (where Προισταμενος = (select Κωδικος from Εργαζομενοι where Επώνυμο = 'Ψυχάρης') )
Βρείτε τα Επωνυμο, Ονομα, Θεση, Μισθος των πωλητών που κερδίζουν τα λιγότερα στη Θεση εργασίας τους
Μισθος = (select min(Μισθος) from Εργαζομενοι where Θεση = 'Πωλητής' );
ΛΑΘΟΣ (το εξωτερικό ερώτημα βρίσκει τα στοιχεία όλων και όχι μόνο των πωλητών) Πρέπει να γράψετε τη συνθήκη Θεση = 'Πωλητής' και στο εξωτερικό ερώτημα ΕΡΩΤΗΜΑΤΑ SQL : Η σύνταξη ερωτήματος επιλογής SQL αποτελείται από έξι προτάσεις: SELECT [ distinct ] ονόματα πεδίων, εκφράσεων, ή και συναθροιστικές συναρτήσεις
Υποερώτημα ονομάζεται οποιαδήποτε εντολή SELECT που είναι ενσωματωμένη (φωλιασμένη) σε άλλη εντολή SELECT.
Τότε η πρώτη αποτελεί το εξωτερικό ερώτημα και η δεύτερη το εσωτερικό ερώτημα.
Χρησιμοποιούνται όταν δεν γνωρίζουμε την τιμή σύγκρισης στο κατηγόρημα (πρόταση WHERE).
Ποιος ή ποιοι εργαζόμενοι έχουν το μικρότερο Μισθό.
Να προβάλλεται Επώνυμο, Όνομα, Θέση, και Μισθός
Μισθος = ( select min(Μισθος) from Εργαζομενοι );
Ποιοι εργαζόμενοι έχουν Μισθό μικρότερο από το μέσο μισθό.
Να προβάλλεται Επώνυμο, Όνομα, Θέση, Μισθός και Τμήμα (όπως Η1 με σύζευξη δύο πινάκων) Επωνυμο, Ονομα, Θεση, Μισθος, Τμημα
Εργαζομενοι.ΚωδΤμηματος = Τμηματα.ΚωδΤμηματος and Μισθος < ( select avg(Μισθος) from Εργαζομενοι );
Βρείτε ποιοι εργαζόμενοι έχουν Μισθό ίσο με το μισθό του Σταύρου Αργύρη, χωρίς να γνωρίζετε το μισθό του.
Να προβάλλεται Επώνυμο, Όνομα
Μισθος = ( select Μισθος from Εργαζομενοι where Επωνυμο ='Σταύρου' );
Βρείτε ποιοι εργαζόμενοι εργάζονται στην ίδια θέση με τον Σταύρου Αργύρη χωρίς να γνωρίζετε τη Θέση του.
Να προβάλλεται Επώνυμο, Όνομα
Βρείτε ποιοι πωλητές κερδίζουν τα λιγότερα στη θέση εργασίας τους.
Να προβάλλεται Επώνυμο, Όνομα, Θέση, Μισθός
Ποιοι οι πωλητές με Μισθό μικρότερο από το μέσο μισθό των πωλητών.
Να προβάλλεται Επώνυμο, Όνομα, Θέση, Μισθός (όπως Η5)
Βρείτε τον διευθυντή με το μεγαλύτερο Μισθό
Βρείτε τους πωλητές με μισθό μικρότερο από το μέσο μισθό
Πιο είναι το τμημα με το μεγαλύτερο ετήσιο ποσό για μισθούς (με δύο υποερωτήματα) ΚωδΤμηματος, sum(μισθος*12) as Salaries having sum(μισθος*12) = (select max( m.ετησιος) from (select ΚωδΤμηματος, sum(μισθος*12) as ετησιος Να γίνει ο πίνακας ΚλιμακαΜισθων
Βρείτε τα ονόματα, θέσεις και μισθολογικό κλιμάκιο των εργαζομένων select επωνυμο, θεση, μισθος, βαθμιδα from Εργαζομενοι , ΚλιμακαΜισθων where μισθος >= αποΠοσο and μισθος <εωςΠοσο (Προσέξτε τα διαστήματα.
Η αναπαράσταση πρέπει να είναι [κλειστό από τα αριστερά – ανοιχτό από τα δεξιά) διάστημα, άρα δεν γίνεται να ανακτηθούν με τον τελεστή betweenand, που συνήθως σημαίνει >= και <= , αλλά με την κλασσική σύνταξη Α>==αποΠοσο and A<ΕωςΠοσο.
Παρατηρήστε επίσης ότι δεν υπάρχει σύζευξη, αλλά η απάντηση στο ερώτημα προέρχεται πάλι από τον περιορισμό του καρτεσιανού γινομένου των δύο πινάκων.
Γίνεται σύγκριση ένα-με-όλα) Το ερώτημα SQL γίνεται διαφορετικά με την έκφραση casewhen..thenelse.. end (case με αναζήτηση) αλλά δεν υποστηρίζεται στα desktop συστήματα όπως Access, Dbase, Paradox.
Δοκιμάστε το παρακάτω στον SQL SERVER ή στον Query Analyzer select επωνυμο, θεση, μισθος, When μισθος>=500 and μισθος<1000 then 1 When μισθος>=1000 and μισθος<1200 then 2
Συσχετιζόμενο υποερώτημα ονομάζεται εκείνο του οποίου η τιμή εξαρτάται από κάποια μεταβλητή που παίρνει την τιμή της από το εξωτερικό ερώτημα.
Έτσι ένα τέτοιο υποερώτημα πρέπει να εκτελείται κατ' επανάληψη (μία φορά για κάθε τιμή της μεταβλητής), αντί μία μόνο φορά.
Ποιοι εργαζόμενοι κερδίζουν τα περισσότερα στη Θέση εργασίας τους.
Να προβάλλεται Επώνυμο, Όνομα, Θέση, Μισθός τους. (ανά Θέση το max(Μισθος)).
Επωνυμο, Ονομα, Θεση, Μισθος select max(Μισθος) where ε.Θεση = Εργαζομενοι.Θεση ) Το εσωτερικό υποερώτημα θα υπολογιστεί για κάθε τιμή της μεταβλητής ε που παίρνει από το εξωτερικό ερώτημα
Ποιοι είναι οι τρεις καλύτερα αμοιβόμενοι στην εταιρία (με συσχετιζόμενο υποερωτημα)
3 > (select count(*) from Εργαζομενοι where μισθος > em.μισθος)
Ποιοι προσλήφθηκαν τελευταία σε κάθε τμήμα (δείτε το Θ1 και βάλτε ανά ΚωδΤμηματος τη max(ΗμΠροσληψης))
Ποιο τμήμα δεν έχει εργαζόμενους.
Με συσχετιζόμενο υποερώτημα η απάντηση θα είναι where Εργαζομενοι.ΚωδΤμηματος= Τμηματα.ΚωδΤμηματος);
Τα περισσότερα συστήματα βάσεων δεδομένων (SQL Server, Oracle, MySQL, MimerSQL, PostgreSQL) είναι σχεσιακά από τη φύση τους και έτσι παριστάνουν δεδομένα σε πίνακες ή λίστες με μη ιεραρχικούς τύπους συνδέσμων (ζεύγη τιμών των πρωτεύοντων κλειδιών των αντικειμένων), τις σχέσεις.
Τα ιεραρχικά δεδομένα όμως (όπως για παράδειγμα η XML) έχουν συσχετίσεις τύπου γονέα-παιδιού οι οποίες δεν παριστάνονται εύκολα σε έναν σχεσιακό πίνακα της βάσης δεδομένων, καθιστώντας δύσκολη την διαχείριση των εγγραφών.
Τα ιεραρχικά δεδομένα μπορούν να βρεθούν σε μία ποικιλία εφαρμογών βάσεων δεδομένων όπως οι εργαζόμενοι που κατατάσσονται σύμφωνα με τον προϊστάμενο τους, τα μηνύματα που περνούν σε ιεραρχίες προτεραιότητας στα φόρουμ και στις λίστες email, το οργανόγραμμα μιας εταιρίας, οι κατηγορίες και υποκατηγορίες των προϊόντων, η διαχείριση αντικειμένων μέσω περιεχομένου.
Στον πίνακα Εργαζομενοι χρησιμοποιείται η απλή προσέγγιση της αναδρομικής λίστας γειτνίασης (σε κάθε κόμβο-παιδί αποθηκεύεται δείκτης προς τον κόμβο-γονέα) για τη μεταφορά των ιεραρχικών δομών δένδρου (δείτε την αναδρομική συσχέτιση από το διάγραμμα Οντοτήτων-Συσχετίσεων).
Εμφανίστε το πλήρες δένδρο του οργανογράμματος της εταιρίας select e1.επωνυμο as επιπεδο1, e2.επωνυμο as επιπεδο2, e3.επωνυμο as επιπεδο3 left join εργαζομενοι as e2 on e2.προισταμενος=e1.κωδικος ) left join εργαζομενοι as e3 on e3.προισταμενος=e2.κωδικος where e1.επωνυμο = 'Ψυχάρης'
Βρείτε όλα τα φύλλα του δένδρου (τους κόμβους δίχως παιδιά) του οργανογράμματος from εργαζομενοι e1 left join εργαζομενοι e2 on e2.προισταμενος=e1.κωδικος where e2.κωδικος is null
Βρείτε το πλήρες μονοπάτι του οργανογράμματος από τον ‘Ψυχάρη’ (επίπεδο1) προς τον ‘Σταύρου’ (επίπεδο3) select e1.επωνυμο as επιπεδο1, e2.επωνυμο as επιπεδο2, e3.επωνυμο as επιπεδο3 left join εργαζομενοι e2 on e2.προισταμενος=e1.κωδικος ) left join εργαζομενοι e3 on e3.προισταμενος=e2.κωδικος where e1.επωνυμο = 'Ψυχάρης' and e3.επωνυμο = 'Σταύρου' (Οι κυριότεροι περιορισμοί αυτής της προσέγγισης είναι ότι χρειάζεστε ένα left join για κάθε επίπεδο της ιεραρχίας των δεδομένων και ότι τα ερωτήματα δεν είναι δυναμικά - δεν μεταβάλονται ανάλογα με τις αλλαγές στο βάθος του δένδρου).
Για το επόμενο παράδειγμα διαδικασίας στον SQL Server δημιουργήστε πρώτα ένα αντίγραφο πίνακα τρέχωντας το παρακάτω στον Query Analyzer: insert into ERGAZOMENOS(Eno, Proistamenos) select Κωδικος, Προισταμενος from Εργαζομενοι;
Να δημιουργηθεί μία διαδικασία στον SQL Server η οποία θα δέχεται ως όρισμα τον Κωδικό ενός εργαζομένου και θα επιστρέφει όλους τους κωδικούς των υφισταμένων του από τον πίνακα ERGAZOMENOS(ENO, PROISTAMENOS).
Από τον Query Analyzer και στην Δικιά σας Βάση δεδομένων εργαζομένων-τμημάτων αποθηκεύσετε το παρακάτω -- δήλωση μιας μεταβλητής πίνακα
-- για εξαγωγή των αποτελεσμάτων -- έναρξη πρώτου block εντολών -- δημιουργία δύο προσωρινών πινάκων -- εισήγαγε στον πίνακα newEmp -- με προιστάμενο τον manag -- όσο ο newEmp δεν είναι κενός -- έναρξη δεύτερου block εντολών -- πρόσθεσε στην μεταβλητή EmpsOfManager -- τους κωδικούς εργαζομένων -- που περιέχονται στον newEmp -- έπειτα βάλε στον tempEmp τους υφισταμένους -- αυτών που βρίσκονται στον newEmp -- αλλά δεν υπάρχουν στον EmpsOfManager -- με τα περιεχόμενα του tempEmp -- και καθαρίζει τον tempEmp -- τέλος δεύτερου block εντολών -- επέστρεψε τα περιεχόμενα του EmpsOfManager -- τέλος πρώτου block εντολών Η διαδικασία FindEmpsOfManager (τρέχει γράφοντας π.χ.
FindEmpsOfManager 17 ; ) δέχεται ως όρισμα μία μεταβλητή integer την manag (μεταβλητές δηλώνονται με το @).
Χρησιμοποιεί δύο προσωρινούς πίνακες, τους newEmp και tempEmp (δηλώνονται με το #) που έχουν ένα πεδίο το Eno με τύπο integer.
Η διαδικασία στην αρχή εισάγει στον newEmp όλους τους κωδικούς των εργαζομένων με κωδικό προισταμένου = manag.
Ο βρόχος while προσθέτει τους εργαζομένους του newEmp στην μεταβλητή πίνακα EmpsOfManager (δηλώνεται με το @).
Μετά βρίσκει τους εργαζομένους που δουλεύουν για αυτούς (είναι υφιστάμενοι) που περιέχονται στον newEmp, εκτός από αυτούς που έχουν ήδη βρεθεί να είναι εργαζόμενοι και περιέχονται στον πίνακα EmpsOfManager και αποθηκεύει τα αποτελέσματα στον πίνακα tempEmp.
Τέλος αντικαθιστά τα περιεχόμενα του newEmp με τα περιεχόμενα του tempEmp.
Ο βρόχος τερματίζει όταν δεν βρει νέους (έμμεσους) εργαζόμενους.
Παρατηρήστε ότι η χρήση του not in (select * from @EmpsOfManager) διασφαλίζει ότι η διαδικασία δουλεύει ακόμη και στην (απίθανη) περίπτωση όπου υπάρχει ένας κύκλος διαχείρισης (κυκλικά συνδεδεμένη λίστα).
Για παράδειγμα αν ο a δουλεύει για τον b, ο b για τον c και ο c για τον a.
Ενώ οι κύκλοι είναι μία μη ρεαλιστική περίπτωση, είναι πιθανόν να υπάρχουν σε άλλες εφαρμογές.
Για παράδειγμα ο πίνακας Flights(ToSity, FromSity) που καθορίζει σε ποιες πόλεις (ToSity) μπορούμε να πάμε με άμεση πτήση από μία πόλη (FromSity).
Σε αυτή την περίπτωση μπορεί να υπάρχουν κύκλοι, αλλά η διαδικασία θα απαλείφει τις πόλεις που έχουν ήδη βρεθεί.
Δημιουργία της βάσης δεδομένων «Τράπεζα1» create table ΠΕΛΑΤΗΣ (
ΟνομαΠελατη varchar(20) not null , primary key (ΟνομαΠελατη) ) ; create table ΥΠΟΚΑΤΑΣΤΗΜΑ (
ΟνομαΥποκαταστηματος varchar(15) not null , primary key (ΟνομαΥποκαταστηματος) ); create table ΛΟΓΑΡΙΑΣΜΟΣ (
ΑριθμοςΛογαριασμου varchar(10) not null , primary key (ΑριθμοςΛογαριασμου) , foreign key (ΟνομαΥποκαταστηματος) references Υποκαταστημα(ΟνομαΥποκαταστηματος) ) ; create table ΔΑΝΕΙΟ (
ΑριθμοςΔανειου varchar(10) not null , primary key (ΑριθμοςΔανειου) , create table ΔΑΝΕΙΖΟΜΕΝΟΣ (
ΟνομαΠελατη varchar(20) not null ,
ΑριθμοςΔανειου varchar(10) not null , primary key (ΟνομαΠελατη , ΑριθμοςΔανειου) , foreign key (ΟνομαΠελατη) references Πελατης(ΟνομαΠελατη) , foreign key (ΑριθμοςΔανειου) references Δανειο(ΑριθμοςΔανειου) ) ; create table ΚΑΤΑΘΕΤΗΣ (
ΟνομαΠελατη varchar(20) not null ,
ΑριθμοςΛογαριασμου varchar(10) not null , primary key (ΟνομαΠελατη , ΑριθμοςΛογαριασμου) , foreign key (ΑριθμοςΛογαριασμου) references Λογαριασμος(ΑριθμοςΛογαριασμου) );
Το σχεσιακό μοντέλο της βάσης με τους περιορισμούς αναφορικής ακεραιότητας απαντηστε στα παρακατω ΕΡΩΤΗΜΑΤα Σε SQL Εμφανίστε τα ονόματα υποκαταστημάτων από τον πίνακα Δανειο Να εμφανίσετε όλες τις στήλες από τον πίνακα Δανειο Εμφανίστε χωρίς διπλότυπα τα ονόματα υποκαταστημάτων από τον πίνακα Δανειο.
Εμφανίστε από τον πίνακα Δανειο τα αριθμός δανείου, όνομα Υποκαταστήματος και το Ποσο πολλαπλασιασμένο επί 340 (Ποσο * 340) Τους αριθμούς δανείων για δάνεια με Ποσο μεγαλύτερο από 1200.
Τους αριθμούς δανείων για δάνεια με Ποσο μεταξύ 5000 και 10000 Όλα τα στοιχεία των πελατών από τον Αναγνώστου μέχρι και τον Παπαδόπουλο (between "Αναγνώστου" and "Παπαδόπουλος") Τα ονόματα πελατών με οδό που αρχίζει από Κ (χρήση του Like) Τα Ονόματα υποκαταστημάτων που αρχίζουν από Β ή από Κ, βρίσκονται σε Πόλεις εκτός του Βόλου, και έχουν Ενεργητικό μεταξύ 500000 και 3000000, ταξινομημένα κατά Ενεργητικό από το υψηλότερο στο χαμηλότερο Εντοπίστε το όνομα πελάτη, αριθμό δανείου και Ποσο δανείου των πελατών που έχουν ένα Δανειο από το Υποκαταστημα με όνομα ‘Κρήνης’ (σύζευξη 2 πινάκων) Δώστε με αλφαβητική σειρά τα ονόματα πελατών που έχουν Δανειο στα Υποκαταστήματα της Πολης ‘Σέρρες’ (σύζευξη 3 πινάκων) Βρείτε όλα τα στοιχεία των πελατών του ερωτήματος Β11 (σύζευξη 4 πινάκων) Εμφανίστε όλα τα στοιχεία του πίνακα Δανειο, ταξινομημένα με φθίνουσα σειρά (Desc) ως προς το Ποσο και έπειτα με αύξουσα σειρά ως προς Αριθμό δανείου Βρείτε το όνομα, τον αριθμό δανείου και το Ποσο δανείου όλων των πελατών.
Μετονομάστε το ΑριθμοςΔανειου ως ΚωδΔανειου (σύζευξη 2 και χρήση του As) Εμφανίστε τα ονόματα πελατών, με αύξουσα σειρά, και τις διευθύνσεις των πελατών με Ποσο δανείου που υπερβαίνει πάνω από 3 φορές το Υπολοιπο Λογαριασμού τους (5 πίνακες, 4 συνθήκες σύζευξης , μία συνθήκη επιλογής Ποσο>3 * υπολοιπο) Βρείτε το πλήθος των υποκαταστημάτων της τράπεζας (χρήση της count (*) στον πίνακα Υποκαταστημα).
Βρείτε το άθροισμα, ελάχιστη και μέγιστη τιμή των Υπολοιπων από τον πίνακα Λογαριασμος (χρήση των συναρτήσεων sum , min , max στο πεδίο Υπολοιπο).
Εισάγετε στον πίνακα Πελατης το όνομα, την οδό σας και την πόλη σας με την σύνταξη insert into ΌνομαΠίνακα(πεδίο1, πεδίο2, πεδίο3) Εισάγετε (με τη σύνταξη insert into.
Values ) ένα νέο υποκατάστημα με ΟνομαΥποκαταστηματος 'Μεραρχιας' στην Πολη 'Σέρρες' και Ενεργητικό 9000000. εξηγησεισ: Βασική συνταξη ερωτήματος προβολής-επιλογής-σύζευξης (Select-From-Where) Η SQL βασίζεται σε πράξεις συνόλου και σχέσεων.
Το αποτέλεσμα μιας ερώτησης SQL είναι μια άλλη σχέση (αντιστοιχεί σε πίνακα).
Μια συνηθισμένη ερώτηση της SQL έχει τη μορφή:
Αυτό το ερώτημα είναι ισοδύναμο με την έκφραση της σχεσιακής άλγεβρας select αντιστοιχεί στην πράξη της προβολής της σχεσιακής άλγεβρας.
Τις στήλες (πεδία) που θα υπάρχουν στο αποτέλεσμα της ερώτησης, και η σειρά με την οποία θα εμφανίζονται.
Ένας αστερίσκος στην πρόταση select δηλώνει προβολή όλων των στηλών (select *).
Η πρόταση select μπορεί να περιέχει και αριθμητικές εκφράσεις (αντιστοιχεί στην γενικευμένη προβολή της σχεσιακής άλγεβρας) που σχετίζονται με τις αριθμητικές πράξεις +, -, *, / και λειτουργούν σε σταθερές, ή ονόματα στηλών. from αντιστοιχεί στην πράξη του καρτεσιανού γινομένου της σχεσιακής άλγεβρας.
Ποιοι πίνακες θα χρησιμοποιηθούν για τον υπολογισμό του αποτελέσματος. where αντιστοιχεί στην πράξη της επιλογής της σχεσιακής άλγεβρας.
Περιέχει συγκρίσεις με τιμές και πεδία των πινάκων που εμφανίζονται στο from.
Δέχεται συνθήκες επιλογής και συνθήκες σύζευξης.
Στις συνθήκες χρησιμοποιούνται οι τελεστές σύγκρισης: <, <=, >, >=, =, <> (().
Στις συνθήκες επιτρέπονται και αριθμητικές εκφράσεις.
Τα αποτελέσματα των συγκρίσεων μπορούν να συνδυαστούν χρησιμοποιώντας τους λογικούς τελεστές not , and , or.
Τα εισαγωγικά χρησιμοποιούνται για σύγκριση με τιμές κειμένου (συμβολοσειρές), που δεν είναι αριθμητικές τιμές.
Επιλέγεται κάθε σειρά για την οποία στην πρόταση where βγαίνει true.
ΠΡΟΣΟΧΗ: Δε γίνεται απαλοιφή των διπλών εμφανίσεων (διπλότυπα).
Η SQL επιτρέπει και πολλαπλές εμφανίσεις της ίδιας σειράς σε έναν πίνακα.
Για την Απαλοιφή διπλών εμφανίσεων (διπλότυπα) χρησιμοποιούμε το distinct . select distinct Α1, Α2, .., Αn from R1, R2, Rm Τα ονόματα στην SQL μπορούν να γραφούν είτε με μικρά είτε με κεφαλαία Η πρόταση where περιλαμβάνει μια πράξη σύγκρισης betweenand(not between and) προκειμένου να απλοποιηθούν οι συγκρίσεις που καθορίζουν ότι μια τιμή είναι μικρότερη ή ίση προς κάποια τιμή και μεγαλύτερη ή ίση από κάποια άλλη τιμή (where Ποσο between 90000 and 100000 αντί του where Ποσο >= 90000 and Ποσο <= 100000).
Όταν το ίδιο όνομα πεδίου εμφανίζεται σε περισσότερους από έναν πίνακες, τότε γίνεται διάκριση βάση του συμβολισμού: όνομα-πίνακα.όνομα-πεδίου Σύζευξη (join) δύο πινάκων.
Το καρτεσιανό γινόμενο στην πρόταση from μαζί με μία συνθήκη σύζευξης (συνένωσης) στην πρόταση where αντιστοιχεί στην σχεσιακή πράξη της σύζευξης δύο πινάκων με χρήση του κοινού τους πεδίου (το πρωτεύον κλειδί του ενός που είναι ξένο κλειδί στον άλλον) where Πίνακας1.όνομα-πρωτεύοντος-κλειδιού= Πίνακας2.όνομα-ξένου-κλειδιού from Πίνακας1 inner join Πίνακας2 on Πίνακας1.όνομα-πρωτεύοντος-κλειδιού= Πίνακας2.όνομα-ξένου-κλειδιού Συνθήκη σύζευξης: Απαιτεί οι τιμές των κοινών πεδίων στους δύο πίνακες να είναι ίδιες (π.χ.
Δανειο.ΑριθμοςΔανειου = Δανειζομενος.ΑριθμοςΔανειου) Συγκρίσεις με Συμβολοσειρές.
Η SQL περιλαμβάνει έναν τελεστή ταύτισης συμβολοσειρών για συγκρίσεις αλφαριθμητικών χαρακτήρων.
Η σύγκριση γίνεται χρησιμοποιώντας το like, not like.
Χρησιμοποιούνται δύο ειδικοί χαρακτήρες: Ο χαρακτήρας ποσοστό % (ή ο αστερίσκος *) για οποιαδήποτε συμβολοσειρά.
Η κάτω παύλα _ (ή το ερωτηματικό ?) για έναν οποιονδήποτε χαρακτήρα.
Στις συγκρίσεις γίνεται διάκριση ανάμεσα σε κεφαλαία και μικρά.
Διάταξη των γραμμών- order by.
Γίνεται στο τέλος του ερωτήματος.
Με χρήση του order by ώστε οι γραμμές στο αποτέλεσμα να είναι ταξινομημένες με βάση το αντίστοιχο πεδίο.
Εξ ορισμού χρησιμοποιείται η αύξουσα διάταξη (asc).
Με τον όρο desc καθορίζουμε την φθίνουσα διάταξη (descending order).
Επίσης μπορεί να γίνει ταξινόμηση με βάση πολλά γνωρίσματα.
Μετονομασία.
Η SQL επιτρέπει την προσωρινή μετονομασία πινάκων και στηλών χρησιμοποιώντας την πρόταση as (παλιό-όνομα as νέο-όνομα).
Το as μπορεί να εμφανίζεται στο select για την μετονομασία στήλης (ψευδώνυμο) ή στο from για την μετονομασία πίνακα (μεταβλητή).
Εισαγωγή.
Η σύνταξη για την εισαγωγή μίας εγγραφής σε έναν πίνακα είναι insert into Όνομα-Πίνακα values (τιμή1, τιμή2,....) ή αλλιώς insert into Όνομα-Πίνακα (πεδίο1, πεδίο2,...) values (τιμή1, τιμή2,....) Η βάση δεδομένων ΤΡΑΠΕΖΑ θα αποθηκεύει πληροφορίες για τις οντότητες Πελάτες, Υποκαταστήματα, Λογαριασμούς και Δάνεια.
Οι Πελάτες συνδέονται με τα Δάνεια με τη συσχέτιση Δανειζόμενος (αποθηκεύει πληροφορία σχετική με το ποιος πελάτης έχει ποιο Δάνειο) που έχει λόγο πληθηκότητας είναι πολλά-με-πολλά (N : M).
Οι Πελάτες συνδέονται με τουςλογαριασμούς με τη συσχέτιση Καταθέτης (αποθηκεύει πληροφορία σχετική με το ποιος πελάτης κατέχει ποιον λογαριασμό) που είναι πολλά-με-πολλά.
Επίσης οι Λογαριασμοί συνδέονται με τα υποκαταστήματα με μία συσχέτιση ένα-με-πολλά (1 : N), με την διπλή γραμμή να δηλώνει ολική συμμετοχή καθότι δεν μπορεί να υπάρχει λογαριασμός δίχως να σχετίζεται με συγκεκριμένο υποκατάστημα.
Τέλος τα Δάνεια συνδέονται συνδέονται με τα υποκαταστήματα με μία συσχέτιση ένα-με-πολλά, με την διπλή γραμμή να δηλώνει πάλι ολική συμμετοχή.
Η παρακάτω εικόνα δείχνει το διάγραμμα Οντοτήτων-Συσχετίσεων (ER) για τον τραπεζικό οργανισμό.
Τετράγωνα ( οντότητες, Ρόμβοι ( συσχετίσεις.
Ο λόγος πληθικότητας (cardinality) ενός τύπου συσχετίσεων ορίζει το πόσες οντότητες από τον πρώτο τύπο οντοτήτων στην συσχέτιση μπορούν να συνδεθούν με τις οντότητες από τον δεύτερο τύπο.
Στην ουσία σημαίνει πόσες εγγραφές από την μία πλευρά της δυαδικής συσχέτισης μπορούν να συνδεθούν με τις εγγραφές τις άλλης πλευράς.
Η μετατροπή του παραπάνω διαγράμματος ER στο σχεσιακό μοντέλο είναι σχετικά εύκολη.
Για κάθε οντότητα δημιουργούμε πίνακα.
Για κάθε δυαδική συσχέτιση ένα-προς-πολλά παίρνουμε το πρωτεύον κλειδί από την πλευρά του -ένα- και το προσθέτουμε σαν πεδίο στην πλευρά του πολλά.Για κάθε δυαδική συσχέτιση πολλά-προς-πολλά δημιουργούμε επιπλέον πίνακα με ξένα κλειδιά τα πρωτεύοντα κλειδιά των δύο επιμέρους οντοτήτων.
ΥΠΟΚΑΤΑΣΤΗΜΑ (ΟνομαΥποκαταστηματος, Πολη, Ενεργητικο) ΛΟΓΑΡΙΑΣΜΟΣ (ΟνομαΥποκαταστήματος, ΑριθμοςΛογαριασμου, Υπολοιπο) ΔΑΝΕΙΟ (ΟνομαΥποκαταστήματος, ΑριθμοςΔανειου, Ποσο) ΔΑΝΕΙΖΟΜΕΝΟΣ (ΟνομαΠελατη, ΑριθμοςΔανειου) ΠΕΛΑΤΗΣ (ΟνομαΠελατη, Οδος, Πολη) ΚΑΤΑΘΕΤΗΣ (ΟνομαΠελατη, ΑριθμοςΛογαριασμου)
ΕΡΩΤΗΜΑΤα SQL ΜΕ Συναθροιστικές Συναρτήσεις Υπολογίστε από τον πίνακα Δανειο τη μέση τιμή του Ποσου των Δανειων στο Υποκατάστημα με όνομα ‘Βενιζέλου’ (χρηση της συνάρτησης avg).
Βρείτε από τον πίνακα Λογαριασμός το μέσο Υπόλοιπο των λογαριασμών σε κάθε υποκατάστημα (ομαδοποίηση ανά ΟνομαΥποκαταστηματος- πρόταση group by).
Βρείτε τον αριθμό (πλήθος) των καταθετών σε κάθε υποκατάστημα (κάντε πρώτα τη σύζευξη των πινάκων Καταθετης, Λογαριασμος, έπειτα υπολογίστε το πλήθος των καταθετών, και μετά ομαδοποιήστε ανά ΟνομαΥποκαταστηματος).
Βρείτε από τον πίνακα Λογαριασμος τα ονόματα υποκαταστημάτων με μέσο υπόλοιπο καταθέσεων μεγαλύτερο των 1200 (ομαδοποίηση ανά ΟνομαΥποκαταστηματος και χρήση της πρότασης having) Βρείτε το μέσο υπόλοιπο των λογαριασμών για κάθε πελάτη που ζει στα Ιωάννινα και έχει τουλάχιστον τρεις λογαριασμούς (κάντε πρώτα τη σύζευξη των πινάκων Καταθετης, Λογαριασμος, Πελατης, έπειτα βρείτε μόνο τους πελάτες που μένουν στα Ιωάννινα, έπειτα υπολογίστε τη μέση τιμή των Υπολοίπων Λογαριασμού για κάθε πελάτη ομαδοποιώντας ανά Καταθετης.ΟνομαΠελατη, και τέλος περιορίστε τα αποτελέσματα με το having βρίσκοντας μόνο εκείνους τους Καταθέτες που έχουν πλήθος Αριθμών Λογαριασμού >= 3)
Βρείτε τα στοιχεία του πελάτη με το μεγαλύτερο υπόλοιπο λογαριασμού στο υποκατάστημα ‘Βενιζέλου’ (βρείτε πρώτα τα στοιχεία των πελατών στο υποκατάστημα Βενιζέλου από τη σύζευξη των πινάκων Πελατης, Καταθετης, Λογαριασμος, έπειτα βρείτε με δεύτερο υποερώτημα το μεγαλύτερο υπόλοιπο λογαριασμού στο υποκατάστημα Βενιζέλου και χρησιμοποιείστε το δεύτερο υποερώτημα σαν τιμή σύγκρισης στο πρώτο).
εξηγησεισ: Συναθροιστικές Συναρτήσεις
Εξηγήσεις: Συναθροιστικές Συναρτήσεις-Ομαδοποίηση (group by) Μπορούμε να εφαρμόσουμε τις συναθροιστικές συναρτήσεις όχι μόνο σε ένα σύνολο, αλλά και σε ομάδες (υποσύνολα του αρχικού συνόλου).
Οι ομάδες προσδιορίζονται χρησιμοποιώντας την πρόταση group by όνομα-πεδίου.
Επιστρέφεται μια τιμή για κάθε ομάδα. (Ομάδα=οι σειρές με ίδια τιμή στο πεδίο ομαδοποίησης).
Ομαδοποίηση μπορεί να γίνει και ως προς περισσότερα πεδία που χωρίζονται με κόμμα.
Αν υπάρχει όνομα πεδίου στο Select πρέπει να υπάρχει και στο group by.
Εξηγήσεις: Συναθροιστικές Συναρτήσεις –Πρόταση having Η πρόταση having συντάσσεται μετά την group by και περιέχει συνθήκες που περιορίζουν τις γραμμές που επιστρέφονται μετά από μία ομαδοποίηση (group by).
Προστέθηκε στην SQL επειδή η πρόταση where δεν μπορεί να χρησιμοποιηθεί για συγκρίσεις με αποτελέσματα συναθροιστικών συναρτήσεων (π.χ. avg(υπολοιπο) > 1200) Πρέπει όμως να επαναλάβετε τη συνάρτηση γιατί δεν μπορείτε να χρησιμοποιήσετε το ψευδώνυμο της.
Η γενική σύνταξη ενός ερωτήματος SQL select [ distinct ] ονόματα πεδίων, αριθμητικές εκφράσεις, συναθροιστικές συναρτήσεις συνθήκες περιορισμού των σειρών που επιστρέφονται μετά από ομαδοποίηση]
Οι group by και having χρησιμοποιούνται μόνο όταν υπάρχουν συναθροιστικές συναρτήσεις.
Τελεστές Σύγκρισης (Στις Λογικές Συνθήκες των προτάσεων Where και Having ):
Επίσης οι τελεστές: like, not like, betweenand, not betweenand, in, not in, is null, is not null, exists, not exists, any, all.
ΕΡΩΤΗΜΑΤα SQL ΜΕ ΠΡΑΞΕΙΣ ΣΥΝΟΛΩΝ (ενωση, τομη, διαφορα) Βρείτε τα ονόματα των πελατών που έχουν δάνειο (υπάρχουν στον πίνακα Δανειζομενος), ή λογαριασμό (υπάρχουν στον πίνακα Καταθετης), ή και τα δύο (ένωση).
Βρείτε τα ονόματα των πελατών που έχουν πάρει δάνειο και έχουν λογαριασμό (τομή).
Βρείτε τα ονόματα των πελατών που έχουν δάνειο αλλά δεν έχουν λογαριασμό (διαφορά).
Βρείτε τα ονόματα των πελατών που δεν έχουν δάνειο (διαφορά Πελατης-Δανειζομενος).
Βρείτε τα ονόματα των πελατών που έχουν δάνειο (υπάρχουν στη σύζευξη Δανειζομενος, Δανειο), ή λογαριασμό στο Υποκατάστημα με όνομα Βενιζέλου (υπάρχουν στη σύζευξη Καταθετης, Λογαριασμος), ή και τα δύο (ένωση).
Βρείτε τα ονόματα των πελατών που έχουν και δάνειο και λογαριασμό στο Υποκατάστημα Βενιζέλου (τομή). δ) εξηγησεισ: ΠΡΑΞΕΙΣ Συνόλων Οι πράξεις συνόλων ένωση (UNION), τομή (INTERSECT) και διαφορά (EXCEPT) στους πίνακες (σχέσεις) αντιστοιχούν στους τελεστές της σχεσιακής άλγεβρας (, (, -.
Οι πράξεις δύο συνόλων Α και Β:
Οι πράξεις συνόλων εφαρμόζονται σε συμβατές σχέσεις (πρέπει να έχουν τον ίδιο αριθμό στηλών και ίδιο τύπο δεδομένων).
Η Γενική Σύνταξη είναι: ( select πεδίο1, πεδίο2 from πίνακας1 where συνθήκη1 ) ( select πεδίο1, πεδίο2 from πίνακας2 where συνθήκη2 ) Καθένας από τους παραπάνω τελεστές αυτόματα διαγράφει τα διπλότυπα (απαλοιφή διπλών εμφανίσεων).
Για την τήρηση των διπλοτύπων χρησιμοποιείται η αντίστοιχη εκδοχή πολλαπλών συνόλων union all.
Παράδειγμα ένωσης.
Βρείτε τα ονόματα όλων των πελατών που έχουν δάνειο (υπάρχουν στον πίνακα Δανειζομενος), ή λογαριασμό (υπάρχουν στον πίνακα Καταθετης), ή και τα δύο. (select ΟνομαΠελατη from Kαταθετης) (select ΟνομαΠελατη from Δανειζομενος) ΣΗΜΕΙΩΣΗ: ο τελεστής union υποστηρίζεται από τα περισσότερα σχεσιακά συστήματα διαχείρισης βάσεων δεδομένων (RDBMS).
Σε αντίθεση η διαφορά except και τομή intersect δεν υπάρχουν σαν τελεστές παρά σε ελάχιστα.
Στην SQL είναι δυνατό να εκφραστούν και διαφορετικά τα ερωτήματα τομής και διαφοράς χρησιμοποιώντας πράξεις με τους τελεστές in, not in, exists, not exists.
Παράδειγμα τομής με τον τελεστή in.
Βρείτε τα ονόματα όλων των πελατών που έχουν πάρει δάνειο και έχουν λογαριασμό.
ΟνομαΠελατη in (select ΟνομαΠελατη from Δανειζομενος) Παράδειγμα διαφοράς με τον τελεστή not in.
Βρείτε τα ονόματα όλων των πελατών που έχουν λογαριασμό αλλά δεν έχουν δάνειο.
ΟνομαΠελατη not in (select ΟνομαΠελατη from Δανειζομενος) Στα δύο τελευταία παραδείγματα διατηρούνται οι διπλότυπες εγγραφές.
Για την απαλοιφή τους χρησιμοποιείται το select distinct. ε) ΕΡΩΤΗΜΑΤα SQL ΕξωτερικήΣ σύζευξηΣ ΚΑΙ null τιμεσ
Εμφανίστε με χρήση left join όλα τα δεδομένα από τους πίνακες Πελατης και Δανειζομενοι (θυμηθείτε ότι η εσωτερική σύζευξη inner join εμφανίζει μόνο τις εγγραφές με κοινή τιμή στο πεδίο ΟνομαΠελατη).
Δείτε τις εγγραφές με κενή τιμή στα πεδία του πίνακα Δανειζομενοι.
Είναι αυτές που υπάρχουν στον πίνακα Πελατης, αλλά δεν υπάρχουν στον Δανειζομενοι, που δεν αντιστοιχούν δηλαδή με καμία από τις εγγραφές του).
Βρείτε τους Πελάτες που δεν είναι Δανειζόμενοι (με χρήση left join και is null).
from Πελατης left join Δανειζομενος on Πελατης.ΟνομαΠελατη= Δανειζομενος.ΟνομαΠελατη where Δανειζομενος.ΟνομαΠελατη is null
Βρείτε τα Υποκαταστήματα που δεν έχουν Δάνεια (με χρήση left join και is null).
Βρείτε τα Υποκαταστήματα που δεν έχουν Λογαριασμούς (με χρήση left join και is null).
Εισάγετε ένα νέο Υποκατάστημα και επαναλάβετε τα δύο προηγούμενα ερωτήματα.
Βρείτε τα ονόματα των πελατών που είτε έχουν καταθέσεις είτε έχουν πάρει δάνεια ή και τα δύο (πλήρης εξωτερική σύζευξη των Καταθετης και Δανειζομενος) from Καταθετης left join Δανειζομενος on Καταθετης.ΟνομαΠελατη = Δανειζομενος.ΟνομαΠελατη) from Καταθετης right join Δανειζομενος on Καταθετης.ΟνομαΠελατη = Δανειζομενος.ΟνομαΠελατη)
Βρείτε τα ονόματα των πελατών που είτε έχουν καταθέσεις είτε έχουν πάρει δάνεια, αλλά όχι και τα δυο (Καταθετης XOR Δανειζομενος) select * from Ε6 where ΑριθμοςΛογαριασμου is null or ΑριθμοςΔανειου is null και βρείτε έναν τρόπο για να πάρετε τα ονόματα Πελατών σε μία στήλη (με χρήση union). ε) εξηγησεισ: Εξωτερική σύζευξη (Εξωτερική Συνένωση) Μια επέκταση της σύζευξης που αποτρέπει την απώλεια πληροφοριών.
Υπολογίζει την εσωτερική σύζευξη (inner join) των δύο πινάκων και στη συνέχεια προσθέτει στο αποτέλεσμα τις εγγραφές του ενός πίνακα που δεν αντιστοιχούν με καμία από τις εγγραφές του άλλου (χρησιμοποιεί τα null σαν τιμές στα πεδία των αναντίστοιχων εγγραφών του άλλου πίνακα).
Οι Τύποι Σύζευξης δύο πινάκων είναι (η λέξη outer προαιρετική):
Η Εσωτερική σύζευξη Πελατης Δανειζομενος στην SQL Πελατης inner join Δανειζομενος on Πελατης.ΟνομαΠελατη= Δανειζομενος.ΟνομαΠελατη Η Αριστερά εξωτερική σύζευξη Πελατης Δανειζομενος: select * from Πελατης left join Δανειζομενος on Πελατης.ΟνομαΠελατη = Δανειζομενος.ΟνομαΠελατη Η Δεξιά εξωτερική σύζευξη Πελατης Δανειζομενος: Πελατης right join Δανειζομενος on
Η Πλήρης εξωτερική σύζευξη Πελατης Δανειζομενος: Είναι η ένωση (union) αριστερής και δεξιάς εξωτερικής σύζευξης.
Γενικά είναι Πελατης left join Δανειζομενος on Πελατης.ΟνομαΠελατη = Δανειζομενος.ΟνομαΠελατη ) ( select * from Πελατης right join Δανειζομενος on Πελατης.ΟνομαΠελατη = Δανειζομενος.ΟνομαΠελατη ) ε) εξηγησεισ: NULL Τιμές Είναι πιθανό για τις γραμμές ενός πίνακα να έχουν τιμή null (κενή τιμή) σε κάποιο πεδίο.
NULL τιμές εμφανίζονται και στην εξωτερική σύζευξη δύο πινάκων (left join, right join).
Το αποτέλεσμα σύγκρισης με μια τιμή null είναι unknown (ούτε true, ούτε false).
Επίσης το αποτέλεσμα οποιασδήποτε αριθμητικής έκφρασης είναι null όταν κάποια τιμή που περιλαμβάνει είναι null.
Τότε η πρόταση where βγαίνει false και η σειρά δεν επιλέγεται.
H λέξη κλειδί is null (is not null) μπορεί να χρησιμοποιηθεί σε μια συνθήκη για να ελέγξουμε αν μια τιμή είναι null και να ανακτήσουμε την αντίστοιχη σειρά.
εμφωλιασμενα υποερωτηματα ΜΕ ΤΕΛΕΣΤΕΣ ΣΥΓΚΡΙΣΗΣ
Βρείτε όλα τα στοιχεία των πελατών που μένουν στην ίδια πόλη με τον Ευσταθίου (βρείτε πρώτα όλα τα στοιχεία των πελατών από τον πίνακα Πελατης έπειτα βρείτε με υποερώτημα την πόλη του Ευσταθίου και χρησιμοποιείστε το υποερώτημα σαν τιμή σύγκρισης στο πεδίο Πολη του εξωτερικού ερωτήματος).
Βρείτε όλα τα στοιχεία του Πελάτη με το μεγαλύτερο Ποσό Δανείου (βρείτε πρώτα όλα τα στοιχεία των πελατών που έχουν δάνειο από τη σύζευξη των πινάκων Πελατης, Δανειζομενος, Δανειο, έπειτα βρείτε με υποερώτημα το μεγαλύτερο ποσό Δανείου και χρησιμοποιείστε το υποερώτημα σαν τιμή σύγκρισης στο πεδίο Ποσο του εξωτερικού ερωτήματος).
Βρείτε όλα τα στοιχεία των Πελατών με Ποσό Δανείου μικρότερο από το μέσο ποσό (βρείτε πρώτα όλα τα στοιχεία των πελατών που έχουν δάνειο από τη σύζευξη των πινάκων Πελατης, Δανειζομενος, Δανειο, έπειτα βρείτε με υποερώτημα το μέσο ποσό Δανείου και χρησιμοποιείστε το υποερώτημα σαν τιμή σύγκρισης στο πεδίο Ποσο του εξωτερικού ερωτήματος).
Βρείτε όλα τα στοιχεία του Υποκαταστήματος με το μεγαλύτερο Ποσό Δανείου (βρείτε πρώτα όλα τα στοιχεία των Υποκαταστημάτων που έχουν Δάνεια από τη σύζευξη των πινάκων Υποκαταστημα, Δανειο, έπειτα βρείτε με υποερώτημα το μεγαλύτερο ποσό Δανείου και χρησιμοποιείστε το υποερώτημα σαν τιμή σύγκρισης στο πεδίο Ποσο του εξωτερικού ερωτήματος).
Βρείτε όλα τα στοιχεία του Υποκαταστήματος με το μικρότερο Υπόλοιπο λογαριασμού (βρείτε πρώτα όλα τα στοιχεία των Υποκαταστημάτων που έχουν Λογαριασμούς από τη σύζευξη των πινάκων Υποκαταστημα, Λογαριασμος, έπειτα βρείτε με υποερώτημα το μικρότερο υπόλοιπο λογαριασμού και χρησιμοποιείστε το υποερώτημα σαν τιμή σύγκρισης στο πεδίο Υπολοιπο του εξωτερικού ερωτήματος).
Βρείτε όλα τα στοιχεία του πελάτη με το μικρότερο υπόλοιπο λογαριασμού στο υποκατάστημα Βενιζέλου (βρείτε πρώτα όλα τα στοιχεία των πελατών που έχουν Λογαριασμό στο υποκατάστημα Βενιζέλου από τη σύζευξη των πινάκων Πελατης, Καταθετης, Λογαριασμος, έπειτα βρείτε με υποερώτημα το μικρότερο υπόλοιπο λογαριασμού στο υποκατάστημα Βενιζέλου και χρησιμοποιείστε το υποερώτημα σαν τιμή σύγκρισης στο πεδίο Υπολοιπο του εξωτερικού ερωτήματος).
Βρείτε όλα τα στοιχεία των Υποκαταστημάτων με μέσω υπόλοιπο λογαριασμού μεγαλύτερο από 2000 (βρείτε πρώτα όλα τα στοιχεία των Υποκαταστημάτων από τον πίνακα Υποκαταστηματα έπειτα βρείτε με υποερώτημα από τον πίνακα Λογαριασμος και χρήση group by και having, τα Ονόματα Υποκαταστημάτων με avg(Υπόλοιπο)>2000 και χρησιμοποιείστε το υποερώτημα σαν τιμή σύγκρισης στο πεδίο ΟνομαΥποκαταστηματος του εξωτερικού ερωτήματος).
Εδώ το αποτέλεσμα του υποερωτήματος είναι μόνο μία εγγραφή και η ισότητα = δεν βγάζει σφάλμα.
Εάν είναι παραπάνω από μία χρειάζεται ο τελεστή in στο πεδίο ΟνομαΥποκαταστηματος του εξωτερικού ερωτήματος).
εξηγησεισ: εμφωλιασμενα υποερωτηματα ΜΕ ΤΕΛΕΣΤΕΣ ΣΥΓΚΡΙΣΗΣ Ένα υποερώτημα είναι μια έκφραση select – from – where που είναι εμφωλιασμένη (ένθετη) μέσα σε μια άλλη έκφραση.
Τότε το πρώτο ονομάζεται εξωτερικό ερώτημα και το δεύτερο εσωτερικό υποερώτημα.
Υπολογίζεται πρώτα το εσωτερικό υποερώτημα και κατόπιν το εξωτερικό εφαρμόζοντας σε αυτό το αποτέλεσμα του εσωτερικού ερωτήματος.
Εξαίρεση αποτελεί η περίπτωση των συσχετιζόμενων υποερωτημάτων όπου το εσωτερικό υποερώτημα θα υπολογιστεί για κάθε γραμμή (συστοιχία) του εξωτερικού ερωτήματος.
Σαν τελεστές σύγκρισης χρησιμοποιούνται οι < <= > >= = <> Τα συνηθέστερα υποερωτήματα (όπως τα Ζ2 έως Ζ7) είναι αυτά που έχουν ως αποτέλεσμα μία τιμή συναθροιστικής συνάρτησης max, min, avg, sum, count η οποία χρησιμοποιείται σαν τιμή σύγκρισης για να βρεθούν με το εξωτερικό ερώτημα τα στοιχεία των κατόχων αυτής της τιμής.
Τα εμφωλιασμένα υποερωτήματα χρησιμοποιούνται όταν δεν γνωρίζουμε την τιμή σύγκρισης στο κατηγόρημα σε προτάσεις where ή having.
Στις περιπτώσεις όπου το εσωτερικό υποερώτημα θα έχει ως αποτέλεσμα την επιστροφή δύο ή περισσοτέρων τιμών χρησιμοποιούνται οι τελεστές in, not in, some, all, exists . η) εμφωλιασμενα υποερωτηματα ΜΕ ΤΕΛΕΣΤΕΣ Βρείτε τα ονόματα των πελατών που έχουν και λογαριασμό όσο και Δανειο στην τράπεζα (δηλαδή η πράξη της τομής, Καταθετης που είναι και Δανειζομενος με χρήση του in).
Βρείτε τα ονόματα των πελατών που έχουν πάρει Δανειο και δε λέγονται “Παπαδόπουλος” ή “Πέτρου” (με χρήση του τελεστή not in στο πεδίο ΟνομαΠελατη του πίνακα Δανειζομενος).
Βρείτε όλα τα στοιχεία των Υποκαταστημάτων με μέσω υπόλοιπο λογαριασμού μεγαλύτερο από 1000 (Βρείτε με υποερώτημα από τον πίνακα Λογαριασμος και χρήση group by και having, τα Ονόματα Υποκαταστημάτων με avg(Υπόλοιπο)>1000.
Εδώ είναι περισσότερα από ένα.
Χρησιμοποιείστε το υποερώτημα σαν σύνολο τιμών σύγκρισης με χρήση του τελεστή in στο πεδίο ΟνομαΥποκαταστηματος του εξωτερικού ερωτήματος).
Βρείτε τα ονόματα υποκαταστημάτων με Ενεργητικο μεγαλύτερο από το Ενεργητικο ενός τουλάχιστον υποκαταστήματος της Πολης των Σερρών (με χρήση του τελεστή some στο πεδίο Ενεργητικο του Πίνακα Υποκαταστημα.
Το υποερώτημα θα βρίσκει το Ενεργητικο των Υποκαταστημάτων της Πολης των Σερρών από τον Πίνακα Υποκαταστημα).
Βρείτε τα στοιχεία των πελατών με Ποσο Δανείου μικρότερο από κάποιου (ένα τουλάχιστον) Πελάτη που βρίσκεται στην Πολη της Θεσσαλονίκης (με χρήση του τελεστή some στο πεδίο ποσό, από τη σύζευξη των πινάκων Πελατης, Δανειζομενος, Δανειο.
Το υποερώτημα θα βρίσκει τα Ποσά Δανείων των Πελατών που βρίσκονται στην Πολη της Θεσσαλονίκης).
Βρείτε τα ονόματα των υποκαταστημάτων που έχουν Ενεργητικο μεγαλύτερο από το Ενεργητικο όλων των υποκαταστημάτων της Πολης των Σερρών (όπως το Η3 με χρήση όμως του τελεστή all στο πεδίο Ενεργητικο).
Βρείτε τα ονόματα πελατών με Υπόλοιπο Λογαριασμού μεγαλύτερο από το Υπόλοιπο όλων των Πελατών που βρίσκονται στη Σέρρες (χρήση του τελεστή all).
Βρείτε το Υποκατάστημα με τους περισσότερους Λογαριασμούς (δηλαδή το μεγαλύτερο Πλήθος Λογαριασμών με χρήση του τελεστή all).
Με χρήση της count και ομαδοποίηση ως προς ΟνομαΥποκαταστήματος μπορούμε από τον πίνακα Λογαριασμός να βρούμε το πλήθος των Λογαριασμών σε κάθε Υποκατάστημα ΟνομαΥποκαταστηματος, count(*) as ΠληθοςΛογαριασμων
Πως θα βρείτε τη μέγιστη (ή ελάχιστη για τους λιγότερους λογαριασμούς) τιμή μιας στήλης συναθροιστικής συνάρτησης?.
Με την παρακάτω σύνταξη με χρήση του τελεστή all στην πρόταση having η) ΕΞΗΓΗΣΕΙΣ: εμφωλιασμενα υποερωτηματα ΜΕ ΤΕΛΕΣΤΕΣ Μια συνήθης χρήση των εμφωλιασμένων υποερωτημάτων είναι η εκτέλεση ελέγχων και συγκρίσεων για: τη συμμετοχή σε κάποιο σύνολο , τη σύγκριση συνόλων, τον έλεγχο για κενά σύνολα Τα εμφωλιασμένα υποερωτήματα χρησιμοποιούνται είτε στην πρόταση where είτε στην πρόταση having.
Οι τελεστές που χρησιμοποιούνται για τους ελέγχους προηγούνται ενός υποερωτήματος και χρησιμοποιούνται όταν το υποερώτημα είναι πιθανό να έχει ως αποτέλεσμα την επιστροφή δύο ή περισσοτέρων τιμών.
Οι τελεστές είναι: · (>, <, =, κλπ) some/any/all (έλεγχος για κενά σύνολα) Ως τελεστές σύγκρισης πριν από το some ή το all χρησιμοποιούνται οι <, <=, >, >=, =, <>.
Ο τελεστής in , not in ελέγχει αν μια σειρά (πλειάδα) ανήκει (ή όχι) σε ένα σύνολο από σειρές τιμών που έχουν προκύψει από μια έκφραση υποερωτήματος select-from-where.
Π.χ.
Βρείτε τα ονόματα των πελατών που έχουν και λογαριασμό όσο και Δανειο στην τράπεζα. select distinct ΟνομαΠελατη where ΟνομαΠελατη in (select ΟνομαΠελατη from Καταθετης) Το υποερώτημα έχει ως αποτέλεσμα την επιστροφή δύο ή περισσοτέρων τιμών και δεν ισχύει η συνθήκη ΟνομαΠελατη = (.).
Πρέπει να γράψουμε ΟνομαΠελατη in (.).
Π.χ.
Βρείτε τα ονόματα των πελατών που έχουν πάρει Δανειο και δε λέγονται “Παπαδόπουλος” ή “Πέτρου”. select distinct ΟνομαΠελατη where ΟνομαΠελατη not in (“Παπαδόπουλος” , “Πέτρου”) Ο τελεστής some (any) Ο τελεστής some (any) χρησιμοποιείται για τη σύγκριση συνόλων.
Έχει τη σημασία του τουλάχιστον ένα (ή κάποιο) από τα στοιχεία ενός συνόλου.
Π.χ.
Βρείτε τα ονόματα υποκαταστημάτων με Ενεργητικο μικρότερο από το Ενεργητικο ενός τουλάχιστον υποκαταστήματος της Πολης των Σερρών.
Ενεργητικο <some (select Ενεργητικο
Ο τελεστής all χρησιμοποιείται για τη σύγκριση συνόλων.
Έχει τη σημασία από όλα (ή κάθε ένα από) τα στοιχεία ενός συνόλου.
Π.χ.
Βρείτε τα ονόματα των υποκαταστημάτων που έχουν Ενεργητικο μικρότερο από το Ενεργητικο όλων των υποκαταστημάτων της Πολης της Θεσσαλονίκης. select distinct ΟνομαΥποκαταστηματος where Ενεργητικο < all ( select Ενεργητικο from Υποκαταστημα where Πολη = “Θεσσαλονίκη” ) Επίσης το (<> all) είναι ισοδύναμο του not in.
Παραδείγματα με τελεστες in, not in , some , all
Μπορούμε επίσης να χρησιμοποιήσουμε το in (not in) για να ελέγξουμε ταυτόχρονα παραπάνω από ένα γνώρισμα
Επίσης ισχύει (= some) ισοδύναμο. του in.
Ωστόσο ((some) όχι ισοδύναμο του not in Επίσης το (( all) είναι ισοδύναμο του not in.
Από την άλλη το (= all) ελέγχει αν το υποερώτημα έχει μόνο μία τιμή άρα δεν είναι ισοδύναμο του in. (α) Έχουμε δει ότι η σύνταξη για την εισαγωγή μίας εγγραφής σε έναν πίνακα είναι INSERT INTO table_name VALUES (value1, value2,....) ή (β) Για να εισάγουμε μαζικά πολλές εγγραφές γράφουμε την ερώτηση που το αποτέλεσμα της θα εισάγεται στη σχέση.
Θ01.Να αποθηκεύσετε και να εκτελέσετε ερώτημα SQL που θα εισάγει έναν νέο πελάτη με ΟνομαΠελατη 'Βασιλακόπουλος', οδο 'Εγνατίας 40' και Πολη 'Σέρρες'.
Θ02.Να δημιουργήσετε ένα νέο υποκαταστημα με ΟνομαΥποκαταστηματος 'Μητροπόλεως', Πολη 'Σέρρες' και ενεργητικο 7000000.
Θ03.Να δημιουργήσετε ένα νέο λογαριασμό στο νέο υποκατάστημα για τον νέο πελατη που εισάγατε (θα πρέπει να τρέξετε δύο insert intovalues, ένα που θα εισάγει έναν νέο λογαριασμό και ένα που θα εισάγει έναν νέο καταθέτη).
Θ04.Εισαγωγή null τιμών: Εισάγετε νέο πελάτη 'Smith' με άγνωστα τα υπόλοιπα στοιχεία του insert into Πελατης(ΟνομαΠελατη,Οδος,Πολη) values ('Smith', null, null)
Για κάθε πελάτη που έχει πάρει δάνειο από το υποκατάστημα 'Βενιζέλου' προστίθεται ως δώρο ένας λογαριασμός των 200 (Παράδειγμα για την μαζική εισαγωγή δεδομένων) : insert into Λογαρισμος select ΑριθμοςΔανειου, ΟνομαΥποκαταστηματος, 200 where ΟνομαΥποκαταστηματος = 'Βενιζέλου' Πρέπει πρώτα να υπολογιστεί το select πλήρως και μετά να γίνει η εισαγωγή.
Να δημιουργήσετε ένα αντίγραφο πίνακα για τα δάνεια της τράπεζας (παράδειγμα για την μαζική εισαγωγή δεδομένων με δημιουργία αντιγράφου πίνακα) : create table ΑντιγραφοΔανειων (ΑριθμοςΔανειου varchar(10) not null , primary key (ΑριθμοςΔανειου) );
Τρέχετε το ερώτημα και δημιουργείται ο πίνακας και έπειτα τρέχετε το παρακάτω insert into ΑντιγραφοΔανειων select * from Δανειο
Να δημιουργήσετε ένα αντίγραφο πίνακα για τους Λογαριασμούς της Τράπεζας Μπορούμε να σβήσουμε μόνο ολόκληρες εγγραφές και όχι συγκεκριμένα πεδία (για το κάθε πεδίο ξεχωριστά απλώς το θέτουμε ίσο με null) με τη σύνταξη: Σβήνει όλες τις εγγραφές του πίνακα R για τις οποίες ισχύει το κατηγόρημα P.
Προσοχή γιατί όταν λείπει η πρόταση where σβήνονται όλες οι εγγραφές ενός πίνακα.
Να διαγράψετε όλους τους λογαριασμούς του Παπαδόπουλου (εδώ δεν μπορούμε να διαγράψουμε κατευθείαν τους λογαριασμούς του επειδή έχει συσχετιζόμενες εγγραφές στον πίνακα καταθέτης,δηλαδή θα τις διαγράψουμε πρώτα από τον πίνακα καταθετης) delete from καταθετης where ΟνομαΠελατη = 'Παπαδόπουλος'
Αφού διαγράφηκε από τους καταθέτες πρέπει να διαγραφεί και από τους λογαριασμούς.
Πως όπως αφού δεν υπάρχουν πια τα στοιχεία του στον πίνακα καταθέτες? Διαγράφουμε τις αναντίστοιχες εγγραφές: τους λογαριασμούς που δεν υπάρχουν πια στον πίνακα Καταθετης delete from Λογαριασμος where ΑριθμοςΛογαριασμου not in (select ΑριθμοςΛογαριασμου from καταθετης) Όταν διαγράφουμε εγγραφές, πρέπει να διαγράφουμε και όλα τα δεδομένα που συσχετίζονται μ’ αυτές αν στους περιορισμούς ξένων κλειδιών foreign key δεν έχουμε προσθέσει το on delete cascade.
Επίσης πρέπει να προσέχουμε την αντίστροφη σειρά με την οποία θα γίνονται οι διαγραφές.
Η τράπεζα θέλει να κλείσει όλα τα υποκαταστήματά της που βρίσκονται στο Βόλο.
Βρείτε τη σειρά με την οποία θα εκτελεστούν τα παρακάτω ερωτήματα διαγραφής delete from Υποκαταστημα where Πολη = 'Βόλος' ; --Πρέπει να διαγράψουμε και όλους τους λογαριασμούς: delete from Λογαριασμος where ΟνομαΥποκαταστηματος in ( select ΟνομαΥποκαταστηματος from Υποκαταστημα where Πολη = 'Βόλος' ) ; --Πρέπει να διαγράψουμε και όλα τα Δανεια: delete from Δανειο where ΟνομαΥποκαταστηματος in ( --Πρέπει να διαγράψουμε και όλους τους Καταθέτες: delete from Καταθετης where ΑριθμοςΛογαριασμου in ( select ΑριθμοςΛογαριασμου from Λογαριασμος where ΟνομαΥποκαταστηματος in ( select ΟνομαΥποκαταστηματος from Υποκαταστημα where Πολη = 'Βόλος' ) ) ; --Πρέπει να διαγράψουμε και όλους τους Δανειζομενους: delete from Δανειζομενος where ΑριθμοςΔανειου in ( select ΑριθμοςΔανειου from Δανειο where ΟνομαΥποκαταστηματος in ( select ΟνομαΥποκαταστηματος from Υποκαταστημα where Πολη = 'Βόλος' ) );
Έχουμε δει ότι η γενική σύνταξη είναι update όνομα-πίνακα set όνομα-στήλης = νέα-τιμή where P Η ενημέρωση μπορεί να γίνει και σε περισσότερες στήλες
Έστω ότι ο πελάτης Smith αλλάζει διεύθυνση update Πελατης set Οδος = 'Ερμού 4' , Πολη= 'Σέρρες' where ΟνομαΠελατη = 'Smith' Η ενημέρωση γίνεται σε όλες τις σειρές που ικανοποιούν το κατηγόρημα Ρ Για να ‘σβήσουμε’ ένα πεδίο το θέτουμε απλά ίσο με null:
Έστω ότι ο πελάτης Smith δεν έχει Πολη update Πελατης set Οδος = null
Παράδειγμα: Αύξηση όλων των καταθέσεων που είναι μεγαλύτερες των 100 κατά 5% λόγω τοκισμού update Λογαριασμος set Υπολοιπο = Υπολοιπο * 1.05 where Υπολοιπο > 100
Παράδειγμα: στους πελάτες που έχουν υπόλοιπο <= 1000 η τράπεζα δίνει αύξηση 5% και στους πελάτες που έχουν υπόλοιπο > 1000 δίνει 9%: update Λογαριασμος set Υπολοιπο = Υπολοιπο * 1.09 where Υπολοιπο > 1000 ; update Λογαριασμος set Υπολοιπο = Υπολοιπο * 1.05 where Υπολοιπο < 1000;
Ποιο update πρέπει να τρέξουμε πρώτα; (σωστά είναι, αλλά αν τα εκτελούσαμε με την σειρά της εκφώνησης θα ήταν λάθος)
Αύξηση όλων των υπολοίπων που είναι μεγαλύτερα από τον μέσο όρο κατά 5% set Υπολοιπο = Υπολοιπο * 1.05 where Υπολοιπο > ( select avg(Υπολοιπο) συσχετιζομενα εμφωλιασμενα υποερωτηματα ΜΕ ΤΕΛΕΣΤΕΣ exists, not exists, & ΠΑΡΑΓΟΜΕΝΑ Βρείτε τους πελάτες που έχουν καταθέσεις και έχουν πάρει Δανειο (δηλαδή Καταθετης που είναι και Δανειζομενος, συσχετιζόμενο υποερώτημα με χρήση exists).
Βρείτε τα ονόματα των πελατών που έχουν καταθέσεις και δεν έχουν πάρει Δανειο (δηλαδή Καταθετης που δεν είναι Δανειζομενος, συσχετιζόμενο υποερώτημα με χρήση not exists).
ΔΙΑΙΡΕΣΗ.
Βρείτε τα ονόματα των πελατών που έχουν καταθέσεις σε όλα τα υποκαταστήματα της Πολης της Θεσσαλονίκης (Αλεξίου).
ΔΙΑΙΡΕΣΗ.
Βρείτε τα ονόματα των πελατών που έχουν καταθέσεις σε όλα τα υποκαταστήματα της Πολης των Σερρών (Κυριάκου, Λάμπρου, Πέτρου).
Βρείτε τα Υποκαταστήματα για τα οποία το μέσο υπόλοιπο των λογαριασμών τους είναι μικρότερο των 1000 (με Παραγόμενο Υποερώτημα στο from και όχι με group by και having).
εξηγησεισ: συσχετιζομενα υποερωτηματα ΜΕ Ο τελεστής EXISTS χρησιμοποιείται στον έλεγχο για κενά σύνολα (κενές σχέσεις).
Ο τελεστής EXISTS επιστρέφει true αν η υποερώτηση δεν είναι κενή.
Χρησιμοποιείται συνήθως σε συσχετιζόμενα υποερωτήματα.
Π.χ.
Βρείτε τους πελάτες που έχουν καταθέσεις και έχουν πάρει Δανειο (δηλαδή Καταθετης που είναι και Δανειζομενος, είναι η πράξη της τομής). where Καταθετης.ΟνομαΠελατη = Δανειζομενος.ΟνομαΠελατη ) Είναι συσχετιζόμενο υποερώτημα.
Θα υπολογιστεί για κάθε τιμή της μεταβλητής Δανειζομενος.ΟνομαΠελατη που παίρνει από το εξωτερικό ερώτημα.
Διαδικασία εκτέλεσης: Το σύστημα εξετάζει στο εξωτερικό ερώτημα κάποια γραμμή του πίνακα Δανειζομενος, έστω αυτή με ΟνομαΠελατη =”Πέτρου”.
Τότε η μεταβλητή Δανειζομενος.ΟνομαΠελατη παίρνει την τιμή ”Πέτρου”, οπότε το σύστημα εκτελεί το παρακάτω υποερώτημα (select * from Καταθετης where Καταθετης.ΟνομαΠελατη = ”Πέτρου”) και επιστρέφεται το σύνολο τιμών μιας γραμμής αν υπάρχει Καταθετης με όνομα ”Πέτρου” ή καμίας γραμμής (κενό σύνολο) αν δεν υπάρχει Καταθετης με όνομα ”Πέτρου”.
Τώρα το σύστημα μπορεί να ολοκληρώσει την επεξεργασία της γραμμής με ΟνομαΠελατη =”Πέτρου” του πίνακα Δανειζομενος.
Επιλέγει τη γραμμή αν το σύνολο που επιστρέφεται από το υποερώτημα δεν είναι κενό (η πρόταση where exists βγάζει true και η γραμμή επιλέγεται).
Κατόπιν το σύστημα συνεχίζει επαναλαμβάνοντας την ίδια διαδικασία για άλλη γραμμή του πίνακα Δανειζομενος μέχρι να εξεταστούν όλες οι γραμμές του.
Ο τελεστής not exists: επιστρέφει true αν η υποερώτηση είναι κενή Π.χ.
Βρείτε τα ονόματα των πελατών που έχουν πάρει Δανειο και δεν έχουν καταθέσεις (δηλαδή Δανειζομενος που δεν είναι Καταθετης, είναι η πράξη της διαφοράς) where Καταθετης.ΟνομαΠελατη=Δανειζομενος.ΟνομαΠελατη ) Αφού ο τελεστής not exists: επιστρέφει true αν η υποερώτηση είναι κενή, μπορεί να χρησιμοποιηθεί για έλεγχο αν η σχέση A περιέχει όλη τη σχέση B Άρα B except A ( null.
Τότε not exists (Β except Α) ( true Χρησιμοποιείται στην πράξη της διαίρεσης της σχεσιακής άλγεβρας.
Συνήθως αναγνωρίζουμε ότι πρόκειται για διαίρεση από τη λέξη όλα, ή για όλα στην ερώτηση.
Η διαίρεση γίνεται με διαδοχικές αφαιρέσεις (Β except Α) για κάθε τιμή της μεταβλητής που παίρνει από το εξωτερικό ερώτημα.
Π.χ.
Βρείτε τα ονόματα των πελατών που έχουν καταθέσεις σε όλα τα υποκαταστήματα της Πολης της Πάτρας. select distinct S.ΟνομαΠελατη where not exists ( select ΟνομαΥποκαταστηματος where Πολη = "Πάτρα" and ΟνομαΥποκαταστηματος not in from Καταθετης, Λογαριασμος where Καταθετης.ΟνομαΠελατη = S.ΟνομαΠελατη and Καταθετης.ΑριθμόςΛογαριασμού = Λογαριασμος.ΑριθμόςΛογαριασμού ) ) Όπου Α είναι τα Υποκαταστήματα των Καταθετών, Β είναι τα Υποκαταστήματα της Πάτρας.
Ο υπολογισμός γίνεται για κάθε καταθέτη (για κάθε S.ΟνομαΠελατη).
εξηγησεισ: ΠΑΡΑΓΟΜΕΝΕΣ ΣΧΕΣΕΙΣ (ΠΡΟΣΩΡΙΝΕΣ) Εκτός από πίνακες ή και αποθηκευμένα ερωτήματα (Όψεις), η SQL-92 δίνει τη δυνατότητα μια υποερώτηση να χρησιμοποιηθεί στο from σαν προσωρινή.
Τότε πρέπει να τις δοθεί ένα όνομα χρησιμοποιώντας το as (η χρήση του as στην πρόταση from είναι προεραιτική).
Π.χ.
Βρείτε τα Υποκαταστήματα για τα οποία το μέσο υπόλοιπο των λογαριασμών τους είναι μεγαλύτερο των 1000. select Αποτελεσμα.ΟνομαΥποκαταστηματος, Αποτελεσμα.ΜεσοΥπολοιπο (select ΟνομαΥποκαταστηματος, avg(Υπόλοιπο) as ΜεσοΥπολοιπο group by ΟνομαΥποκαταστηματος ) as Αποτελεσμα where Αποτελεσμα.ΜεσοΥπολοιπο > 1000 Σημειώστε ότι εδώ δεν χρειάζεται να χρησιμοποιήσουμε την πρόταση having για τη συνθήκη avg(Υπόλοιπο)>1000 αφού υπολογίστηκε στην πρόταση from η προσωρινή σχέση Αποτελεσμα, και τα γνωρίσματά της, όπως το Αποτελεσμα.ΜεσοΥπολοιπο μπορούν να χρησιμοποιηθούν κατευθείαν στην πρόταση where.
Θέλουμε να δημιουργήσουμε μία σχεσιακή βάση δεδομένων που θα κρατά πληροφορίες για συγγραφείς βιβλίων και
Στην αρχή δεν γνωρίζουμε τον τρόπο με τον οποίο θα συνδέονται μεταξύ τους.
Πρέπει να καθορίσουμε πρώτα τις συσχετίσεις μεταξύ αυτών των οντοτήτων.
Για παράδειγμα η συσχέτιση των βιβλίων με τις κατηγορίες βιβλίων είναι προφανής, όπως και αυτές των βιβλίων με τους συγγραφείς, και των βιβλίων με τις κατηγορίες βιβλίων.
Και οι τρείς συσχετίσεις εδώ είναι ένα-προς-πολλά με το σύμβολο του πολλά από την μεριά των βιβλίων.
Μένει στην ουσία να καθορίσουμε όλες τις συσχετίσεις των παραγγελιών βιβλίων.
Το κύριο τμήμα της βάσης δεδομένων Βιβλιοπωλείο απορρέει από την διαπίστωση ότι σε ένα Βιβλιοπωλείο οι πελάτες θα κάνουν, απευθυνόμενοι σε υπαλλήλους παραγγελίες για βιβλία.
Πως συσχετίζονται οι πελάτες με τα βιβλία και τους υπαλλήλους; με την τριαδική συσχέτιση παραγγελίες.
Η αρχική τριαδική συσχέτιση ‘Παραγγελίες’ θα μετατραπεί σε τύπο οντότητας με δικό της κλειδί και τρεις δυαδικές συσχετίσεις όπως στο παρακάτω διάγραμμα οντοτήτων-συσχετίσεων (ER).
Μετατροπή της τριαδικής συσχέτισης παραγγελίες σε τρεις δυαδικές.
Κάθε τύπος οντότητας (τα ορθογώνια) θα έχει το δικό του κλειδί.
Αν αντικαταστήσουμε τα βιβλία με προϊόντα γενικού είδους έχουμε τη βάση για κάθε είδους σύστημα διαχείρισης παραγγελιών.
Το μόνο που απομένει είναι να προσδιορίσουμε τον λόγο πληθικότητας των τύπων συσχετίσεων (οι ρόμβοι).
Ο λόγος πληθικότητας (cardinality) ενός δυαδικού τύπου συσχετίσεων ορίζει το πόσες οντότητες από τον πρώτο τύπο οντοτήτων στην συσχέτιση μπορούν να συνδεθούν με τις οντότητες από τον δεύτερο τύπο.
Στην ουσία σημαίνει πόσες εγγραφές από την μία πλευρά της δυαδικής συσχέτισης μπορούν να συνδεθούν με τις εγγραφές τις άλλης πλευράς.
Με απλές ερωταποκρίσεις: Ένας πελάτης κάνει πολλές παραγγελίες αλλά μία παραγγελία γίνεται από έναν μόνο πελάτη.
Άρα η συσχέτιση πελάτες-κάνουν-παραγγελίες είναι ένα προς πολλά.
Ένα βιβλίο μπορεί να περιέχεται σε πολλές παραγγελίες και μία παραγγελία μπορεί να περιέχει πολλά βιβλία.
Άρα η συσχέτιση παραγγελίες-έχουν-βιβλία είναι πολλά προς πολλά.
Ένας υπάλληλος μπορεί να χειριστεί πολλές παραγγελίες αλλά μία παραγγελία την χειρίζεται ένας μόνο υπάλληλος.
Άρα η συσχέτιση υπάλληλοι-χειρίζονται-παραγγελίες είναι ένα προς πολλά, και έτσι προκύπτει το διάγραμμα Οντοτητων-Συσχετισεων (ER).
Έτσι το διάγραμμα μας δείχνει ότι θα πρέπει, μετατρέποντάς το στο σχεσιακό μοντέλο, να δημιουργήσουμε 4 πίνακες για τις τέσσερις οντότητες και έναν επιπλέον πίνακα για την συσχέτιση παραγγελίες-έχουν-βιβλία επειδή είναι πολλά προς πολλά, που στα εργαστήρια τον ονομάζουμε ΣτοιχείαΠαραγγελίας.
Άρα ένα σύστημα διαχείρισης παραγγελιών θα έχει σαν κορμό τους πίνακες Υπάλληλοι, Πελάτες, Παραγγελίες, ΣτοιχείαΠαραγγελίας, Προϊόντα.
ΤΟ ΜΟΝΤΕΛΟ ΟΝΤΟΤΗΤΩΝ-ΣΥΣΧΕΤΙΣΕΩΝ (τετράγωνα - οντότητες, ρόμβοι -συσχετίσεις)
Στο τελικό μοντέλο Οντοτήτων-συσχετίσεων (ER) έχουμε καθορίσει επιπλέον ότι σε μία κατηγορία ανήκουν πολλά βιβλία, ότι ένας εκδότης εκδίδει πολλά βιβλία και ότι ένας συγγραφέας γράφει πολλά βιβλία όπως είπαμε και στην αρχή.
Η τελευταία συσχέτιση συγγραφέας-γράφει-βιβλία θα μπορούσε να ήταν πολλά-προς-πολλά για να καλύψει και την περίπτωση των συν-συγγραφέων, αλλά εδώ μας αρκεί η καταγραφή μόνο του πρώτου ονόματος.
Η μετατροπή του μοντέλου ER στο σχεσιακό μοντέλο είναι σχετικά εύκολη.
Για κάθε οντότητα δημιουργούμε πίνακα, για κάθε δυαδική συσχέτιση ένα προς πολλά προσθέτουμε το πρωτεύον κλειδί της πλευράς του ένα στην πλευρά του πολλά, όπου γίνεται ξένο κλειδί, και για κάθε δυαδική συσχέτιση πολλά-προς-πολλά δημιουργούμε επιπλέον πίνακα με ξένα κλειδιά τα πρωτεύοντα κλειδιά των δύο επιμέρους οντοτήτων.
ΤΟ ΣΧΕΣΙΑΚΟ ΜΟΝΤΕΛΟ ΜΕ ΤΟ ΔΙΑΓΡΑΜΜΑ ΠΕΡΙΟΡΙΣΜΩΝ ΑΝΑΦΟΡΙΚΗΣ ΑΚΕΡΑΙΟΤΗΤΑΣ.
Η βάση αποτελείται από τους παρακάτω πίνακες.
Το σχεσιακό μοντέλο δείχνει ποια είναι η συνολική δομή της βάσης.
Το διάγραμμα περιορισμών αναφορικής ακεραιότητας πρέπει να δείχνει (με βέλη) από που θα παίρνουν τις τιμές τους τα ξένα κλειδιά.
Προσέξτε το επιπλέον πεδίο ΤελικηΤιμη που αποθηκεύει την τιμή πώλησης.
Η τιμή αυτή πρέπει πρώτα να αντιγράφεται από τον πίνακα προϊόντα και να μπορεί να αλλάξει για να μπορεί να εκδοθεί ένα τιμολόγιο.
Πως συνδέεται μία εγγραφή από έναν πίνακα με μία εγγραφή από έναν άλλο πίνακα (π.χ. η παραγγελία με ΚωδΠαραγγελίας 1 με τον πελάτη με ΚωδΠελάτη 4);
Με ένα ζεύγος τιμών των πρωτευόντων κλειδιών τους {1, 4}.
Μία παραγγελία συνδέεται με έναν πελάτη με ένα ζεύγος τιμών {ΚωδΠαραγγελιας, ΚωδΠελατη} που αποθηκεύεται στον πίνακα ΠΑΡΑΓΓΕΛΙΕΣ.
Μία παραγγελία συνδέεται με έναν υπάλληλο με ένα ζεύγος τιμών {ΚωδΠαραγγελιας, ΚωδΥπαλληλου} που αποθηκεύεται στον πίνακα ΠΑΡΑΓΓΕΛΙΕΣ.
Μία παραγγελία συνδέεται με ένα βιβλίο με ένα ζεύγος τιμών {ΚωδΒιβλιου, ΚωδΠαραγγελιας} που αποθηκεύεται στον πίνακα ΣΤΟΙΧΕΙΑΠΑΡΑΓΓΕΛΙΑΣ.
Ένα βιβλίο συνδέεται με έναν συγγραφέα με ένα ζεύγος τιμών {ΚωδΒιβλιου, ΚωδΣυγγραφεα} που αποθηκεύεται στον πίνακα ΒΙΒΛΙΑ.
Ένα βιβλίο συνδέεται με έναν Εκδότη με ένα ζεύγος τιμών {ΚωδΒιβλιου, ΚωδΕκδοτη} που αποθηκεύεται στον πίνακα ΒΙΒΛΙΑ.
Ένα βιβλίο συνδέεται με μία Θεματική Κατηγορία με ένα ζεύγος τιμών {ΚωδΒιβλιου, ΚωδΚατηγοριας} που αποθηκεύεται στον πίνακα ΒΙΒΛΙΑ.
Αυτά τα ζεύγη τιμών {τιμήΑ, τιμήΒ} που στην ουσία το κάθε ένα συνδέει ένα μέλος του συνόλου Α με ένα μέλος του συνόλου Β ονομάζονται σχέσεις και οι βάσεις δεδομένων σχεσιακές βάσεις δεδομένων.
Αν είχαμε ένα πεδίο ορισμού x (1, 2, 3) και ένα πεδίο τιμών y (3, 6, 9) και θέλαμε να ορίσουμε την σταθερή στο χρόνο σχέση μεταξύ τους (1|3, 2|6, 3|9) τότε αυτή θα ονομάζονταν συνάρτηση (y=f(x)=3*x).
Το πρώτο χαρακτηριστικό των σχέσεων είναι ότι μεταβάλλονται με το χρόνο (εισαγωγές, διαγραφές, ενημερώσεις).
Το δεύτερο απορρέει από τον ορισμό του C.
Codd για μία σχέση. “Σχέση: Ένα υποσύνολο του καρτεσιανού γινομένου των υποκείμενων πεδίων ορισμού”.
Άρα δεν είναι δυνατόν να επιτρέπεται να αποθηκευτεί στη σχέση {ΚωδΠαραγγελιας, ΚωδΠελατη} ένας κωδικός πελάτη που δεν υπάρχει στον πίνακα πελάτες γι’ αυτό το λόγο υπάρχουν οι περιορισμοί ακεραιότητας αναφορών των τιμών αυτών σε όποιο πίνακα είναι ξένα κλειδιά.
Πως συνδέονται δύο Πίνακες;
Η σύνδεση δύο πινάκων επιτυγχάνεται µε τα κοινά πεδία τιμών τους (πρωτεύον κλειδί και ξένο κλειδί).
Μία σύνδεση γίνεται έτσι μέσω των κοινών τιμών (π.χ.
ΚωδΠελάτη) που ανήκουν και στους δύο πίνακες.
Μπορούμε έτσι να εφαρμόσουμε τη σύζευξη για να ενώσουμε τους δύο πίνακες.
Άρα σε τι χρησιμεύουν τα ξένα κλειδιά; "Δείχνουν" τις συσχετιζόμενες εγγραφές.
Αντικαθιστούν τους δείκτες (pointers) που έχουμε σε άλλα μοντέλα δεδομένων.
Το παρακάτω σχήμα βάσης δεδομένων είναι ένα μικρό κομμάτι από μία βάση που διατηρεί πληροφορίες για φοιτητές, τμήματα, μαθήματα.
Φαίνεται το σχεσιακό μοντέλο με το διάγραμμα περιορισμών αναφορικής ακεραιότητας.
Σημειώστε ότι στο διάγραμμα μερικά γνωρίσματα εμφανίζονται πολλές φορές.
Αυτό είδαμε ότι δεν είναι λάθος.
Προσφέρει τον τρόπο συσχέτισης (ή σύνδεσης) των πινάκων μεταξύ τους.
Οι υπογραμμίσεις δείχνουν τα πρωτεύοντα κλειδιά.
Τα βέλη δείχνουν που αναφέρονται οι τιμές των ξένων κλειδιών.
Οι πίνακες είναι αυτό-επεξηγηματικοί.
Ο πίνακας βαθμολογίες κρατά μόνο τον τελικό βαθμό.
Παρατηρήστε τον πίνακα Προαπαιτουμενα που προήλθε από αναδρομική συσχέτιση (τύπου πολλά προς πολλά) των μαθημάτων με τον εαυτό τους (αυτοαναφορές).
Το παρακάτω σχήμα βάσης δεδομένων είναι ένα εκπαιδευτικό κομμάτι από μία βάση που αφορά ταινίες, ηθοποιούς και στούντιο παραγωγής.
Το σχεσιακό μοντέλο με το διάγραμμα περιορισμών αναφορικής ακεραιότητας.
Τα βέλη δείχνουν που αναφέρονται οι τιμές των ξένων κλειδιών.
Παρατηρήστε το διπλό πρωτεύον κλειδί (Ονομα, Επωνυμο) του πίνακα Ηθοποιοί που είναι ξένο κλειδί στον πίνακα ΤαινίεςκαιΗθοποιοι.
Το παρακάτω σχήμα βάσης δεδομένων αφορά ένα σύστημα δαπανών υπαλλήλων.
Το παρακάτω είναι ένα μικρό κομμάτι από μία βάση χειρισμού κρατήσεων πτήσεων
Το παρακάτω σχήμα βάσης δεδομένων είναι ένα μικρό κομμάτι από μία βάση που αποθηκεύει πληροφορίες για βιβλία, συγγραφείς και εκδότες.
Οι υπογραμμίσεις δείχνουν τα πρωτεύοντα κλειδιά.
Τα βέλη δείχνουν που αναφέρονται οι τιμές των ξένων κλειδιών.
Εδώ ένα βιβλίο μπορεί να έχει πολλούς συγγραφείς, έναν εκδότη και ένα θέμα.
Το σχεσιακό σχήμα μίας βάσης δεδομένων εκπαίδευσης που περιέχει πληροφορίες για ένα εσωτερικό εκπαιδευτικό πρόγραμμα μιας εταιρείας.
Οι υπάλληλοι της εταιρίας είναι και διδάσκοντες.
Παρατηρήστε το διπλό πρωτεύον κλειδί του πίνακα ΠΡΟΣΦΕΡΟΜΕΝΑ_ΜΑΘΗΜΑΤΑ.
Κάθε άλλος πίνακας που συνδέεται με αυτόν αναφέρεται σε αυτό το διπλό κλειδί.
Οι παρακάτω πίνακες είναι αυτό- επεξηγηματικοί.
Το παρακάτω σχήμα βάσης δεδομένων χρησιμοποιείται για την αποθήκευση και παρακολούθηση πληροφοριών κατά την παραγωγή λογισμικού.
Οι υπογραμμίσεις δείχνουν τα πρωτεύοντα κλειδιά.
Εκτός από την βασική δομή μπορείτε εδώ να προσέξετε ότι σχεδόν κάθε πίνακας έχει ένα επιπλέον πεδίο σαν Comments, Notes, Details, OtherLogDetails.
Αυτό είναι κοινή σχεδιαστική τακτική έτσι ώστε να μην περιορίζονται οι τελικοί χρήστες αλλά να τους επιτρέπεται εκτός από τα στάνταρ πεδία να καταχωρήσουν αν θέλουν και κάτι άλλο δίχως να αλλάξει τίποτε στην σχεδίαση της βάσης δεδομένων.
Το παρακάτω σχήμα βάσης δεδομένων παρουσιάζει έναν διαφορετικό τρόπο καταγραφής των τραπεζικών συναλλαγών από πολλούς λογαριασμούς.
Το σχεσιακό σχήμα μίας βάσης δεδομένων μιας εταιρίας με εργαζόμενους και έργα που ελέγχονται από ξεχωριστά τμήματα έχει τους ακόλουθους περιορισμούς: Κάθε εργαζόμενος εργάζεται ακριβώς για ένα τμήμα και μπορεί να εργάζεται σε διάφορα έργα.
Ένας εργαζόμενος μπορεί να διευθύνει το πολύ ένα τμήμα.
Ένα τμήμα σχετίζεται με έναν μόνο εργαζόμενο ο οποίος διευθύνει το τμήμα και σ' έναν αριθμό υπαλλήλων οι οποίοι δουλεύουν για το τμήμα.
Ένα τμήμα μπορεί να σχετίζεται με έναν αριθμό έργων που ελέγχει.
Ένα έργο ελέγχεται από ακριβώς ένα τμήμα και έχει αρκετούς υπάλληλους που δουλεύουν για το έργο.
Κάθε τμήμα σχετίζεται με έναν εργαζόμενο.
Η βάση αποτελείται από τους παρακάτω πίνακες.
Το κύριο τμήμα μιας βάσης δεδομένων παραγγελιών, όπως σε ένα Βιβλιοπωλείο, απορρέει από την διαπίστωση ότι οι πελάτες θα κάνουν παραγγελίες που η κάθε μία παραγγελία θα περιέχει ως είδη παραγγελίας διάφορα προιόντα, τα οποία θα ανήκουν σε κατηγορίες.
Οι πίνακες είναι αυτό- επεξηγηματικοί.
Προσέξτε το επιπλέον πεδίο ΤελικηΤιμη που αποθηκεύει την τιμή πώλησης.
Δεν είναι κλασσικό γνώρισμα σχεδιασμού βάσεων δεδομένων (η τιμή αυτή πρέπει πρώτα να αντιγράφεται από τον πίνακα προϊόντα και να μπορεί να αλλάξει) αλλά είναι απαραίτητο για την έκδοση των τιμολογίων.
Το παράδειγμα βάσης δεδομένων Northwind στον SQL Server αφορά μία εταιρία που εμπορεύεται προϊόντα.
Ένα σύστημα διαχείρισης παραγγελιών έχει σαν κορμό τους πίνακες Πελάτες, Παραγγελίες, ΣτοιχείαΠαραγγελίας και Προϊόντα.
Στον πίνακα ΣτοιχείαΠαραγγελίας (order details) αποθηκεύεται η τιμή πώλησης του κάθε ενός, η ποσότητα και η έκπτωση.
Η κύρια διαφορά που έχει η βάση δεδομένων Northwind με το Βιβλιοπωλείο που αναλύσαμε σε προηγούμενες παραγράφους είναι στα προϊόντα.
Το μοντέλο οντοτήτων συσχετίσεων (ER) από το οποίο προήλθε ολόκληρη η δομή της βάσης φαίνεται παρακάτω.
Το διάγραμμα (ER) μετατρέπεται στο σχεσιακό μοντέλο παρακάτω όπου παρουσιάζονται οι πίνακες στον SQL Server.
Το παράδειγμα της σχεσιακής Βάσης Δεδομένων Northwind.mdb της MS Access αφορά και αυτό μία εταιρεία που εμπορεύεται διάφορα προϊόντα.
Έχουμε Πελάτες που κάνουν παραγγελίες τις οποίες χειρίζονται υπάλληλοι που τις αποστέλλουν μέσω μεταφορικών εταιριών.
Οι παραγγελίες περιέχουν ως είδη παραγγελίας προϊόντα τα οποία ανήκουν σε κατηγορίες και έχουν προμηθευτές.
Εδώ μεταφέραμε τη βάση στον SQL Server χρησιμοποιώντας το Import/Export Data Transformation Services για να μπορεί να γίνει σύγκριση.
Αυτή η βάση δεδομένων αποτελείται από 8 πίνακες, οι οποίοι συνδέονται μεταξύ τους με κοινά πεδία σύμφωνα με το παρακάτω σχεσιακό διάγραμμα:
Τα πρωτεύοντα κλειδιά των πινάκων ξεχωρίζουν από το σχετικό σχέδιο, ενώ οι λόγοι πληθυκότητας των σχέσεων έχουν ένα κλειδί για την αναπαράσταση της μονάδας και το σύμβολο του απείρου (∞) για την αναπαράσταση του πλήθους.
Ο πίνακας Suppliers καταγράφει τα στοιχεία των προμηθευτών της εταιρείας.
Ο πίνακας Categories περιέχει της κατηγορίες προϊόντων που εμπορεύεται η εταιρεία.
Ο πίνακας Products αποθηκεύει τα απαραίτητα στοιχεία κάθε προϊόντος.
Ο πίνακας Employees κρατάει τα στοιχεία των εργαζομένων στην εταιρεία.
Ο πίνακας Shippers περιέχει τα στοιχεία των εταιρειών μεταφορών, με τις οποίες συνεργάζεται η εταιρεία Northwind για να μεταφέρει τα προϊόντα της στους πελάτες της.
Ο πίνακας Customers αποτελεί το πελατολόγιο της εταιρείας με όλα τα στοιχεία των πελατών της.
Ο πίνακας Orders αποθηκεύει τα στοιχεία κάθε παραγγελίας που κάνει κάποιος πελάτης.
Ο πίνακας [Order Details] κρατάει τις λεπτομέρειες της κάθε παραγγελίας.
Αυτές οι δύο βάσεις δεδομένων υπάρχουν στον υπολογιστή σας αν έχετε κάνει εγκατάσταση της MS Access και του SQL Server και χρησιμοποιούνται και ως δείγματα και στα sample codes του Visual Studio (στις visual basic, visual C++ και ASP).
Ένα σύστημα διαχείρισης δικτύου παροχής ενέργειας (Energy Management System όμοιο με αυτό της γειτονικής Ιταλίας) αποτελείται από κόμβους και διακλαδώσεις που ενώνουν ζεύγη κόμβων.
Υπάρχουν σταθμοί παραγωγής ενέργειας, ενδιάμεσοι κόμβοι που χρησιμοποιούνται ως διανομείς ενέργειας στο δίκτυο και τελικοί χρήστες της ηλεκτρικής ενέργειας.
Οι συνθήκες λειτουργίας καταγράφονται καθημερινά με συχνές αναδιαμορφώσεις, και η τοπολογία του δικτύου αλλάζει περιοδικά (π.χ. ανά μήνα).
Αυτή η βάση δεδομένων σχεδιάστηκε για να υποστηρίζει εσωτερικά ενεργούς επιχειρησιακούς κανόνες, μέσω διαδικασιών, συναρτήσεων και triggers.
Οι ενεργοί κανόνες και οι κώδικες έχουν παραληφθεί για λόγους χώρου αλλά σας δίνουν την κεντρική ιδέα.
Το κύριο κομμάτι της βάσης δεδομένων ENERGY_GRID αποτελείται από οκτώ πίνακες.
Ο πίνακας ‘XRHSTES’ κρατάει όλα τα απαραίτητα στοιχεία ενός χρήστη του ηλεκτρικού δικτύου κάποιας περιοχής.
Ο πίνακας ‘TYPOS_KALODIOY’ κρατάει τους τύπους των καλωδίων που χρησιμοποιούνται στα δίκτυα, καθώς και το τι παροχή προσφέρει το κάθε καλώδιο (μονοφασική, τριφασική).
Ο πίνακας ‘SHMEIO’ μας δείχνει τις συντεταγμένες των διανομέων, των ενδιάμεσων κόμβων, των κεντρικών πινάκων, καθώς και των οικιών.
Ο πίνακας ‘KENTRIKOS_PINAKAS’ μας δείχνει την ισχύ που παρέχεται σε κάποιο οικοδομικό τετράγωνο.
Ο πίνακας ‘KALODIO’ μας δείχνει την ισχύ που διαπερνά το καλώδιο εκείνη τη στιγμή καθώς και την γραμμή στην οποία ανήκει το καλώδιο αυτό.
Ο πίνακας ‘GRAMMH’ μας δείχνει το σύνολο των καλωδίων που παρέχουν ενέργεια σε ένα χρήστη.
Ο πίνακας ‘ENDIAMESOS_KOMBOS’ διαχωρίζει σε τοπικό επίπεδο τις γραμμές παροχής ενέργειας σε κάθε χρήστη.
Ο πίνακας ‘DIANOMEAS’ μας δείχνει την διανομή της ενέργειας από τον κεντρικό πίνακα προς τους ενδιάμεσους κόμβους.
Σε ένα σύστημα διαχείρισης των βλαβών – επιδιορθώσεων - ανταλλακτικών, παραγγελιών εξαρτημάτων που χρησιμοποιούνται στα δίκτυα γενικά και τα οποία μπορεί να παρουσιάσουν βλάβες τις οποίες διαχειρίζονται ειδικές ομάδες τεχνικών γίνονται και καταχωρήσεις παραγγελιών των εξαρτημάτων, παραδόσεις των παραγγελιών και έλεγχοι για το τι υπάρχει στην αποθήκη.
Οι βλάβες, επιδιορθώσεις, αλλαγές και παραγγελίες ανταλλακτικών καταγράφονται στο κύριο κομμάτι της βάσης δεδομένων που υποστηρίζει εσωτερικά ενεργούς επιχειρησιακούς κανόνες, μέσω διαδικασιών, συναρτήσεων και triggers και αποτελείται από τα παρακάτω Ο πίνακας ‘Fault’ καταγράφει τις βλάβες των εξαρτημάτων του δικτύου.
Ο πίνακας ‘Available’ στον οποίο καταγράφονται οι ομάδες τεχνικών που αναλαμβάνουν την αποκατάσταση των βλαβών.
Ο πίνακας ‘Stock’ που κρατάει όλα τα εξαρτήματα των δικτύων που έχουμε στην αποθήκη.
Παίζει το ρόλο της αποθήκης.
Ο πίνακας ‘Order’ που κρατάει τις παραγγελίες των εξαρτημάτων που πραγματοποιούνται επειδή δεν υπάρχουν στην αποθήκη.
Ο πίνακας ‘Deliver’ στον οποίο καταχωρούνται οι παραδόσεις των εξαρτημάτων που έχουν από πριν παραγγελθεί.
Ο πίνακας ‘Parts’ κρατάει τα εξαρτήματα που μπορεί γενικά να υποστηρίξει η αποθήκη ανεξαρτήτως αν υπάρχει απόθεμα αυτών.
Ο πίνακας ‘ProgrammedReplacement’ καταγράφει τον χρόνο ζωής των εξαρτημάτων που χρησιμοποιούνται ήδη στο δίκτυο καθώς και το χρόνο προληπτικής τους αντικατάστασης.
Ο πίνακας ‘ScheduledRepair’ καταγράφει τις προγραμματισμένες επισκευές που πρέπει να γίνουν από τις ομάδες τεχνικών συντήρησης.
Ο πίνακας ‘UrgentCall’ καταγράφει τις άμεσες κλήσεις που πραγματοποιούνται προς επιδιόρθωση των εξαρτημάτων.
Υπάρχουν επίσης πρόσθετοι πίνακες που καταγράφουν αυτόματα τις μεταβολές που πραγματοποιούν οι χρήστες και οι triggers στους υπόλοιπους πίνακες της βάσης.
Οι Βάσεις Δεδομένων που περιέχουν και χρονικά δεδομένα, δηλαδή τα δεδομένα που είναι αποθηκευμένα δεν αφορούν μόνο σε ένα μόνο σημείο στο χρόνο (συνήθως το ‘τώρα’) αποκαλούνται ‘χρονολογικές βάσεις δεδομένων’ (temporal databases).
Η έννοια της χρονικής περιόδου που χαρακτηρίζεται από δύο χρονικές στιγμές αρχής-τέλους και από μία διάρκεια (ή χρονικό διάστημα) εξετάζεται σε αυτά τα συστήματα διαχείρισης χρονικών περιόδων και δεδομένων.
Η παρακάτω βάση δεδομένων είναι ένα κομμάτι που κρατά και στοιχεία ιστορικού και αποτελείται από πίνακες έγκυρου χρόνου.
Το σχεσιακό μοντέλο με το διάγραμμα περιορισμών ακεραιότητας αναφορών των ξένων κλειδιών.
Τα υποψήφια κλειδιά σε κάθε πίνακα είναι τα υπογραμμισμένα πεδία.
Η ακεραιότητα δεδομένων για τα πρωτεύοντα και ξένα κλειδιά ελέγχεται με triggers.
Οι τελεστές χρονικών περιόδων για ερωτήσεις ανάκτησης δεδομένων έχουν υλοποιηθεί με συναρτήσεις στον SQL Server.
Οι εισαγωγές και ενημερώσεις δεδομένων γίνονται με κλήσεις αποθηκευμένων διαδικασιών στον SQL Server.
Ο πίνακας ‘Employees’ καταγράφει τα απαραίτητα στοιχείων των εργαζομένων.
Ο πίνακας ‘FamilyChildren’ καταγράφει τα μέλη οικογένειας των εργαζομένων.
Ο πίνακας ‘SalaryHistory’ κρατάει όλο το ιστορικό της μισθολογικής κατάστασης των εργαζομένων για το χρονικό διάστημα που εργάστηκαν.
Ο πίνακας ‘WorkingPlaces’ καταγράφει πληροφορίες για τους διάφορους χώρους εργασίας των εργαζομένων, δηλαδή, σε ποιο κτίριο ανήκουν, τι είδους χώρος είναι (γραφείο, εργαστήριο υπολογιστών, βιβλιοθήκη, αίθουσα διακομιστών, αίθουσα δικτύων) Ο πίνακας ‘PlacesHistory’ κρατάει όλο το ιστορικό των χώρων εργασίας όπου εργάζεται ο κάθε εργαζόμενος.
Ο πίνακας ‘JobTitles’ καταγράφει τους τίτλους εργασίας.
Ο πίνακας ‘Positions’ (θέσεις εργασίας) κρατάει την αντιστοίχιση των θέσεων εργασίας με τους τίτλους εργασίας (JobTitles).
Πολλές θέσεις (PositionNumber) μπορεί να έχουν τον ίδιο τίτλο εργασίας (JobTitleCode).
Ο πίνακας ‘PositionHistory’ καταγράφει όλο το ιστορικό των θέσεων εργασίας.
Η παρακάτω είναι μία βάση δεδομένων με αντικειμενοστρεφή χαρακτηριστικά.
Το κύριο τμήμα της βάση δεδομένων Hospital σχεδιάστηκε με το εκτεταμένο μοντέλο οντοτήτων συσχετίσεων και αποτελείται από πολλούς πίνακες.
Είναι πιο κοντά στις αντικειμενοστρεφείς έννοιες.
Υποστηρίζει ιεραρχίες is-A, πολλαπλή κληρονομικότητα, πολυμορφισμό, ειδίκευση και συσσώρευση.
Ο πίνακας «ΑΤΟΜΟ» καταγράφει τα απαραίτητα στοιχεία ενός ατόμου.
Είναι ένας πίνακας από τον οποίο πολλοί πίνακες θα κληρονομήσουν τα δεδομένα του.
Ο πίνακας «ERGAZOMENOI» καταγράφει τα επιπλέον απαραίτητα στοιχεία ενός εργαζομένου, ενώ τα κυρίως τα κληρονομεί από τον πίνακα ΑΤΟΜΟ.
Επιπλέον παριστάνει και μία δενδρική δομή που αποτελείται από προϊσταμένους-υφισταμένους.
Ο πίνακας «IATROI» καταγράφει τα επιπλέον στοιχεία ενός ιατρού, ενώ τα υπόλοιπα τα κληρονομεί από τον πίνακα ERGAZOMENOI.
Ο πίνακας «EIDIKEYOMENOI» καταγράφει στοιχεία ειδικευόμενων ιατρών, ενώ τα υπόλοιπα τα κληρονομεί από τον πίνακα ERGAZOMENOI.
Ο πίνακας «IDIKOTITES» καταγράφει τις ειδικότητες των ιατρών.
Ο πίνακας «EXARTOMENOI» καταγράφει τους εξαρτώμενους των εργαζομένων.
Ο πίνακας «DIOIKITIKOI» καταγράφει στοιχεία των διοικητικών ενός νοσοκομείου και κληρονομεί δεδομένα και από τον πίνακα ERGAZOMENOI.
Ο πίνακας «TEXNIKOI» καταγράφει στοιχεία των τεχνικών-εργαζομένων ενός νοσοκομείου και κληρονομεί δεδομένα από τον πίνακα ERGAZOMENOI.
Ο πίνακας «NOSILEYTES» καταγράφει στοιχεία των νοσηλευτών-εργαζομένων ενός νοσοκομείου και κληρονομεί δεδομένα από τον πίνακα ERGAZOMENOI.
Ο πίνακας «SINERGATES» καταγράφει τους συνεργάτες με τους οποίους συνεργάζεται ένα νοσοκομείο και συνδέεται με τον πίνακα ΑΤΟΜΟ απ’ όπου κληρονομεί τα υπόλοιπα δεδομένα Ο πίνακας «ERGAZ_KLINIKI» καταγράφει στοιχεία των εργαζομένων στις κλινικές.
Ο πίνακας «BARDIES_NOSILEYTON» καταγράφει τις καθημερινές βάρδιες κάθε νοσηλευτή.
Ο πίνακας «BARDIES» καταγράφει τις γενικές βάρδιες του νοσοκομείου.
Ο πίνακας «ASTHENIS» καταγράφει όλους τους ασθενείς ενός νοσοκομείου και κληρονομεί δεδομένα από τον πίνακα ATOMO.
Ο πίνακας «NOSILEIA» καταγράφει όλα τα απαραίτητα στοιχεία μιας νοσηλείας ενός ασθενή.
Ο πίνακας «EPISKEPSI» καταγράφει όλα τα απαραίτητα στοιχεία επίσκεψης ενός ασθενή σε μια κλινική και συνδέεται με τους πίνακες ASTHENIS και KLINIKI.
Ο πίνακας «KLINIKI» καταγράφει τα στοιχεία των κλινικών.
Ο πίνακας «EXETASEIS» καταγράφει στοιχεία μιας εξέτασης και συνδέεται με τον πίνακα ASTHENIS.
Το πρωτεύον κλειδί αυτού του πίνακα είναι cluster key.
Ο πίνακας «ΙΑΤΡΙΚES» καταγράφει τις ιατρικές εξετάσεις ενός ασθενή και κληρονομεί στοιχεία από τον πίνακα EXETASEIS.
Το ξένο κλειδί FK_IATROY του πίνακα είναι surrogate key.
Ο πίνακας «ERGASTIRIO» καταγράφει τα στοιχεία ενός εργαστηρίου.
Ο πίνακας «EIDH_ERGASTIRIAKON» καταγράφει τα είδη των εργαστηριακών εξετάσεων.
Ο πίνακας «EIDH_DIAGNOSTIKON» καταγράφει τα είδη των διαγνωστικών εξετάσεων.
Ο πίνακας «ERGASTHRIAKES» καταγράφει τις εργαστηριακές εξετάσεις ενός ασθενή και κληρονομεί στοιχεία από τον πίνακα EXETASEIS.
Ο πίνακας «DIAGNOSTIKES» καταγράφει τις διαγνωστικές εξετάσεις ενός ασθενή και κληρονομεί στοιχεία από τον πίνακα EXETASEIS.
Ο πίνακας «FARMAKA» καταγράφει τα διαθέσιμα φάρμακα.
Ο πίνακας «FARM_AGOGI» καταγράφει τη φαρμακευτική αγωγή ενός ασθενή και συνδέεται με τον πίνακα ASTHENIS.
Ο πίνακας «FARM_XORIGISH» καταγράφει τον τρόπο της χορήγησης των φαρμάκων.
Ο πίνακας «FARM_DRASI» καταγράφει τη δράση των φαρμάκων.
Ο πίνακας «ALILEPIDRONTA_FARMAKA» καταγράφει τις αλληλεπιδράσεις των φαρμάκων και συνδέεται με τον πίνακα FARMAKA.
Προέρχεται από αναδρομική συσχέτιση και είναι ένας γράφος.
Χρειάζεται έτσι βασικούς αλγόριθμους διάσχισης γράφων.
Μια Αποθήκη Δεδομένων είναι μια μεγάλη Βάση Δεδομένων για συλλογή πληροφοριών που χρησιμοποιείται συχνά ως βάση σε Συστήματα Στήριξης Αποφάσεων (DSS) Επειδή από μια αποθήκη δεδομένων δεν διαγράφουμε ποτέ τίποτα, αυτό έχει ως αποτέλεσμα να συγκεντρώνεται ένας μεγάλος όγκος πληροφοριών που αποτελούν ιστορικά στοιχεία του οργανισμού- επιχείρησης.
Συχνά οι Αποθήκες Δεδομένων τμηματοποιούνται σε άλλες μικρότερες εξειδικευμένες τις λεγόμενες Data Marts (μικρές αποθήκες).
Αυτές έχουν μικρότερο κόστος υλοποίησης και μικρότερο χρονικό διάστημα κατασκευής.
Έτσι μπορεί μια επιχείρηση να έχει Data Marts για το τμήμα Προσωπικού, το τμήμα Μάρκετινγκ κ.τ.λ.
Οι αποθήκες δεδομένων εστιάζουν στην εισαγωγή και στην ανάλυση μεγάλων όγκων δεδομένων.
Παράγουν αναφορές που περιέχουν τα αποτελέσματα λεπτομερούς ανάλυσης των δεδομένων.
Για αυτό και έχουν προϋπολογισμένες πολλές τιμές.
Χαρακτηριστικά γνωρίσματα μιας αποθήκης δεδομένων που χρειάζεται συνήθως μήνες για να γίνει, είναι · 500,000,000 γραμμές από δεδομένα · Μια αναφορά εκτελείται ανά χρονικό διάστημα που αναλύει τα δεδομένα · Τρεις ώρες είναι ένας μέσος χρόνος για να εκτελεστεί μια αναφορά Ένα σύστημα Άμεσης Αναλυτικής Επεξεργασίας δεδομένων (OLAP- on-line analytical processing) είναι ένα σύστημα που μας επιτρέπει να βλέπουμε μια διαφορετική σύνοψη πολυδιάστατων δεδομένων.
Η λέξη online δηλώνει ότι δεν περιμένουμε για μεγάλο χρονικό διάστημα να δούμε τα αποτελέσματα ενός συγκεντρωτικού ερωτήματος αλλά εμφανίζονται σχεδόν άμεσα.
Είναι το κύριο έργο σε Αποθήκες Δεδομένων για ανάλυση δεδομένων και λήψη αποφάσεων, γρήγορη απάντηση σε οποιαδήποτε χρονική στιγμή τεθεί ένα ερώτημα (On-Line), μεταβολή της οπτικής γωνιάς παρουσίασης των δεδομένων(π.χ από πωλήσεις ανά περιοχή σε πωλήσεις ανά τμήμα) και απαντήσεις σε πολύπλοκες ερωτήσεις:
Ποιος ήταν ο όγκος πωλήσεων ανά περιοχή και κατηγορία προϊόντος την περασμένη χρονιά;
Πόσο σχετίζονται οι αυξήσεις τιμών των υπολογιστών με τα κερδών των πωλήσεων τα 10 τελευταία χρόνια;
Ποια ήταν τα δέκα πρώτα καταστήματα σε πωλήσεις CD;
Πόσους δίσκους πουλήσαμε στην Δυτική Περιφέρεια το τελευταίο τέταρτο της περσινής χρονιάς σε καταστήματα με κατανάλωση μεγαλύτερη από 100 δίσκους μηνιαίως, και ποιο το κέρδος μας από αυτές τις πωλήσεις;
Λειτουργικά χαρακτηριστικά αναλυτικής επεξεργασίας τα συγκεντρωτικά ερωτήματα πολλών διαστάσεων (π.χ. μερικά αθροίσματα πωλήσεων ανά έτος, προϊόν και πωλητή).
Για την απεικόνιση πολυδιάστατων δεδομένων έχουν αναπτυχθεί ειδικά σχήματα.
Μερικά από αυτά είναι τα σχήματα αστέρα και χιονονιφάδας.
Το σχήμα αστέρα (star schema) απεικονίζει τα δεδομένα σαν μία συλλογή δύο τύπων: γεγονότων και διαστάσεων.
Σε αντίθεση με το σχεσιακό σχήμα, το οποίο είναι επίπεδο, το σχήμα αστέρα είναι μια γραφική άποψη των δεδομένων.
Στο κέντρο του αστέρα υπάρχει ένας πίνακας ο πίνακας γεγονότων (fact table) – που μερικές φορές ονομάζετε και πρωτεύον πίνακας (major tables).
Εξωτερικά του πίνακα γεγονότων, υπάρχουν άλλοι πίνακες οι πίνακες διαστάσεων (dimension tables) -που μερικές φορές ονομάζονται και δευτερεύοντες πίνακες (minor tables).
Η πιο απλή μορφή ενός σχήματος αστέρα αποτελείται από έναν πίνακα γεγονότων και πολλούς πίνακες διαστάσεων.
Σε αυτή την περίπτωση, ένα πεδίο του πίνακα γεγονότων δείχνει προς ένα πεδίο του πίνακα διαστάσεως.
Τα πραγματικά προσβάσιμα δεδομένα είναι αποθηκεμένα στους πίνακες γεγονότων και για αυτό οι τελευταίοι τείνουν να είναι αρκετά μεγάλοι.
Οι πίνακες διαστάσεων, οι οποίοι συνήθως είναι μικρότεροι, αποθηκεύουν αναλυτικές πληροφορίες που σχετίζονται με το πεδίο του πίνακα γεγονότος που συνδέονται.
Το Σχήμα που ακολουθεί απεικονίζει το σχήμα αστέρα που χρησιμοποιήσαμε.
Το σχήμα αστέρα στην αποθήκη δεδομένων.
Ο πίνακας SALES είναι ο πίνακας γεγονότων όπου μπορούν να αποθηκεύονται τα μερικά αθροίσματα πώλησης (sum , max, min, avg) κάθε είδους σε κάθε παραγγελία και υπάρχουν τέσσερις πίνακες διαστάσεων.
Οι κύβοι στην αποθήκη δεδομένων παράγονται από αυτούς τους πίνακες.
Σε μία μεγάλη αποθήκη μπορούν να υπάρχουν πολλοί πίνακες γεγονότων, π.χ. κατά την διαίρεσή της σε μικρότερα τμήματα δημιουργούμε έναν πίνακα γεγονότων για κάθε έτος.
Ο πίνακας γεγονότων είναι ο SALES (Πωλήσεις) ο οποίος περιέχει άλλα δυο πεδία την ποσότητα (Quantity) και τις συνολικές πωλήσεις (TotalSales).
Οι πίνακες REGION (Τοποθεσία), DAYS (Μέρες), PRODUCTS (Προϊόντα) και EMPLOYEES (Εργαζόμενοι) αποτελούν τους πίνακες διαστάσεων.
Η πρόσβαση στον πίνακα γεγονότων από ένα πίνακα διάστασης μπορεί να επιτευχθεί μέσω της σύνδεσης μεταξύ ενός πεδίου του πίνακα διαστάσεων και ενός πεδίου του πίνακα γεγονότων.
Για παράδειγμα, μπορούμε να προσπελάσουμε όλες τις τοποθεσίες στην Αθήνα υποβάλλοντας την ακόλουθη SQL ερώτηση: Where (Sales.LocationID=Region.RegionID) ΑND (Region.RegionDescription = “Athens”) Εδώ, το LocationID είναι ένα ξένο κλειδί στον πίνακα γεγονότων Sales και πρωτεύον κλειδί στον πίνακα διάστασης Region (RegionID).
Το πρωτεύον κλειδί για τον πίνακα γεγονότων είναι μία συλλογή ξένων κλειδιών που δείχνουν προς τους πίνακες διαστάσεων.
Επιπλέον, ένας πίνακας διάστασης μπορεί ο ίδιος να δείχνει προς ένα άλλο πίνακα διάστασης.
Παράδειγμα δημιουργίας του πίνακα DAYS στη βάση Northwind στον SQL Server
Εισαγωγή δεδομένων στον πίνακα DAYS
Η πρώτη συνάρτηση στο select εξάγει την ημέρα της εβδομάδος από μια ημερομηνία, η δεύτερη συνάρτηση εξάγει τον μήνα, η τρίτη το τρίμηνο, και η τέταρτη το έτος.
Δείγμα δεδομένων του πίνακα DAYS στον SQL Server Παράδειγμα δημιουργίας του πίνακα SALES
Ο πίνακας SALES στη βάση δεδομένων στον SQL Server Εισαγωγή δεδομένων στον πίνακα SALES
Αν ανοίξετε το περιβάλλον του Borland C++ Builder και πάτε στην καρτέλα Decision Cube θα δείτε όλα τα σχετικά components με τα οποία μπορείτε να πάρετε συγκεντρωτικά αποτελέσματα από πίνακες γεγονότων και διαστάσεων, όπως τα.
Στην φόρμα αυτή μπορούμε να δούμε τις πωλήσεις προϊόντων ανά περιοχή υπό μορφή κύβου.
Ποιο συγκεκριμένα θα δούμε τις πωλήσεις κάθε προϊόντος για κάθε βάση καθώς και το Άθροισμα τους για κάθε χρόνο αλλά και τα συνολικά Αθροίσματα.
Για τη δημιουργία της φόρμας χρησιμοποιούμε τα αντικείμενα: PageControl, DecisionGrid, DecisionSource, DecisionCube, Decision Query, Edit.
Υπάρχει επίσης και ένα αντικείμενο TDatabase στην κεντρική φόρμα που το χρησιμοποιούμε για την πρόσβαση στη βάση δεδομένων.
Το Decision Query χρησιμοποιεί το αντικείμενο Database για την πρόσβαση στη βάση.
Το Decision Query περιέχει το ερώτημα που θα εκτελεστεί και είναι συνδεδεμένο με το DecisionCube.
Το DecisionCube δημιουργεί τους κύβους των αποτελεσμάτων παίρνοντας τα αποτελέσματα από την εκτέλεση του ερωτήματος και τα μεταφέρει στο DecisionSource σε μορφή κύβου.
Το DecisionGrid είναι συνδεδεμένο με το DecisionSource και χρησιμοποιείται για να μας εμφανίζει τα αποτελέσματα της αναζήτησης το οποίο το έχουμε τοποθετήσει πάνω σε ένα Page Control.
Το Decision Source το χρησιμοποιούμε για να μπορούμε να αλλάζουμε τις διαστάσεις του κύβου και να βλέπουμε τα αποτελέσματα από διαφορετική οπτική γωνία κάθε φορά. ((TForm *)this->Owner)->Show(); // και εμφανίζουμε την κεντρική φόρμα
Απενεργοποιούμε το DecisionQuery1 αν είναι ενεργό, το καθαρίζουμε και φορτώνουμε το ερώτημα όπου επιλέγουμε τα πεδία που θέλουμε να εμφανίσουμε, τα παίρνουμε από την προβολή VW_SalesByDay, τα ομαδοποιούμε και τρέχουμε το DecisionQuery1.
Δημιουργία προβολής VW_SalesByDay στον SQL Server Αυτή η προβολή (view) που δημιουργούμε στην αποθήκη δεδομένων εμφανίζει τις συνολικές πωλήσεις των προϊόντων ανά ημέρα.
Τα πεδία που επιλέγουμε είναι το όνομα του προϊόντος, την χρονιά, τον μήνα, το τρίμηνο, τις συνολικές πωλήσεις, το επίθετο του εργαζόμενου και το όνομα της περιοχής που εργάζεται ο εργαζόμενος
Τα δεδομένα αντλούνται από μια Βάση Δεδομένων μέσω μίας διασύνδεσης. – Εντολές SQL ενσωματώνονται στον πηγαίο κώδικα μιας γλώσσας προγραμματισμού όπως οι C, Cobol, Pascal, PL/I, Java, και Fortran.
Μια γλώσσα, στην οποίαν ενσωματώνονται τα ερωτήματα SQL αναφέρεται ως κύρια γλώσσα (host) και οι δομές της SQL επιτρέπονται στην κύρια γλώσσα, αποτελούν την ενσωματωμένη SQL.
Ένα ενσωματωμένο πρόγραμμα SQL πρέπει πριν από την μεταγλώττιση να το επεξεργασθεί ένας ειδικός προεπεξεργαστής που αντικαθιστά τις ενσωματωμένες αιτήσεις SQL με δηλώσεις της κύριας γλώσσας και κλήσεις διαδικασιών για την πρόσβαση στην βάση δεδομένων κατά το χρόνο εκτέλεσης.
Μετά, το πρόγραμμα που δημιουργείται μεταγλωττίζεται από τον μεταγλωττιστή της κύριας γλώσσας. – Το πιο διαδεδομένο API (Application Programming Interface) για κλήση λειτουργιών SQL μέσα από μια γλώσσα προγραμματισμού.
Οι οδηγοί ODBC προσφέρουν ένα ενδιάμεσο επίπεδο αφαίρεσης που επιτρέπει την ενιαία πρόσβαση στην βάση δεδομένων ανεξάρτητα από την τεχνολογία υλοποίησης της (δηλαδή MSAccess, SQL Server, MySQL, Oracle κλπ.) και την τοποθεσία της στο δίκτυο. – Η τυποποιημένη διασύνδεση JDBC (Java Data Base Connectivity) είναι ένα API (Application Programming Interface) για προγραμματισμό βάσεων δεδομένων με τη γλώσσα Java.
Η διασύνδεση JDBC είναι πολύ πιο εύκολη για τους προγραμματιστές της Java συγκριτικά με την διασύνδεση ODBC για τους προγραμματιστές της C.
Εάν δεν υπάρχουν οδηγοί JDBC μια γέφυρα JDBC-ODBC μπορεί να χρησιμοποιηθεί για σύνδεση με πρόγραμμα οδήγησης ODBC μέσω του JDBC API.
Στην Java 2 περιλαμβάνεται μία επιπλέον γέφυρα JDBC-ODBC για το Solaris και τα MS Windows. – Μια αντικειμενοστρεφής τυποποίηση διασύνδεσης (API) με Βάση Δεδομένων.
Το OLE-DB είναι ένα system-level C++ API, με στόχους παρόμοιους με το ODBC, αλλά υποστηρίζει και μη σχεσιακά δεδομένα.
Όπως και το ODBC έτσι και το OLE-DB παρέχει δομές σύνδεσης με μια πηγή δεδομένων, για έναρξη μιας συνόδου, εκτέλεση εντολών SQL και λήψη αποτελεσμάτων με την μορφή ενός συνόλου γραμμών.
Ενώ το OLE DB είναι μία system-level, δηλαδή χαμηλού επιπέδου προγραμματιστική διασύνδεση το ADO (ActiveΧ Data Objects) είναι μία application-level, δηλαδή υψηλού επιπέδου, αντικειμενοστρεφής προγραμματιστική διασύνδεση για δεδομένα παροχέων OLE DB.
Το ADO υλοποιεί ένα κοινό μοντέλο προγραμματισμού βάσεων δεδομένων για πρόσβαση σε κάθε παροχέα OLE-DB και επιτρέπει έτσι με τα προγραμματιστικά αντικείμενα που προσφέρει να γράφονται εφαρμογές με όμοιο τρόπο από Visual C++, Delphi, Visual Basic, Visual J++, ASP, Borland C++ Builder ακόμη και από γλώσσες script, όπως τις VB Script και Java Script.
Η τυποποίηση SQL ορίζει ενσωματώσεις της SQL σε διάφορες γλώσσες προγραμματισμού, όπως οι C, Cobol, Pascal, Java, PL/I και Fortran.
Μια γλώσσα, στην οποίαν ενσωματώνονται τα ερωτήματα SQL αναφέρεται ως κύρια γλώσσα (host) και οι δομές της SQL επιτρέπονται στην κύρια γλώσσα, αποτελούν την ενσωματωμένη SQL.
Τα προγράμματα που είναι γραμμένα στην κύρια γλώσσα μπορούν να χρησιμοποιήσουν την σύνταξη της ενσωματωμένης SQL για να έχουν πρόσβαση και να ενημερώνουν τα δεδομένα που είναι αποθηκευμένα σε μια βάση δεδομένων.
Αυτή η ενσωματωμένη μορφή της SQL επεκτείνει την δυνατότητα του προγραμματιστή να χειρίζεται την βάση δεδομένων ακόμα περισσότερο.
Στην ενσωματωμένη SQL, όλη η επεξεργασία των ερωτημάτων εκτελείται από το σύστημα βάσης δεδομένων, που μετά κάνει το αποτέλεσμα του ερωτήματος διαθέσιμο στο πρόγραμμα, μια εγγραφή κάθε φορά.
Μεταγλωτίζοντας ένα πρόγραμμα ενσωματωμένης SQL Ένα ενσωματωμένο πρόγραμμα SQL πρέπει να το επεξεργασθεί ένας ειδικός επεξεργαστής πριν από την μεταγλώττιση.
Ο προεπεξεργαστής αντικαθιστά τις ενσωματωμένες αιτήσεις SQL με τις δηλώσεις της κύριας γλώσσας και με κλήσεις διαδικασιών που επιτρέπουν την πρόσβαση στην βάση δεδομένων κατά το χρόνο εκτέλεσης.
Μετά, το πρόγραμμα που δημιουργείται μεταγλωττίζεται από τον μεταγλωττιστή της κύριας γλώσσας.
Για να προσδιοριστούν οι αιτήσεις της ενσωματωμένης SQL στον προεπεξεργαστή, χρησιμοποιούμε την εντολή EXEC SQL, που έχει την μορφή
Οι ενσωματωμένες SQL εντολές είναι όμοιες στην μορφή με τις SQL εντολές.
Υπάρχουν ωστόσο, διάφορες σημαντικές διαφορές, όπως θα σημειώσουμε εδώ.
Για να γράψουμε ένα σχεσιακό ερώτημα, χρησιμοποιούμε την εντολή declare cursor.
To αποτέλεσμα του ερωτήματος δεν έχει υπολογιστεί ακόμα.
Αντίθετα, το πρόγραμμα πρέπει να χρησιμοποιήσει τις εντολές open και fetch για να πάρουν τα αποτελέσματα.
Σκεφτείτε το σχήμα της τράπεζας που έχουμε χρησιμοποιήσει σε αυτά τα εργαστήρια.
Υποθέστε ότι έχουμε μια μεταβλητή amount στην κύρια γλώσσα και ότι θέλουμε να βρούμε τα ονόματα και τις πόλεις των πελατών που έχουν μεγαλύτερο ποσό από το amount σε κάποιο λογαριασμό.
Γράφουμε αυτό το ερώτημα ως εξής:
Η μεταβλητή c στην προηγούμενη παράσταση ονομάζεται cursor (δρομέας) για το ερώτημα.
Χρησιμοποιούμε αυτή τη μεταβλητή για να προσδιορίσουμε το ερώτημα στην εντολή open, με αποτέλεσμα να υπολογιστεί το ερώτημα και στην εντολή fetch, με αποτέλεσμα να κάνει τις τιμές μιας εγγραφής να τοποθετηθούν στις μεταβλητές της κύριας γλώσσας.
Η εντολή open για το ερώτημα μας είναι ως εξής:
Αυτή η εντολή κάνει το σύστημα της βάσης δεδομένων να εκτελέσει το ερώτημα και να αποθηκεύσει τα αποτελέσματα μέσα σε μια προσωρινή σχέση.
Το ερώτημα έχει μια μεταβλητή της κύριας γλώσσας (το :amount).
To ερώτημα χρησιμοποιεί την τιμή της μεταβλητής τη στιγμή που εκτελείται η εντολή open.
Αν το ερώτημα SQL καταλήξει σε λάθος, το σύστημα της βάσης δεδομένων αποθηκεύει ένα διαγνωστικό λάθος στην περιοχή επικοινωνίας μεταβλητών (το SQLCA), των οποίων οι δηλώσεις εισάγονται από την εντολή SQL INCLUDE.
Ένα ενσωματωμένο πρόγραμμα SQL εκτελεί μια σειρά από εντολές fetch για να ανακαλέσει εγγραφές του αποτελέσματος.
Η εντολή fetch απαιτεί μια μεταβλητή κύριας γλώσσας για κάθε ιδιότητα της τελικής σχέσης.
Για το παράδειγμα του ερωτήματος, χρειαζόμαστε μια μεταβλητή που να περιέχει την τιμή customer_name και μια άλλη για την τιμή customer_city.
Υποθέστε ότι αυτές οι μεταβλητές είναι en και cc, αντίστοιχα.
Μετά η εντολή: παράγει μια εγγραφή στο αποτέλεσμα.
Το πρόγραμμα μπορεί μετά να χειριστεί τις μεταβλητές en και cc χρησιμοποιώντας τις λειτουργίες της κύριας γλώσσας προγραμματισμού.
Μια μόνο αίτηση fetch επιστρέφει μόνο μια εγγραφή.
Για να πάρουμε όλες τις εγγραφές του αποτελέσματος, το πρόγραμμα πρέπει να περιέχει ένα βρόχο για να ανακυκλώνεται σε όλες τις εγγραφές.
Η ενσωματωμένη SQL βοηθά τον προγραμματιστή στη διαχείριση αυτής της επανάληψης.
Αν και μια σχέση είναι θεωρητικά ένα σύνολο, οι εγγραφές του αποτελέσματος ενός ερωτήματος είναι σε κάποια σταθερή, φυσική σειρά.
Όταν το πρόγραμμα εκτελεί μια εντολή open σε ένα δρομέα, ο δρομέας ορίζεται να δείχνει στην πρώτη εγγραφή του αποτελέσματος.
Κάθε φορά που εκτελεί μια εντολή fetch, ο δρομέας ενημερώνεται για να δείχνει στην επόμενη εγγραφή του αποτελέσματος.
Όταν δεν υπάρχουν άλλες εγγραφές προς επεξεργασία, η μεταβλητή SQLSTATE του SQLCA ορίζεται σε '02000' (που σημαίνει "χωρίς δεδομένα").
Έτσι μπορούμε να χρησιμοποιήσουμε ένα βρόχο while (ή ισοδύναμο βρόχο) για να επεξεργαστούμε κάθε εγγραφή του αποτελέσματος.
Πρέπει να χρησιμοποιήσουμε την εντολή close φια να πούμε στο σύστημα της βάσης δεδομένων να διαγράψει την προσωρινή σχέση που κρατούσε το αποτέλεσμα του ερωτήματος.
Στο παράδειγμά μας αυτή η εντολή παίρνει την μορφή
Η ενσωματωμένη SQL επιτρέπει σε ένα πρόγραμμα κύριας γλώσσας να έχει πρόσβαση στην βάση δεδομένων, αλλά δεν παρέχει βοήθεια στην παρουσίαση των αποτελεσμάτων στον χρήστη ή στη δημιουργία αναφορών.
Τα περισσότερα προϊόντα βάσεων δεδομένων περιλαμβάνουν εργαλεία που βοηθούν τους προγραμματιστές εφαρμογών να δημιουργούν περιβάλλοντα χρήστη και μορφοποιημένες αναφορές.
Το συστατικό dynamic SQL (δυναμική SQL) της SQL επιτρέπει στα προγράμματα να κατασκευάζουν και να στέλνουν SQL ερωτήματα κατά την εκτέλεση.
Αντίθετα, οι ενσωματωμένες SQL εντολές πρέπει να είναι πλήρως ορισμένες κατά τη μεταγλώττιση και να μεταγλωττισθούν από τον ενσωματωμένο SQL προεπεξεργαστή.
Χρησιμοποιώντας δυναμική SQL, τα προγράμματα μπορούν να δημιουργήσουν SQL ερωτήματα ως συμβολοσειρές κατά την εκτέλεση (βασισμένα ίσως στην είσοδο από το χρήστη) και μπορούν μετά να εκτελεστούν αμέσως ή να προετοιμαστούν για μετέπειτα χρήση.
Η προετοιμασία μιας δυναμικής SQL εντολής την μεταγλωττίζει και οι επόμενες χρήσεις της προετοιμασμένης εντολής χρησιμοποιούν την μεταγλωττισμένη έκδοση.
Η SQL ορίζει τυποποιήσεις για ενσωμάτωση δυναμικών κλήσεων SQL σε μια κύρια γλώσσα, όπως στην C, όπως στο παρακάτω παράδειγμα.
To δυναμικό πρόγραμμα SQL περιέχει ένα αγγλικό ερωτηματικό (?), που είναι μια βοηθητική θέση για μια τιμή που παρέχεται όταν εκτελείται το πρόγραμμα SQL.
Ωστόσο, η παραπάνω σύνταξη απαιτεί επεκτάσεις της γλώσσας ή ένα προεπεξεργαστή.
Μια εναλλακτική λύση που χρησιμοποιείται ευρέως είναι να χρησιμοποιηθεί ένα περιβάλλον προγραμματισμού εφαρμογών για να στέλνονται τα SQL ερωτήματα ή οι ενημερώσεις σε ένα σύστημα βάσης δεδομένων και να μην γίνονται αλλαγές στην ίδια τη γλώσσα προγραμματισμού.
Στην υπόλοιπη ενότητα, θα δούμε δυο τυποποιήσεις για την διασύνδεση σε μια SQL βάση δεδομένων και την εκτέλεση ερωτημάτων και ενημερώσεων.
Η μια, το ODBC, είναι ένα περιβάλλον προγραμματισμού εφαρμογών για τη γλώσσα C, ενώ το άλλο, το JDBC, είναι ένα περιβάλλον προγραμματισμού εφαρμογών για τη γλώσσα Java.
Η τυποποίηση ODBC είναι μια ευρέως χρησιμοποιούμενη τυποποίηση για ουδέτερη επικοινωνία μεταξύ εφαρμογών πελατών και βάσεων δεδομένων.
Είναι ένα πρότυπο για τη διασύνδεση με διάφορους διακομιστές βάσεων δεδομένων μέσα από ένα κοινό περιβάλλον προγραμματισμού εφαρμογών (ΑΡΙ, application programming interface).
Το ODBC API ορίζει ένα Call-Level Interface (CLI), αποτελούμενο από συναρτήσεις που καλούνται για να στείλουν δηλώσεις SQL στο Σύστημα Βάσης Δεδομένων και να πάρουν αποτελέσματα από αυτό.
Η τυποποίηση ορίζει τη σύνταξη SQL, κανόνες για τις επιτρεπόμενες σειρές κλήσεων CLI συναρτήσεων καθώς και τα επίπεδα συμβατότητας για τη σύνταξη CLI και SQL.
Ο στόχος του ODBC είναι κάθε εφαρμογή να έχει πρόσβαση σε οποιαδήποτε δεδομένα, ανεξαρτήτου συστήματος.
Το ODBC δημιουργεί ένα ενδιάμεσο στρώμα (middle layer - database driver μεταξύ της εφαρμογής και της βάσης δεδομένων.
Αυτό το στρώμα μεταφράζει δηλώσεις SQL της εφαρμογής σε εντολές που καταλαβαίνει η βάση δεδομένων.
Η SQL χρησιμοποιείται σαν η γλώσσα πρόσβασης στην κάθε βάση δεδομένων.
Το ODBC επιτρέπει σε ένα πελάτη να συνδέεται ταυτόχρονα σε πολλές πηγές δεδομένων και να εναλλάσσεται μεταξύ τους, αλλά οι συναλλαγές σε κάθε πηγή γίνονται ανεξάρτητα.
Ο παροχέας ODBC είναι απλώς το περίβλημα του προτύπου Open Database Connectivity (ODBC).
Πρόκειται για έvα πρότυπο σύνολο κλήσεων συναρτήσεων που μπορούν να αξιοποιηθούν από τη C, C++, Visual Basic, Delphi, PowerBuilder κ.ο.κ..
Άλλες εφαρμογές με γραφικά περιβάλοντα, όπως τα πακέτα στατιστικών, λογιστικά φύλλα, πακέτα γραφικών και ανάλυσης δεδομένων μπορούν να χρησιμοποιούν το ίδιο ODBC API για να συνδεθούν με οποιονδήποτε διακομιστή υποστηρίζει ODBC (στις μέρες μας σχεδόν όλοι).
Αυτό το ΑΡΙ σας επιτρέπει να προγραμματίσετε τον πηγαίο σας κώδικα μια φορά και εύκολα να μεταφέρετε αυτή την εφαρμογή σε έναν άλλο σύστημα βάσης δεδομένων με λίγες ή και καθόλου αλλαγές κώδικα.
Στο ODBC ο πυρήνας του CLI έχει εντολές για σύνδεση με μια βάση δεδομένων, προετοιμασία και εκτέλεση δηλώσεων SQL για λήψη αποτελεσμάτων ή τιμές καταστάσεων και για διαχείριση συναλλαγών.
Το επόμενο επίπεδο συμβατότητας (επίπεδο 1) απαιτεί υποστήριξη για ανάκληση πληροφοριών καταλόγων και παλιές άλλες λειτουργίες, πέρα και πάνω από το CLI.
Το επίπεδο 2 απαιτεί επιπλέον λειτουργίες, όπως τη δυνατότητα να στέλνονται και να ανακαλούνται πίνακες με τιμές παραμέτρων και να ανακαλούνται πιο λεπτομερείς πληροφορίες καταλόγων.
Για να δείτε όλους τους ODBC drivers Επιλέγετε : Πίνακας Ελέγχου -> Εργαλεία Διαχείρισης -> Πηγές δεδομένων ODBC.
Έπειτα επιλέγετε καρτέλα DSN χρήστη ή DSN συστήματος ή DSN αρχείου και το κουμπί προσθήκη.
Στο παράθυρο διαλόγου Δημιουργία αρχείου προέλευσης δεδομένων, επιλέξτε ένα όνομα προγράμματος οδήγησης και ακολουθήστε τις οδηγίες του οδηγού.
Να γίνει πρόγραμμα σε C το οποίο θα χρησιμοποιεί μία σύνδεση ODBC, ένα user name και ένα password για να συνδεθεί με μία βάση δεδομένων,
Να γίνει πρόγραμμα σε C το οποίο θα χρησιμοποιεί μία σύνδεση ODBC, ένα user name και ένα password για να συνδεθεί με μία βάση δεδομένων, έπειτα θα δημιουργεί τον παρακάτω πίνακα
Θα εισάγει τα δεδομένα με εντολές SQL και έπειτα θα εμφανίζει την πίστωση για κάθε πελάτη Οι εφαρμογές μπορούν να χρησιμοποιούν το ODBC για · να ανοίξουν μία σύνδεση με μία βάση δεδομένων, · να στείλουν εντολές εισαγωγής και ενημέρωσης δεδομένων και, · να στείλουν ερωτήματα και να πάρουν αποτελέσματα Όπως φαίνεται και στην άσκηση το πρώτο βήμα στη χρήση του ODBC για να επικοινωνήσει με έναν διακομιστή είναι να διαμορφωθεί μία σύνδεση.
Για να γίνει αυτό, το πρόγραμμα πρώτα δεσμεύει ένα περιβάλλον SQL με την συνάρτηση SQLAllocEnv και μετά ένα χειριστή σύνδεσης (ODBC connection handle) στην βάση δεδομένων με την συνάρτηση SQLAllocConnect.
Το ODBC ορίζει τους τυπους RETCODE (error handle), HENV (ODBC enviroment handle), HDBC (database connection handle), HSTMT (SQL statement handle).
Έπειτα το πρόγραμμα ανοίγει τη σύνδεση με τη βάση δεδομένων χρησιμοποιώντας την συνάρτηση SQLConnect που δέχεται ώς ορίσματα ένα χειριστή σύνδεσης, ένα όνομα ODBC (είναι ο διακομιστής που θα συνδεθεί), ένα αναγνωριστικό χρήστη (user_name) και ένα κωδικό πρόσβασης (password) για την βάση δεδομένων.
Η σταθερά SQL_NTS δηλώνει ότι το προηγούμενο όρισμα είναι μία συμβολοσειρά που τερματίζει με κενό.
Αφού ανοίξει η σύνδεση, το πρόγραμμα μπορεί να στείλει δηλώσεις SQL στην βάση δεδομένων χρησιμοποιώντας την συνάρτηση SQLExecDirect Οι μεταβλητές της γλώσσας C μπορούν να συνδεθούν με ιδιότητες του αποτελέσματος του ερωτήματος, ώστε όταν ληφθεί μια εγγραφή χρησιμοποιώντας την SQLFetch, οι τιμές των ιδιοτήτων θα αποθηκευθούν στις αντίστοιχες μεταβλητές της C.
Η συνάρτηση SQLBindCol κάνει αυτή την εργασία.
Το δεύτερο όρισμα προσδιορίζει τη θέση της ιδιότητας στο αποτέλεσμα του ερωτήματος και το τρίτο όρισμα υποδεικνύει τον τύπο μετατροπής που απαιτείται από την SQL σε C.
Το επόμενο όρισμα δίνει την διεύθυνση της μεταβλητής.
Για τύπους μεταβλητού μεγέθους, όπως πίνακες χαρακτήρων, τα τελευταία δύο ορίσματα δίνουν το μέγιστο μήκος της μεταβλητής και μια θέση όπου αποθηκεύεται το πραγματικό μήκος όταν λαμβάνεται μια εγγραφή.
Μια αρνητική τιμή που επιστρέφεται για το πεδίο του μήκους δείχνει ότι η τιμή είναι null.
Η εντολή SQLFetch είναι σε ένα βρόχο while που εκτελείται μέχρι η SQLFetch να επιστρέψει μια τιμή διαφορετική από την SQL_SUCCESS.
Σε κάθε ανάκληση, το πρόγραμμα αποθηκεύει τις τιμές των μεταβλητών της C όπως καθορίζεται από τις κλήσεις SQLBindCol και τυπώνει αυτές τις τιμές.
Στο τέλος της συνόδου, το πρόγραμμα ελευθερώνει τον χειριστή της εντολής, αποσυνδέεται από την βάση δεδομένων και ελευθερώνει τη σύνδεση και τους χειριστές του περιβάλλοντος SQL.
Ο καλός προγραμματισμός απαιτεί να ελέγχεται το αποτέλεσμα κάθε κλήσης της συνάρτησης για να διασφαλιστεί ότι δεν υπάρχουν λάθη.
Έχουμε παραλείψει τους περισσότερους από αυτούς τους ελέγχους για συντομία.
Είναι πιθανόν να δημιουργήσετε μια SQL εντολή με παραμέτρους.
Για παράδειγμα, σκεφτείτε την εντολή Τα αγγλικά ερωτηματικά σημειώνουν βοηθητικές θέσεις για τιμές τις οποίες δίνουμε αργότερα.
Η παραπάνω εντολή μπορεί να προετοιμαστεί (PREPARE), δηλαδή να μεταγλωττιστεί στην βάση δεδομένων και να εκτελεστεί κατ' επανάληψη παρέχοντας πραγματικές τιμές στις βοηθητικές θέσεις, σε αυτή την περίπτωση παρέχοντας έναν αριθμό λογαριασμού, όνομα υποκαταστήματος και υπόλοιπο για τη σχέση account.
To ODBC ορίζει συναρτήσεις για διάφορες εργασίες, όπως την εύρεση όλων των σχέσεων της βάσης δεδομένων και την εύρεση των ονομάτων και τύπων ή στηλών ενός αποτελέσματος ερωτήματος ή μιας σχέσης της βάσης δεδομένων.
Εξ ορισμού, κάθε SQL εντολή αντιμετωπίζεται ως ξεχωριστή συναλλαγή που εκτελείται αυτόματα.
Η κλήση SQLSetConnectOption(conn, SQL_AUTOCOMMIT, 0) απενεργοποιεί την αυτόματη εκτέλεση (commit) στη σύνδεση conn και οι συναλλαγές πρέπει μετά να ολοκληρωθούν άμεσα με το SQLTransact(conn, SQL_COMMIT) ή να αναιρεθούν από την SQLTransact(conn,SQL_ROLLBACK).
Οι πιο πρόσφατες εκδόσεις της τυποποίησης ODBC προσθέτουν νέα λειτουργικότητα.
Κάθε έκδοση ορίζει επίπεδα συμβατότητας, που καθορίζουν υποσύνολα της λειτουργικότητας που ορίζεται από την τυποποίηση.
Μια υλοποίηση ODBC μπορεί να παρέχει λειτουργίες μόνο του πυρήνα, ή μπορεί να παρέχει πιο προχωρημένες λειτουργίες (επιπέδου 1 ή 2).
Το επίπεδο 1 απαιτεί υποστήριξη για ανάκληση πληροφοριών για τον κατάλογο, όπως πληροφορίες για το ποιες σχέσεις υπάρχουν και τους τύπους των ιδιοτήτων τους.
Το επίπεδο 2 απαιτεί επιπλέον λειτουργίες, όπως τη δυνατότητα να στέλνονται και να καλούνται πίνακες από τιμές παραμέτρων και να ανακαλούνται πιο λεπτομερείς πληροφορίες καταλόγων.
Η τυποποίηση Open Database Connectivity (ODBC) παρέχει έναν αποτελεσματικό τρόπο δημιουργίας εφαρμογών client-server ακόμη και σε περιβάλλοντα UNIX όπως για παράδειγμα μέσω της βιβλιοθήκης ανοιχτού κώδικα unixODBC που υποστηρίζει βάσεις δεδομένων MySQL, PostgreSQL και MimerSQL.
Επίσης μέσω μιάς γέφυρας όπως της Easysoft unix-client ODBC-ODBC windows-server bridge.
Τα έγκυρα ονόματα δεν είναι δυνατόν να περιλαμβάνουν χαρακτήρες ελέγχου ή τους ακόλουθους ειδικούς χαρακτήρες: ` | # * ? [ ] . ! $.
Εάν ένα αναγνωριστικό (δηλαδή όνομα πίνακα ή στήλης) περιέχει κενό διάστημα ή ειδικό χαρακτήρα ή σύμβολο τότε πρέπει να περικλειστεί σε ανάστροφα εισαγωγικά (`) όταν χρησιμοποιείται ODBC.
Η JDBC ορίζει ένα API, δηλαδή μια διασύνδεση προγραμματισμού εφαρμογών (Application Programming Interface-API) που μπορούν να χρησιμοποιήσουν τα προγράμματα Java για να συνδεθούν σε διακομιστές βάσεων δεδομένων.
Αποτελείται από μια ομάδα κλάσεων και διασυνδέσεων γραμμένες στη Java που επιτρέπουν στον προγραμματιστή να στέλνει δηλώσεις της SQL για εκτέλεση σε έναν Server μιας βάσης δεδομένων και σε περίπτωση μιας ερωταπόκρισης της SQL να ανακτά τα αποτελέσματα της ερωταπόκρισης.
Η JDBC είναι ένα όνομα-σήμα κατατεθέν και όχι ένα ακρωνύμιο.
Ωστόσο, θεωρείται σαν Java Database Connectivity αλλά η πλήρης μορφή δεν χρησιμοποιείται πλέον.
Το να γράφετε εφαρμογές βάσης δεδομένων στη Java χρησιμοποιώντας την JDBC σας προσφέρει τουλάχιστον δύο πλεονεκτήματα: (1) μεταφερσιμότητα μεταξύ των διακομιστών βάσης δεδομένων και (2) μεταφερσιμότητα μεταξύ των αρχιτεκτονικών και λειτουργικών συστημάτων.
Η μεταφερσιμότητα μεταξύ των διακομιστών της βάσης δεδομένων είναι μια συνέπεια της JDBC API.
Πολλά συστήματα βάσεων δεδομένων (Oracle, Sybase και Informix, για παράδειγμα) παρέχουν οδηγούς της JDBC, που βασικά αποτελούν υλοποίηση της JDBC API για τις μηχανές της βάσης δεδομένων τους.
Οι οδηγοί της JDBC φροντίζουν τις εξαρτήσεις του διακομιστή και οι εφαρμογές που είναι γραμμένες στη Java γίνονται ανεξάρτητες από τον διακομιστή.
Η μεταφερσιμότητα μεταξύ των πλατφόρμων hardware και λειτουργικών συστημάτων είναι αποτέλεσμα της γλώσσας Java.
Έτσι, ο συνδυασμός της Java και της JDBC για τον προγραμματισμό εφαρμογών βάσεων δεδομένων είναι ιδανικός, καθώς οι εφαρμογές γράφονται μία φορά και τρέχουν παντού.
Τα παρακάτω βασικά βήματα περιλαμβάνονται στην ανάπτυξη εφαρμογών της JDBC:
Εισάγετε τις κλάσεις της JDBC (java.sql.*).
Φορτώστε τους οδηγούς της JDBC.
Συνδεθείτε με τη βάση δεδομένων.
Προγραμματίζετε τη βάση δεδομένων χρησιμοποιώντας τις διασυνδέσεις της JDBC.
Αποσυνδεθείτε από τη βάση δεδομένων.
Το παρακάτω πρόγραμμα δείχνει ένα παράδειγμα προγράμματος Java που χρησιμοποιεί την διασύνδεση JDBC.
Το πρόγραμμα πρέπει πρώτα να ανοίξει μια σύνδεση με μια βάση δεδομένων και μετά να εκτελέσει SQL εντολές, αλλά πριν ανοίξει μια σύνδεση φορτώνει τα κατάλληλα προγράμματα οδήγησης για την βάση δεδομένων χρησιμοποιώντας την Class.forName.
Η πρώτη παράμετρος στην κλήση getConnection καθορίζει το όνομα του υπολογιστή που τρέχει ο διακομιστής (στο παράδειγμα μας, το aura.bell-labs.com), τον αριθμό θύρας που χρησιμοποιεί για επικοινωνία (στο παράδειγμα μας, 2000).
Η παράμετρος καθορίζει επίσης ποιο σχήμα θα χρησιμοποιηθεί στον διακομιστή (στο παράδειγμα μας, bankdb), αφού ένας διακομιστής βάσης δεδομένων μπορεί να υποστηρίζει πολλά σχήματα.
Η πρώτη παράμετρος καθορίζει επίσης το πρωτόκολλο που θα χρησιμοποιηθεί για επικοινωνία με την βάση δεδομένων (στο παράδειγμα μας, jdbc:oracle:thin:).
Παρατηρήστε ότι το JDBC καθορίζει μόνο το API και όχι το πρωτόκολλο επικοινωνίας.
Ένα πρόγραμμα JDBC μπορεί να υποστηρίζει πολλά πρωτόκολλα και πρέπει να καθορίσουμε ένα υποστηριζόμενο και από τη βάση δεδομένων και από το πρόγραμμα οδήγησης.
Τα δυο άλλα ορίσματα στην getConnection είναι ένα αναγνωριστικό χρήστη και ένας κωδικός πρόσβασης.
Το πρόγραμμα μετά δημιουργεί ένα χειριστή εντολής πάνω στη σύνδεση και τον χρησιμοποιεί για να εκτελέσει μια SQL εντολή και να πάρει αποτελέσματα.
Στο παράδειγμα μας, η stmt.executeUpdate εκτελεί μια εντολή ενημέρωσης.
Η δομή try { . . . } catch { . . . } μας επιτρέπει να πιάνουμε τις εξαιρέσεις (συνθήκες λαθών) που εμφανίζονται όταν γίνονται οι κλήσεις JDBC και να τυπώνει ένα κατάλληλο μήνυμα για το χρήστη.Το πρόγραμμα μπορεί να εκτελέσει ένα ερώτημα χρησιμοποιώντας την stmt.executeQuery().
Μπορεί να ανακαλέσει το σύνολο των γραμμών του αποτελέσματος σε ένα ResultSet και να τις διαβάσει, μια εγγραφή κάθε φορά, χρησιμοποιώντας τη συνάρτηση next() στο σύνολο αποτελεσμάτων.
Το πρόγραμμα δείχνει δυο τρόπους ανάκλησης των τιμών των ιδιοτήτων μιας εγγραφής: χρησιμοποιώντας το όνομα της ιδιότητας (branch_name) και χρησιμοποιώντας τη θέση της ιδιότητας (το 2, για να δηλωθεί η δεύτερη ιδιότητα).
Εάν δεν υπάρχουν οδηγοί JDBC μια γέφυρα JDBC-ODBC bridge μπορεί να χρησιμοποιηθεί για σύνδεση με πρόγραμμα οδήγησης ODBC μέσω του JDBC Υπάρχουν πολλές πηγές δεδομένων που δεν είναι σχεσιακές βάσεις δεδομένων και μπορεί να μην είναι καθόλου βάσεις δεδομένων.
Παραδείγματα τέτοια είναι τα επίπεδα αρχεία και ηλεκτρονικό ταχυδρομείο.
Το OLE-DB της Microsoft είναι ένα system-level C++ API, με στόχους παρόμοιους με το ODBC, αλλά υποστηρίζει και δεδομένα που δεν προέρχονται από βάσεις δεδομένων στα οποία μπορούν να παρέχονται μόνο περιορισμένες δυνατότητες ερωτημάτων και ενημέρωσης.
Όπως και το ODBC έτσι και το OLE-DB παρέχει δομές σύνδεσης με μια πηγή δεδομένων, για έναρξη μιας συνόδου, εκτέλεση εντολών και λήψη αποτελεσμάτων με την μορφή ενός συνόλου γραμμών, που είναι ένα σύνολο από γραμμές με τα αποτελέσματα των ερωτημάτων SQL.
Ο Microsoft OLE DB provider for ODBC drivers (MSDASQL).
Για να εμφανίσετε ένα τέτοιο παράθυρο κάντε μέσα σε ένα φάκελο δεξί κλικ ->Δημιουργία-> έγγραφο κειμένου και αφού αλλάξτε την κατάληξή του σε UDL (universal data link) ανοίξτε το.
Ωστόσο, το OLE DB δεν είναι αντικαταστάτης του ODBC και διαφέρει από αυτό με διάφορους τρόπους.
Στο ODBC, οι εντολές είναι πάντα στην SQL ενώ στο OLE DB οι εντολές μπορεί να είναι σε οποιαδήποτε γλώσσα που υποστηρίζεται από την πηγή δεδομένων.
Στο OLE DB ένα σύνολο γραμμής είναι ένα αντικείμενο που μπορεί να είναι κοινόχρηστο από πολλές εφαρμογές, μέσω κοινόχρηστης μνήμης.
Ένα σύνολο γραμμής μπορεί να ενημερωθεί από μια εφαρμογή και οι άλλες εφαρμογές που μοιράζονται αυτό το αντικείμενο θα ειδοποιούνται για την αλλαγή.
Τεχνικές διαφορές μεταξύ των δύο διασυνδέσεων είναι:
Το ΟLΕ DB εξασφαλίζει στις εφαρμογές μια κοινή μέθοδο πρόσβασης σε δεδομένα.
Δεν έχει σημασία με ποια μορφή αποθηκεύονται αυτά τα δεδομένα όπως κείμενα, XLS, ΜDB ή SQL Server.
Το ΟLΕ DB χρησιμοποιεί το Comροnent Objed ModeI (COM) ως υποκείμενη τεχνολογία.
Με αυτές τις υπηρεσίες, μπορούν να εκλείψουν οι αντιγραφές μεταξύ των διαφορετικών εργαλείων πρόσβασης δεδομένων.
Επίσης, επειδή το CΟΜ είναι ένα πρότυπο του οποίου δικαιώματα έχουν οργανισμοί προτύπων, μπορεί να γίνει μια κοινή πλατφόρμα προτύπων καθώς συμμετέχουν κι άλλες εταιρίες.
Αυτό μπορεί να καταστήσει τον κώδικα πιο συμβατό και με περισσότερες δυνατότητες μεταφοράς ανάμεσα στα διάφορα περιβάλλοντα προγραμματισμού και εργαλεία.
Ενώ το OLE DB είναι μία system-level, δηλαδή χαμηλού επιπέδου προγραμματιστική διασύνδεση το ADO (ActiveΧ Data Objects) είναι μία application-level, δηλαδή υψηλού επιπέδου, αντικειμενοστρεφής προγραμματιστική διασύνδεση για δεδομένα παροχέων OLE DB.
Το ADO υλοποιεί ένα κοινό μοντέλο προγραμματισμού βάσεων δεδομένων για πρόσβαση σε κάθε παροχέα OLE-DB και επιτρέπει έτσι με τα προγραμματιστικά αντικείμενα που προσφέρει να γράφονται εφαρμογές με όμοιο τρόπο από Visual C++, Delphi, Visual Basic, Visual J++, ASP, Borland C++ Builder ακόμη και από γλώσσες script, όπως τις VB Script και Java Script.
Έτσι το ActiveΧ Data Objects (ADO) API, παρέχει μια εύκολη διασύνδεση για τη λειτουργικότητα των παροχέων OLE DB.
Στα περιβάλοντα προγραμματισμού υπάρχουν τα ADO Data-Bound Controls που χρησιμοποιούν την διεπαφή OLE DB IRowset που επιστρέφει ένα rowset (σύνολο γραμμών).
Υπάρχουν επίσης τα ADO data-source controls που μέσω της διεπαφής OLE DB IDataSource επιστρέφουν ένα δείκτη προς μία πηγή δεδομένων.
Ανοίξτε ένα νέο project (File->New->Application) από το περιβάλλον του Borland C++ Builder Από την καρτέλα Standard τοποθετήστε πάνω στη φόρμα 5 TLabel , 7 TEdit και 7 TButton Από την καρτέλα ADO τοποθετήστε ένα TADOConnection, δύο TADOQuery και ένα TADOCommand.
Αλλάξτε στο κάθε ένα από τα επτά TButton την ιδιότητα Name αντίστοιχα σαν btnFirst , btnPrevious , btnNext , btnLast , btnInsert , btnUpdate , btnDelete.
Αποθηκεύεστε όλο το Project (File->Save Project As) σε έναν κατάλογο ‘MyProject1’.
Πηγαίνετε στον κατάλογο αυτό και φτιάξτε μέσα του μία βάση δεδομένων της Access με όνομα SAMPLE.
Ανοίξτε τη βάση και τρέξτε την παρακάτω εντολή SQL για την δημιουργία του πίνακα customers
Στον πίνακα customers εισάγετε τις παρακάτω εγγραφές Επιστρέψτε στον C++ Builder και στην εφαρμογή σας.
Διπλοπατήστε πάνω στη φόρμα και εισάγετε το τμήμα κώδικα του FormCreate.
Πάνω από το FormCreate πρέπει να γράψετε τον κώδικα για τις τρεις συναρτήσεις ConnectDB, InitializeQueries και ShowCustomers όπως τις βλέπετε στο παράδειγμα.
Έπειτα διπλοπατήστε σε κάθε ένα button και γράψτε τον κώδικα όπως στο παράδειγμα, που θα επιτρέπει την μετακίνηση ανάμεσα στις εγγραφές με τα next, prior, first, last και την εισαγωγή δεδομένων στον πίνακα με το btnInsert, την ενημέρωση ή διόρθωση μιάς εγγραφής με το btnUpdate και την διαγραφή μιας εγγραφής με το btnDelete.
Ο κώδικας του Unit1.cpp φαίνεται παρακάτω btnFirst->Caption= "|<"; //ΠΡΩΤΗ ΕΓΓΡΑΦΗ btnPrevious->Caption = "<"; //ΠΡΟΗΓΟΥΜΕΝΗ ΕΓΓΡΑΦΗ btnNext->Caption = ">"; //ΕΠΟΜΕΝΗ ΕΓΓΡΑΦΗ btnLast->Caption = ">|"; //ΤΕΛΕΥΤΑΙΑ ΕΓΓΡΑΦΗ
Korth και S.
Sudrshan. “Συστήματα Βάσεων Δεδομένων, 4η Έκδοση”, Εκδόσεις Μ.
Γκιούρδας 2002.
Gehrkre, “Συστήματα Διαχείρισης Βάσεων Δεδομένων”, Εκδόσεις Τζιόλα, 2002.
Elmasri and S.B Navathe. “Θεμελιώδεις αρχές συστημάτων Βάσεων Δεδομένων, Τόμος Α’, 3η Έκδοση Αναθεωρημένη”.
Εκδόσεις Δίαυλος 2001.
Date. “Εισαγωγή στα συστήματα Βάσεων Δεδομένων, Τόμος Α’ ”.
Εκδόσεις Κλειδάριθμος Χ.
Σκουρλάς, “Σχεσιακές βάσεις δεδομένων”, Νέων Τεχν.
Αθήνα 2000.
Βασιλακόπουλος, “Σχεδιασμός Βάσεων Δεδομένων & SQL”, Πειραιάς, 1993.
Petkovic, “Οδηγός του SQL Server 2000”, Μ.
Γκιούρδας, 2000
Εκδόσεις Μ.
Γκιούρδας Ταξινόμηση κατά επωνυμο
Όπου Λογικές συνθήκες
Εμφάνιση όλων των Πεδίων
Από τον Πίνακα Φοιτητες where Λογικές Συνθήκες select προβολή πεδίων
Επιλέξτε ως Αρχεία τύπου: - (Text Files *.txt) μετά βρείτε τον φάκελο με τα δεδομένα, και έπειτα το αρχείο Φοιτητές.txt και πατήστε Εισαγωγή
Επιλέξτε σε υπάρχοντα πίνακα ‘Φοιτητες’ και
Είναι ήδη οριοθετημένα με στηλοθέτη (tab) και τα “” σαν προσδιοριστικό κειμένου.
Επιλέξτε επόμενο μην χρησιμοποιείτε τόνους στα ονόματα πινάκων και πεδίων
Ταξινόμηση κατά επώνυμο
Όπου Λογική συνθήκη
Από τον Πίνακα Φοιτητές
Εμφανίζονται στο αποτέλεσμα οι εγγραφές που ικανοποιούν τις λογικές συνθήκες
WHERE Λογικές Συνθήκες
Άρα η εσωτερική σύζευξη δεν αρκεί για να εμφανίσει όλες τις πληροφορίες της βάσης δεδομένων
Υποερώτημα στο FROM υπολογισμός για κάθε S
Η μεταβλητή παίρνει την τιμή της από το εξωτερικό ερώτημα
Ο SQL Server διαθέτει τελεστή full outer join
SELECT προβολή πεδίων
Πατήστε Ερώτημα->Εκτέλεση για να εμφανιστούν οι εγγραφές και έπειτα Αρχείο->αποθήκευση ως
Από τα ερωτήματα Δ05 και Δ07 φαίνεται ότι η σύζευξη είναι μία πράξη που επαναλαμβάνεται.
Στην παρούσα βάση δεδομένων έχουμε δύο κύριες συζεύξεις τις Καθηγητές-Διδασκαλιες-Μαθηματα και Φοιτητες-Εγγραφες-Μαθηματα, που επαναλαμβάνονται σε πολλά ερωτήματα SQL.
Υποερώτημα στο HAVING
