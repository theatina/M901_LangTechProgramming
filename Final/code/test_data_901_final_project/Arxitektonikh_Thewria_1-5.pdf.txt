Με την πολύτιµη συµβολή των συνεργατών Ιωάννη Μαδεµλή , και
ΤΕΙ Σερρών, Τµήµα Πληροφορικής & Επικοινωνιών Αρχιτεκτονική Η/Υ
Ανάγνωση παραµέτρων - υπολογισµός και ανάγνωση τελικής διεύθυνσης ή και
Κεφάλαια του Μαθήµατος
Εισαγωγή στον Η/Υ BGC-8088 και τον M/E Intel 8088
Ιστορία και εξέλιξη των Υπολογιστών
Βασικά και σύνθετα ψηφιακά κυκλώµατα (Πύλες, ολοκληρωµένα κυκλώµατα, συνδυαστικά κυκλώµατα, αθροιστές, ALU, κυκλώµατα ρολογιού, µνήµες)
Συστήµατα µε Μικροεπεξεργαστές (ιστορική εξέλιξη, εσωτερική αρχιτεκτονική, µέθοδοι κατασκευής, είδη υπολογιστών ) εσωτερική δοµή Μικροεπεξεργαστών (καταχωρητές, ALU, µονάδα ελέγχου, δίαυλος, µνήµη cache, τεχνολογίες)
Εντολές γλώσσας µηχανής (κύκλοι εντολών, φάσεις εκτέλεσης, ανάλυση εντολών σε βήµατα µικροκώδικα, κατηγορίες εντολών, παραλληλία εντολών, CISC και RISK)
Σήµατα ελέγχου (µνήµης, περιφερειακών συσκευών, DMA, σήµατα διακοπής, σήµατα κατάστασης, λοιπά σήµατα ελέγχου), ∆ιασύνδεση CPU και περιφερειακών συσκευών (DMA, ΙΝΤ)
Μνήµη (Ιεραρχία, οργάνωση µνήµης, ανάγνωση/εγγραφή, είδη µνήµης RAM-ROM, τεχνολογίες, κώδικες διόρθωσης λαθών)
Μνήµες ROM και RAM (τεχνολογίες κατασκευής, είδη µνήµης).
Κώδικες ανίχνευσης και διόρθωσης σφαλµάτων µνήµης.
Η µνήµη cache (Αρχές λειτουργίας, µέθοδοι σχεδίασης-υλοποίησης)
∆ίαυλοι επικοινωνίας (ISA, PCI, PCMCIA, USB, FireWire,AGP)
Κεφάλαιο 1.
Εισαγωγή στον Η/Υ BGC-8088 και τον M/E Intel
Ο Εκπαιδευτικός Αναπτυξιακός Υπολογιστής BGC-8088 MicroEngineer V.3 είναι κατασκευή της εταιρείας MICROPORT.
Βασίζεται στον µικροεπεξεργαστή INTEL 8088-2, που αποτελεί την έκδοση διπλού χρονισµού (λειτουργεί στα 4.77 MHz και τα 8 MHz) του απλούστερου INTEL 8088 (4.77 MHz) που ήταν ο επεξεργαστής του πρώτου IBM PC, στον οποίο βασίζονται οι σύγχρονοι υπολογιστές µε επεξεργαστές της σειράς x86 και Pentium της Ο µικροεπεξεργαστής (Μ/Ε) 8088 είναι ο πρόγονος όλων των Μ/Ε 80x86 και Pentium της Intel, οι οποίοι είναι όλοι προς τα πίσω συµβατοί µε αυτόν. αυτό σηµαίνει ότι ένα πρόγραµµα γραµµένο σε γλώσσα µηχανής του 8088 µπορεί να εκτελεστεί ο χωρίς καµία τροποποίηση σε όλους τους επόµενους επεξεργαστές της να παίρνουν.
Έτσι τα προγράµµατα που φτιάχνουµε για τον 8088 µπορούν κάλλιστα να εκτελεστούν και στα desktop PC ή laptop που έχουµε και στο σπίτι.
O BGC-8088 έχει 32Κ RAM και 16Κ ROM που µπορούν να επεκταθούν µε άλλα 16 Κ ROM µε προγράµµατα του χρήστη.
Η επικοινωνία µε τον χρήστη γίνεται µέσω ενός πληκτρολογίου 56 πλήκτρων σε διάταξη QWERTY που περιλαµβάνει όλους τους εκτυπώσιµους χαρακτήρες και σύµβολα, καθώς και πλήκτρα λειτουργιών και ελέγχου, και µίας LCD οθόνης 2 γραµµών και 40 χαρακτήρων.
Προαιρετικά µπορεί να δεχθεί κάρτα HERCULES καθώς διαθέτει υποδοχές προτύπου ISA όπως και ο IBM-PC.
Η κάρτα HERCULES είναι µια κάρτα γραφικών που προσφέρει ανάλυση 80 χαρακτήρων και 24 γραµµών µε µονόχρωµη απεικόνιση.
Με τη χρήση της κάρτας αυτής και µε τη χρήση έτοιµων ρουτινών βιβλιοθήκης που είναι αποθηκευµένες στη µνήµη ROM του υπολογιστή, η εµφάνιση στην οθόνη µπορεί να προσοµοιάσει αυτή των κανονικών υπολογιστών, καθιστώντας την εργασία µε τον ηλεκτρονικό υπολογιστή πολύ πιο ∆ιαθέτει 2 υποδοχές ISA των 62 pins για σύνδεση καρτών επέκτασης ISA των 8 bit.
∆ιαθέτει µία σειριακή θύρα επικοινωνίας RS232-C, και µία παράλληλη θύρα επικοινωνίας (πχ. για σύνδεση εκτυπωτή), καθώς και ειδική θύρα σύνδεσης εκπαιδευτικών πλακετών των 50 pin (address, data, control).
Σε αυτή την θύρα εξάγονται όλες οι γραµµές του διαύλου διευθύνσεων, του διαύλου δεδοµένων αλλά και του διαύλου ελέγχου, και χρησιµοποιείται για σύνδεση επιπλέον περιφερειακών συσκευών, όπως καρτών Multi-I/O.
∆ιαθέτει επίσης έναν Προγραµµατιζόµενο Χρονιστή (Prorammable Interval Timer – PIT) 8254 της INTEL που χρησιµοποιείται για παραγωγή σηµάτων χρονισµού και ως µετρητής χρόνου (counter), ένα chip Προγραµµατιζόµενης ∆ιεπαφής Περιφερειακών (Programmable Peripheral Interface – PPI) 8255 της INTEL που παρέχει 3 θύρες Εισόδου / Εξόδου των 8-bit πλήρως προγραµµατιζόµενες, και έναν Προγραµµατιζόµενο Ελεγκτή ∆ιακοπών (Programmable Interrupt Controller – PIC) 8259Α της INTEL που παρέχει 8 γραµµές Τέλος διαθέτει ειδική θύρα σύνδεσης εκπαιδευτικών πλακετών των 50 pin όπου συνδέονται όλες οι γραµµές του data bus, του address bus και οι γραµµές ελέγχου (control bus) του
O 8088 είναι ένας Μ/Ε τεχνολογίας HMOS, µε εσωτερική αρχιτεκτονική των 16 bit (χρησιµοποιεί καταχωρητές των 16 bit) αλλά έχει ∆ίαυλο ∆εδοµένων (Data Bus) των 8 bit για επικοινωνία µε την µνήµη και τις Π.Σ., κάτι που κάνει πιο φθηνή την κατασκευή µητρικών (motherboards) και περιφερειακών σε σχέση µε τον 8086 που έχει Data Bus των 16 bit.
Με την επιλογή τους αυτή οι τεχνικοί της εταιρείας INTEL θέλησαν να δώσουν µεγαλύτερο βάρος στην ελαχιστοποίηση του κόστους κατασκευής µητρικών πακέτων αλλά και περιφερειακών συσκευών για τον επεξεργαστή 8088 θυσιάζοντας την ταχύτητα του διαύλου δεδοµένων, ο οποίος έχει το µισό εύρος από ό,τι οι καταχωρητές του επεξεργαστή.
Επίσης έχει ∆ίαυλο ∆ιευθύνσεων (Address Bus) των 20 bit, οπότε και µπορεί να απευθυνθεί σε 220 = 1048576 = 1ΜΒ µνήµη (RAM και ROM).
∆ιαθέτει 14 καταχωρητές των 16 bit για γενικές και ειδικές λειτουργίες, µερικοί από τους οποίους µπορούν να χωρισθούν σε δύο καταχωρητές των 8-bit.
∆ιαθέτει 90 συνολικά εντολές γλώσσας µηχανής που έχουν 24 συνολικά διαφορετικούς τρόπους σύνταξης (addressing modes).
Περιλαµβάνουν αριθµητικές πράξεις στα 8 ή 16 bit, µε πρόσηµο ή χωρίς, (περιλαµβ. πολ/σµος και διαίρεση).
Στο σύνολο εντολών του επεξεργαστή περιλαµβάνονται επίσης και πολύπλοκες αριθµητικές εντολές όπως ο πολλαπλασιασµός ακεραίων αριθµών και η διαίρεση ακεραίων αριθµών, µε πρόσηµο και
Ο Μικροεπεξεργαστής INTEL 8088 και τα pin του. οποίους µπορούν να χωρισθούν σε δύο καταχωρητές των 8-bit.
Οι καταχωρητές του 8088
Ονοµα Καταχωρητή ∆οµή Χρήση BX BH BL Base (Καταχωρητής Βάσης) BP Base Pointer (∆είκτης Βάσης) SI Source Index (∆είκτης Πηγής) DI Destination Index (∆είκτης Κατέυθυνσης) SP Stack Pointer (∆είκτης Στοίβας) IP Instruction Pointer (∆είκτης Εντολής) CS Code Segment (Τµήµα Κώδικα) DS Data Segment (Τµήµα ∆εδοµένων) SS Stack Segment (Τµήµα Στοίβας) ES Extra Segment (Εξτρα Τµήµα) FG FlaG Register (Καταχωρητής Σηµαιών)
Καταχωρητές γενικής και ειδικής χρήσης Οι καταχωρητές AX, BX, CX, DX µπορούν να θεωρηθούν και ως διπλοί καταχωρητές των 2x8 bit.
Για παράδειγµα ο χρήστης µπορεί να προσπελάσει τον καταχωρητή AX και µέσω των δύο 8-bit καταχωρητών AH και AL.
Ο AH αντιστοιχεί στο υψηλότερης τάξης τµήµα του AX (δηλαδή τα bits 8-15) ενώ ο AL αντιστοιχεί στο χαµηλότερης τάξης τµήµα του AX (δηλαδή τα bits 0-7).
To ίδιο συµβαίνει αντίστοιχα και για τους καταχωρητές BX, CX και DX.
Οι καταχωρητές αυτοί είναι γενικής χρήσης, δηλαδή µπορούν να µεταφέρουν δεδοµένα προς και από τη µνήµη, να εκτελέσουν αριθµητικές πράξεις κλ.π.
Ο Συσσωρευτής όµως (ΑΧ) είναι πιο σηµαντικός από τους υπόλοιπους καθώς συγκεκριµένες εντολές και τρόποι προσπέλασης µνήµης εκτελούνται µόνο µε αυτόν, όπως ο πολλαπλασιασµός και η διαίρεση.
Οι καταχωρητές CS, DS, SS, ES είναι καταχωρητές τµηµάτων (segment registers) και χρησιµοποιούνται για την προσπέλαση µνήµης του 8088 η οποία γίνεται µε τµήµατα (segments) και µετατοπίσεις (offsets).
Η προσπέλαση µνήµης στον 8088 Ο επεξεργαστής 8088 µπορεί να προσπελάσει 1ΜΒ µνήµης έχοντας address bus µε 20 γραµµές διευθύνσεων (220=1048576).
Για συµβατότητα όµως µε τον προηγούµενο επεξεργαστή της INTEL, τον 8080, κατασκευάστηκε µε καταχωρητές διευθύνσεων των 16 bits (216=65536).
Έτσι επινοήθηκε η µέθοδος των παραγράφων (paragraphs), σύµφωνα µε την οποία, κάθε διεύθυνση των 16 bits δεν αναφέρεται σε απόλυτη διεύθυνση αλλά στην αρχή µίας δεκαεξάδας από bytes (π.χ. η διεύθυνση 000116 αναφέρεται στην αρχή της πρώτης δεκαεξάδας µνήµης : 0001016=16, η 000216 στην αρχή της δεύτερης δεκαεξάδας µνήµης : 0002016=32 κ.λ.π.).
Η τελευταία δεκαεξάδα είναι η FFFF16 που αναφέρεται στην διεύθυνση Για την προσπέλαση οποιασδήποτε διεύθυνσης µνήµης εκτός από την διεύθυνση παραγράφου (segment) χρειάζεται και µία διεύθυνση µετατόπισης (offset).
Έτσι οι διευθύνσεις σχηµατίζονται ως segment:offset.
H µετατόπιση (offset) θα αρκούσε να είναι των 4 bits (24=16) έτσι ώστε να προσδιορίζει το byte της δεκαεξάδας.
Για λόγους οµοιογένειας όµως το offset είναι επίσης των 16 bits και µπορεί να δώσει 216=65536 διαφορετικές διευθύνσεις πάνω από την αρχή της παραγράφου, και όχι µόνο 16.
Έτσι έχοντας το segment σταθερό και αλλάζοντας το offset, προφανώς «µπαίνουµε» και στον χώρο των επόµενων δεκαεξάδων της µνήµης.
Από τα παραπάνω είναι κατανοητό ότι δεν είναι µονοσήµαντη η διευθυνσιοδότηση µνήµης µε την µέθοδο segment:offset, δηλαδή για κάθε απόλυτη διεύθυνση µνήµης υπάρχουν πολλοί συνδυασµοί segment:offset που την προσδιορίζουν (π.χ. το 17ο byte µνήµης έχει διεύθυνση 0001:0001 αλλά και 0000:0011).
Για να βρούµε την απόλυτη διεύθυνση µνήµης ακολουθούµε τον απλό τύπο :
Απόλυτη διεύθυνση = segment X 16 + offset.
Έτσι οι καταχωρητες τµηµάτων (CS,DS,SS,ES) φτιάχτηκαν για να καταχωρούν το κοµµάτι ‘segment’ από την έκφραση «segment:offset» των διευθύνσεων µνήµης που σχηµατίζονται στον επεξεργαστή κατά την διάρκεια της λειτουργίας του και της εκτέλεσης εντολών.
Η σηµασία του segment και του offset
Τµήµατα προγράµµατος και καταχωρητές Οι τεχνικοί της εταιρείας INTEL, µαζί µε τις προδιαγραφές του επεξεργαστή, καθόρισαν και τις προδιαγραφές των προγραµµάτων που θα µπορούσε αυτός να εκτελέσει.
Έτσι, όρισαν ότι κάθε εκτελούµενο πρόγραµµα θα έπρεπε να αποτελείται από τρία διαφορετικά τµήµατα, τα
Το τµήµα κώδικα (code segment) όπου βρίσκεται το ίδιο το πρόγραµµα,
Το τµήµα δεδοµένων (data segment) όπου βρίσκονται οι µεταβλητές του προγράµµατος (data) και,
To τµήµα στοίβας (stack segment) που χρησιµοποιείται για την στοίβα του προγράµµατος (stack) που είναι ένα τµήµα µνήµης το οποίο προσπελαύνεται από τον 8088 µε δοµή LIFO (Last in First out) και χρησιµοποιείται για προσωρινή αποθήκευση δεδοµένων, όπως προσωρινή αποθήκευση καταχωρητών, πέρασµα Έτσι ο 8088 έχει έναν καταχωρητή τµήµατος για κάθε ένα από τα 3 αυτά τµήµατα, που «δείχνει» την δεκαεξάδα στην οποία ξεκινάει το κάθε τµήµα.
Οι καταχωρητές αυτοί είναι :
Ο CS (code segment register) που δείχνει στο τµήµα κώδικα,
Ο DS (data segment register) που δείχνει στο τµήµα δεδοµένων, και
O SS (stack segment register) που δείχνει στο τµήµα στοίβας.
O τέταρτος καταχωρητής τµήµατος που είναι ο ES (Extra segment register) χρησιµοποιείται ως «γενικής χρήσης» καταχωρητής τµήµατος που µπορεί να «δείξει» σε οποιοδήποτε άλλο τµήµα (δεκαεξάδα) της µνήµης ώστε να προσπελάσει οποιαδήποτε διεύθυνση χωρίς να «χαλάσει» τις τιµές των CS,DS,SS που είναι αφιερωµένοι για άλλο σκοπό.
Το κάθε τµήµα (κώδικα, δεδοµένων, στοίβας, έξτρα) έχοντας σταθερή διεύθυνση segment, µπορεί µέσω του µεταβλητού 16µπιτου offset να έχει µέγεθος µέχρι 64Κ (0000..FFFF).
Αλλάζοντας τιµή στον segment register κάποιου τµήµατος είναι δυνατή η επανατοποθέτηση (relocation) του τµήµατος σε οποιαδήποτε δεκαεξάδα µνήµης.
Παράδειγµα τοποθέτησης των 3 τµηµάτων ενός προγράµµατος στη µνήµη και αντίστοιχες τιµές των καταχωρητών τµηµάτων.
Στην επόµενη εικόνα που συµπεριλαµβάνεται στο εγχειρίδιο της Ιntel για τον 8088 φαίνονται χαρακτηριστικά τα 3 τµήµατα προγράµµατος καθώς και το «Εξτρα Τµήµα» στο ποίο µπορεί να δείχνει ο ES register Επίσης φαίνονται σχηµατικά:
Το µέγεθος των τµηµάτων που δεν ξεπερνά τα 64Κ
Η έννοια της µετατόπισης (offset)
Η σειρά µε την οποία τοποθετούνται στην µνήµη τα bytes των αριθµών πολλαπλών byte, δηλαδή πρώτα το byte χαµηλής τάξης (LSB) και µετά το byte υψηλής τάξης
Τµήµατα προγράµµατος και αντίστοιχοι καταχωρητές τµηµάτων
Για την αποθήκευση του “offset” κοµµατιού της διεύθυνσης µνήµης που είναι σε µορφή «segment:offset» χρησιµοποιούνται άλλοι καταχωρητές του 8088.
Για παράδειγµα, ο καταχωρητής IP (Instruction Pointer) κρατάει το ‘offset’ κοµµάτι της διεύθυνσης που δείχνει πάντα την επόµενη εντολή που θα εκτελεστεί.
Το ‘segment’ κοµµάτι της διεύθυνσης το κρατάει ο καταχωρητής CS (code segment register).
Έτσι η διεύθυνση µνήµης που σχηµατίζεται από τους καταχωρητές CS:IP είναι πάντα η διεύθυνση της επόµενης εντολής κώδικα µηχανής που θα εκτελεστεί.
Σηµείωση: στον BGC-8088 οι εξ’ορισµού τιµές για τους καταχωρητές τµηµάτων είναι : Α/Α Καταχωρητής Αρχική Τιµή
Λαµβάνοντας υπ’ όψιν ότι η αρχική τιµή του καταχωρητή IP είναι 0000, συµπεραίνουµε ότι τα προγράµµατα που γράφουµε στον BGC-8088 ξεκινούν εξ’ ορισµού από την διεύθυνση : 0100:0000 που µεταφράζεται σε απόλυτη διεύθυνση : 0100016=409610.
Παράδειγµα 2: Η εντολή CMPSB συγκρίνει ένα byte ενός string από την διεύθυνση DS:SI µε ένα byte ενός άλλου string στην διεύθυνση ES:DI, επηρεάζοντας τις σηµαίες (flags).
Εδώ οι SI (Source Index) και DI (Destination Index) έχουν καταχωρηµένα τα offset.
Το ποιός καταχωρητής segment χρησιµοποιείται σε κάθε προσπέλαση µνήµης είναι πολύ Όταν προσπελαύνεται διεύθυνση µνήµης που αντιστοιχεί σε κώδικα (πρόγραµµα), τότε χρησιµοποιείται ο CS register.
Παράδειγµα στην εντολή JMP 0300, επειδή η διεύθυνση 0300 αντιστοιχεί σε κάποιο κοµµάτι του προγράµµατος γλώσσας µηχανής, η πραγµατική διεύθυνση διακλάδωσης του προγράµµατος είναι CS:0300, δηλαδή ότι αριθµό έχει ο CS Όταν προσπελαύνεται διεύθυνση µνήµης που αντιστοιχεί σε δεδοµένα, τότε χρησιµοποιείται ο DS register.
Για παράδειγµα στην εντολή ADD AX,[1234] η οποία θα προσθέσει στο περιεχόµενο του καταχωρητή AX το περιεχόµενο της θέσης µνήµης [1234], η πραγµατική διεύθυνση µνήµης που διαβάζεται είναι η DS:1234.
Τέλος, όταν προσπελαύνεται διεύθυνση µνήµης που αντιστοιχεί στην στοίβα (stack), τότε χρησιµοποιείται ο καταχωρητής SS.
Παράδειγµα στην εντολή PUSH BX το περιεχόµενο του καταχωρητή BX θα καταχωρηθεί στην πραγµατική διεύθυνση SS:SP όπου ο SP (Stack Pointer) είναι ο καταχωρητής που δείχνει πάντοτε την «κορυφή» του stack.
Στο σετ των καταχωρητών του 8088 υπάρχουν και ειδικοί καταχωρητές όπως : ¾ Ο καταχωρητής IP (Instruction Pointer) που δείχνει την επόµενη εντολή που θα εκτελεστεί (µέσα στο Τµήµα Κώδικα – Code Segment) ¾ Ο καταχωρητής SP (Stack Pointer) ο οποίος δείχνει το σηµείο µέχρι το οποίο έχει γεµίσει η στοίβα (stack) µέσα στο Τµήµα Στοίβας (Stack Segment).
Ο καταχωρητής ξεκινά µε µεγάλη τιµή (0B3F) και όσο γεµίζει το stack αυτός µειώνεται (το stack γεµίζει από πάνω προς τα κάτω, δηλαδή από µεγάλες διευθύνσεις προς µικρότερες).
Ο καταχωρητής FG (Flag Register) περιέχει σηµαίες (flags) που δείχνουν ή καθορίζουν την κατάσταση του επεξεργαστή.
Κάθε σηµαία (flag) έχει µέγεθος 1 bit καθώς αναπαριστά µία διακοπτική ένδειξη ή λειτουργία που µπορεί να είναι ON ή OFF.
Στον καταχωρητή FG δεν έχει σηµασία η τιµή του ως 16-bit δυαδικό νούµερο, αλλά το κάθε bit ξεχωριστά και ανεξάρτητα από τα υπόλοιπα, που έχει και την δική του ξεχωριστή σηµασία.
Η σηµασία των bits του Καταχωρητή Σηµαιών του 8088 είναι η εξής : Ως γνωστόν από τα 16 bits του FG χρησιµοποιούνται µόνο τα 9 που είναι : Bit Ονοµασία Συντ Εξήγηση 0 Carry Flag CY Κρατούµενο, γίνεται 1 όταν αποτελέσµατα πράξεων ξεπερνούν το όριο των 16 bits. 2 Parity Flag PF Σηµαία Ισοτιµίας, γίνεται 1 όταν το αποτέλεσµα µίας πράξης έχει ζυγό αριθµό µονάδων. 4 Auxiliary Carry AF Βοηθητικό Κρατούµενο, γίνεται 1 όταν µεταφέρεται κρατούµενο από το byte χαµηλής τάξης στο byte υψηλής τάξης 6 Zero Flag ZF Σηµαία Μηδενός, γίνεται 1 όταν το αποτέλεσµα µίας πράξης π.χ.
ADD σε οποιοδήποτε καταχωρητή, είναι ίσο µε 0. 7 Sign Flag SF Σηµαία Προσήµου, γίνεται 1 όταν το αποτέλεσµα µίας πράξης είναι αρνητικός αριθµός. 8 Trap Flag TF Σηµαία Βηµατικής Εκτέλεσης, όταν είναι 1 εκτελεί τις εντολές βήµα-βήµα για debugging. 9 Interrupt Flag IF Σηµαία Αποδοχής ∆ιακοπών, όταν είναι 1 επιτρέπεται η διακοπή του προγ/τος από interrupts 10 Direction Flag DF Σηµαία Κατεύθυνσης, 1 = οι εντολές string εκτελούνται από υψηλές δ/νσεις προς χαµηλές. 11 Overflow Flag OF Σηµαία Υπερχείλισης, γίνεται 1 όταν το αποτέλε-σµα µίας πράξης ξεπερνά το όριο των προσηµασµένων αριθµών δηλαδή -
Στο παραπάνω διάγραµµα φαίνεται καθαρά ότι : Οι καταχωρητές γενικής χρήσεως καθώς και οι καταχωρητές δείκτη βρίσκονται τοπολογικά κοντά και συνδέονται µεταξύ τους µε έναν δίαυλο που ονοµάζεται A-Bus.
Στον ίδιο δίαυλο συνδέεται η αριθµητική και λογική µονάδα ALU η οποία κάνει τις πράξεις των ακεραίων.
Επίσης βλέπουµε ότι οι καταχωρητές τµηµάτων που σχετίζονται µε τις διευθύνσεις είναι επίσης τοπολογικά κοντά και συνδέονται µεταξύ τους µε έναν άλλο δίαυλο που ονοµάζεται B-Bus.
Στον ίδιο δίαυλο βλέπουµε να συνδέεται µία µονάδα πρόσθεσης η οποία στην ουσία βρίσκεται µέσα στην αριθµητική και λογική µονάδα και η οποία χρησιµοποιείται για να προσθέτει τις διευθύνσεις βάσης και τους δείκτες ώστε να προκύπτουν οι τελικές διευθύνσεις όταν χρησιµοποιούνται δεικτοδοτούµενες διευθυνσιοδοτήσεις π.χ.
Η µνήµη του BGC-8088 BGC-8088 έχει 32Κ RAM και 16Κ ROM επεκτάσιµα µε άλλα 16 Κ ROM µε ίναι χαρτογραφηµένη στις διευθύνσεις 0000016 … 07FFF16 (0…32767).
Οι α κάθε ρουτίνα η διεύθυνσή της αποτελείται προγράµµατα του χρήστη.
Θεωρητικά θα µπορούσε να φιλοξενήσει έως και 1ΜΒ µνήµη πρώτες 4096 διευθύνσεις είναι δεσµευµένες και χρησιµοποιούνται από το πρόγραµµα MONITOR (0000016 … 00FFF16).
Από αυτές οι πρώτες 1024 διευθύνσεις (0000016 … 003FF16) περιέχουν τις διευθύνσεις των ρουτινών εξυπηρέτησης των διακοπών (vectors of Οι διακοπές µπορεί να είναι µέχρι και 256.
Γι από 4 byte (2 byte segment + 2 byte offset).
Για παράδειγµα η διεύθυνση της ρουτίνας εξυπηρέτησης της διακοπής 85 (INT 85), που όταν εκτελεστεί επανεκκινεί το πρόγραµµα MONITOR, βρίσκεται στην θέση 0021416 = 8516 x 4.
Εκεί υπάρχουν διαδοχικά τα bytes 9F 01 00 FC.
Τα πρώτα 2 είναι low και high bytes του offset, και τα 2 επόµενα τα low και high bytes του segment.
Έτσι η πραγµατική διεύθυνση της ρουτίνας εξυπηρέτησης της διακοπής 85 είναι η FC00:019F.
Η διεύθυνση αυτή είναι στην ROM του µηχανήµατος.
Οι διευθύνσεις των ρουτινών εξυπηρέτησης των διακοπών βρίσκονται στη Επειδή όµως κατά την έναρξη λειτουργίας του ηλεκτρονικού υπολογιστή η µνήµη RAM είναι κενή ή περιέχει σκουπίδια, θα πρέπει προφανώς µε κάποιον τρόπον οι διευθύνσεις των ρουτινών να τοποθετούνται στις σωστές διευθύνσεις της µνήµης RAM.
Αυτός που τις τοποθετεί στις σωστές διευθύνσεις κατά την εκκίνηση του ηλεκτρονικού υπολογιστή δεν είναι άλλος από το πρόγραµµα εκκίνησης που βρίσκεται σε µνήµη ROM και που στα PC ονοµάζεται BIOS ενώ στον BGC-8088 ονοµάζεται πρόγραµµα MONITOR.
Οι διευθύνσεις των ρουτινών είναι τοποθετηµένες στη RAM και όχι σε µόνιµη µνήµη ROM για έναν πολύ καλό λόγο: όταν µετά το πρόγραµµα εκκίνησης, φορτωθεί κάποιο λειτουργικό σύστηµα, όπως τα Windows η το Linux, τότε αυτό έχει την δυνατότητα να αλλάξει τις διευθύνσεις των ρουτινών εξυπηρέτησης των διακοπών, εφόσον αυτές είναι στη RAM, και να βάλει δικές τους διευθύνσεις ρουτινών οι οποίες θα δείχνουν σε δικές του υπορουτίνες διαχείρισης των διακοπών.
Οι ρουτίνες διαχείρισης των διακοπών των λειτουργικών συστηµάτων πρώτα καλούν τις αντίστοιχες ρουτίνες της ROM και στη συνέχεια εκτελούν επιπλέον κώδικα που είναι απαραίτητος για την οµαλή λειτουργία του εκάστοτε λειτουργικού συστήµατος.
Τα interrupt vectors και το jump εκκίνησης ι υπόλοιπες 28672 θέσεις µνήµης είναι διαθέσιµες για προγράµµατα του (0100016 ο καταχωρητής CS έχει την εξ’ ορισµού τιµή 0100 (0100:0000 = απόλυτη
Η µνήµη ROM του BGC-8088 α 16 ΚΒ της µνήµης ROM που περιλαµβάνουν το πρόγραµµα MONITOR και τους drivers πορεί να προσθέσει ο χρήστης (ελεύθερο slot µνήµης) χαρτογραφούνται ην εκκίνηση (εφαρµογή τροφοδοσίας) και κατά την επανεκκίνηση (reset) του τή συνήθως είναι ένα JMP στην ρουτίνα εκκίνησης του συστήµατος που ανήκει
Ο χάρτης µνήµης του BGC-8088 το παρακάτω σχήµα φαίνεται η πλήρης χαρτογράφηση της µνήµης του BGC-8088
Για τον λόγο αυτό είναι χαρτογραφηµένα στις διευθύνσεις FC00016 … FFFFF16, δηλαδή «ψηλά» στην µνήµη στο όριο του 1 ΜΒ. στις διευθύνσεις F800016 … FBFFF16, δηλαδή ακριβώς κάτω από την υπάρχουσα µνήµη µηχανήµατος, ο 8088 αλλά και όλοι οι απόγονοί του στην σειρά x86 και Pentium της INTEL, ξεκινούν µε την εκτέλεση της εντολής που βρίσκεται στην διεύθυνση FFFF016, που είναι στο BIOS (του προγράµµατος MONITOR στην περίπτωση του BGC-8088) που είναι σε µόνιµη µνήµη ROM.
Περιοχή Μνήµης ∆ιευθύνσεις Χώρος (bytes) Εντολή εκκίνησης του συστήµατος FFFFF 00010
ROM που περιέχει το πρόγραµµα MONITOR και
Χώρος για ROM µε προγράµµατα του χρήστη (ελεύθερο slot µνήµης)
Χώρος διευθύνσεων που δεν αντιστοιχεί σε chip
Ελεύθερος χώρος για προγράµµατα του χρήστη 07FFF 0700016
Περιοχή Μεταβλητών του προγράµµατος MONITOR 00FFF ∆ιευθύνσεις των ρουτινών εξυπηρέτησης των διακοπών – Interrupt Vectors
Οι Εντολές Γλώσσας Μηχανής του 8088 ς.
Κάθε τέτοια εντολή συντάσσεται ε έως και 30 διαφορετικούς τρόπους.
Κάθε Συνδυασµός Εντολής (Τρόπος Σύνταξης) έχει
Εντολές Αριθµητικών Πράξεων (Arithmetic Commands)
Ο Intel 8088 έχει 90 συνολικά εντολές Γλώσσας Μηχανή τον δικό του κωδικό εντολής (operation code ή opcode) και παραµέτρους που είναι συνήθως, σταθερά νούµερα, καταχωρητές ή θέσεις µνήµης.
Οι εντολές του 8088 χωρίζονται σε 6 κατηγορίες πο
Εντολές Μεταφοράς δεδοµένων (Data Transfer Comm
Εντολές Λογικών Πράξεων (Logic Commands)
Εντολές χειρισµού αλφαριθµητικών (String Manipulation
Εντολές Ελέγχου Ροής Προγράµµατος (Program Flow Control Comm
Εντολές Ελέγχου του Επεξεργαστή (Processor Control Commands)
1 MOV Move (Μετακίνηση) µένα µεταξύ καταχωρητών και Μεταφέρει δεδο 2 PUSH Push (Ώθησε στη στοίβα) Ωθεί τους καταχωρητές στη στοίβα 3 POP Pop (Ανέκτησε από στοίβα) στοίβα Ανακτά τιµές καταχωρητών από τη 4 XCHG Exchange (Ανταλλαγή) Ανταλλάσσει τιµές καταχωρητών και µνήµης 5 IN Input (Είσοδος από θύρα) ∆ιαβάζει δεδοµένα από θύρα I/O 6 OUT Output (Έξοδος σε θύρα) Εξάγει δεδοµένα σε θύρα Ι/Ο 7 XLAT ι ση DS:BX+AL και Translate (µετατροπή βάσε Ψάχνει σε look-up table στη θέ 8 LAHF Load AH with Flags Βάζει τις σηµαίες στον AH 9 SAHF Store AH into Flags Αντιγράφει τον ΑΗ στις σηµαίες
Εντολές Αριθµητικών Πράξεων
1 ADD Add (Πρόσθεση χωρίς κρ.) ρίς κρατούµενο Προσθέτει χω 2 ADC Add with Carry (Πρόσθεση 3 INC Increment (Αύξηση) Αυξάνει καταχωρητές κατά 1 4 SUB Subtract (Αφαίρεση χ ωρίς ί δανεικό Αφαιρεί χωρίς να χρησιµοποιε 5 SBB Subtract with Borrow Αφαιρεί µε χρήση δανεικού 6 DEC Decrement (Μείωση) Μειώνει καταχωρητές κατά 1 7 NEG Negative (Αρνητικό) Αλλάζει το πρόσηµο του αριθµού 8 CMP Compare (Σύγκριση) Συγκρίνει τα περιεχόµενα καταχωρητών και µνήµης
Πολλαπλασιάζει θετικούς αριθµούς, χωρίς πρόσηµο
IMUL Integer Multiply (Πολ Πολλαπλασιάζει ακέραιους προσηµασµένους 11 DIV Division (∆ιαίρεση) ∆ιαιρεί ακέραιους θετικούς αριθµούς χωρίς πρόσηµο 12 IDIV Integer Division (∆ιαίρεση ∆ιαιρεί ακέραιους προσηµασµένους αριθµούς 13 CBW Convert Byte to Word Μετατρέπει έναν αριθµό από 1 byte σε 2 yte Μετατρέπει έναν αριθµό από 2 byte σε 4 b
Εντολές Λογικών Πράξεων
1 AND And (Λογικό ΚΑΙ) ό ΚΑΙ µεταξύ bits Εκτελεί λογικ 2 OR Or (Λογικό Ή) Εκτελεί λογικό Ή µεταξύ bits 3 XOR ικό Ή) ύ bits Xor (Αποκλειστ Εκτελεί αποκλειστικό Ή µεταξ 4 TEST Test (Έλεγχος bits) Εκτελεί λογικό ΚΑΙ µεταξύ bits χωρίς να καταχωρεί 5 ΝΟΤ Not (Λογική Άρνηση) του αριθµού Αντιστρέφει τα bits (µετακίνηση bits αριστερά) ηρώνοντας Μετακινεί τα bits αριστερά συµπλ τα bits δεξιά συµπληρώνοντας µηδενικά Shift Logical Right (µετακίνηση bits δεξ
Μετακινεί τα bits δεξιά κρατώντας το πρόσηµο Shift Arithmetic Right (αριθµ.µετακ. bits δεξιά 9 ROL Περιστρέφει τα bits του αριθµού 1 θέση αριστερά (το Rotate Left (Περιστροφή αριστερά) τελευταίο πάει πρώτο) 10 ROR t (Περιστροφή αριθµού 1 θέση δεξιά (το Rotate Righ Περιστρέφει τα bits του πρώτο πάει τελευταίο) αριθµού αρι-στερά µε Rotate συµµετοχή του κρατούµενου ού δεξιά µε συµµετοχή Rotate with Carry Right (Περ/φή δεξιά µε κρατού Περιστρέφει τα bits του αριθµ
Εντολές Χειρισµού Αλφαριθµητικών /α Εντολή Εξήγηση Λειτουργία
1 REP Repeat (Επανέλαβε) νει την επόµενη εντολή Επαναλαµβά 2 MOVS φή te προς byte Move String (Αντιγρα Αντιγράφει ένα String σε ένα άλλο by 3 CMPS e String (Σύγκριση Συγκρίνει δύο String byte προς byte Compar 4 SCAS ing (Ανίχνευση Ψάχνει ένα χαρακτήρα µέσα σε ένα string Scan Str 5 LODS ing (Φόρτωση Φορτώνει τα byte ενός string σε καταχωρητή Load Str 6 STOS ring (Αποθήκευση Αποθηκεύει την τιµή ενός καταχωρητή σε ένα String.Store St
Εντολές Ελέγχου Ροής Προγράµµατος
1 CALL Call (Κλήση υπορουτίνας) ν εκτέλεση σε υπορ/να Μεταφέρει τη 2 RET Return (Επιστροφή από Επιστρέφει στο κυρίως πρόγραµµα µετά από την 3 JMP Jump (∆ιακλάδωση) Μεταφέρει την εκτέλεση σε άλλη εντολή 4 JE/JZ Jump on Equal/Zero ∆ιακλάδωση σε ισότητα /µηδέν ∆ιακλάδωση σε ανισότητα / διάφορο του µηδενός ∆ιακλάδωση σε περίπτωση που ο 1ος είναι µικρότερος του 2ου (προσηµασµ.) µικρότερος ή ίσος του 2ου (προσ.) ∆ιακλάδωση σε περίπτωση που ο 1ος δεν είναι ∆ιακλάδωση σε περίπτωση που ο 1ος είναι µεγαλύτερος του 2ου (προσηµασµ.) µικρότερος του 2ου (θετικοί) µικρότερος ή ίσος του 2ου (θετικοί) µεγαλύτερος του 2ου (θετικοί) 14 JP/JPE Jump on Parity Even ∆ιακλάδωση σε Ζυγή Ισοτιµία 15 JNP/JPO Jump on Parity Odd ∆ιακλάδωση σε Μονή Ισοτιµία 16 JS Jump on Sign ∆ιακλάδωση σε αρνητικό αριθµό 17 JNS Jump on not Sign ∆ιακλάδωση σε θετικό αριθµό 18 JCXZ Jump on CX Zero ∆ιακλάδωση όταν ο CX γίνει 0 19 LOOP Loop (Βρόχος CX) Εκτελεί επαναληπτικά εντολές µε απαριθµητή τον 20 LOOPZ Loop Zero (Βρόχος CX µε Εκτελεί επαναληπτικά εντολές µε απαριθµητή τον CX και όσο ισχύει σχέση ισότητας 21 LOOPNZ Loop Zero (Βρόχος CX µε CX και όσο ισχύει σχέση ανισότητας 22 ΙΝΤ Interrupt (∆ιακοπή) ∆ιακοπή Λογισµικού – Μεταφέρει την εκτέλεση σε
Επιστρέφει στο κυρίως πρόγραµµα µετά από ρουτίνα
Εντολές Ελέγχου του Επεξεργαστή α/α Εντολή Εξήγηση Λειτουργία 1 CLC Clear Carry Καθαρίζει το κρατούµενο (=0) 2 STC Set Carry Θέτει το κρατούµενο (=1) 3 CMC Complement Carry Αντιστρέφει το κρατούµενο 4 CLD Clear Direction Καθαρίζει τη σηµαία κατεύθυνσης (=0) 5 STD Set Direction Θέτει τη σηµαία κατεύθυνσης (=1) 6 CLΙ Clear Interrupt Καθαρίζει τη σηµαία διακοπών (=0) 7 STΙ Set Interrupt Θέτει τη σηµαία διακοπών (=1) 8 HALT Halt (Σταµάτα) Σταµατά τον επεξεργαστή (στάση) 9 WAIT Wait (Περίµενε) Περιµένει για διαχείριση σφαλµάτων κινητής 10 ESC Escape Χορήγηση διαύλων σε άλλους Μ/Ε 11 LOCK Lock Κλείδωµα ∆ιαύλων 12 NOP No Operation Καµία Ενέργεια
Οι κωδικοί των εντολών Στις επόµενες σελίδες παραθέτονται οι εντολές του 8088 σε συνοπτική µορφή µαζί µε τους κωδικούς των εντολών (opcodes).
Τρόποι Σύνταξης των Εντολών Οι εντολές του 8088 συντάσσονται µε αρκετούς διαφορετικούς τρόπους, και δέχονται διαφορετικές παραµέτρους, αλλά δεν συντάσσονται όλες οι εντολές µε όλους τους τρόπους :
Υπονοούµενος (Implied) : Η σύνταξη της εντολής δεν περιέχει παράµετρο ή συντάσσεται µε συγκεκριµένο τρόπο ο οποίος υπονοεί το ποιες είναι οι παράµετροι.
Παράδειγµα : STC (Set Carry),
Παράµετρος Καταχωρητής (Register Operand) : Η εντολή επενεργεί σε ένα Παράδειγµα : PUSH AX (ΑΧÆStack),
Παράµετρος Θέση Μνήµης (Memory Operand) : Η εντολή επενεργεί σε δεδοµένα που βρίσκονται στην µνήµη και µάλιστα στο τµήµα δεδοµένων (data segment).
Παράδειγµα : POP [0200] (StackÆ DS:0200)
Παράµετρος Σχετική Μετατόπιση (Relative Offset Operand) : Η εντολή µεταφέρει την εκτέλεση (εντολές Jxx, ...) σε διεύθυνση του Code Segment που απέχει κάποια bytes, (+/-), από την αρχή της επόµενης εντολής.
Παράµετρος Αριθµός (Numerical Operand) : Η εντολή δέχεται ως παράµετρο ένα σταθερό νούµερο που έχει θέση δεδοµένου.
Παράδειγµα : ΙΝΤ 3 (Display Registers & Return to MONITOR)
Έµµεση Προσπέλαση (Indirect Addressing) : Η εντολή δέχεται ως παράµετρο µία θέση µνήµης από την οποία διαβάζει κάποια bytes (2 ή 4) τα οποία σχηµατίζουν την τελική διεύθυνση στην οποία θα επενεργήσει η εντολή.
Παράδειγµα : CALL FAR [0500] (θα πάει στην διεύθυνση 0500 και θα διαβάσει από εκεί 4 bytes, 2 για το segment και 2 για το offset, και στην διεύθυνση που σχηµατίζεται ως segment:offset θα γίνει τελικά η κλήση υπορουτίνας)
Συνδυασµοί Σύνταξης των Εντολών Οι παραπάνω τρόποι σύνταξης µπορούν να συνδυαστούν ώστε να µας δώσουν περισσότερους σύνθετους τρόπους σύνταξης των εντολών που είναι :
Καταχωρητής σε Καταχωρητή (Register to Register) : Η εντολή διαβάζει δεδοµένα από ένα καταχωρητή και µετά από επεξεργασία τα αποθηκεύει σε άλλο καταχωρητή.
Καταχωρητής και Μνήµη (Register to/from Memory) : Η εντολή διαβάζει δεδοµένα από ένα καταχωρητή ή τη µνήµη και µετά από επεξεργασία τα σώζει στη µνήµη ή σε
Καταχωρητής και Αριθµός (Register and Numerical Value): Η εντολή παίρνει ένα νούµερο και ένα καταχωρητή και µετά από κάποια επεξεργασία το αποθηκεύει σε ένα Παράδειγµα : TEST DX, FFFF ( DX~FFFF ?)
Μνήµη και Αριθµός (Memory and Numerical Value): Η εντολή επενεργεί πάνω σε ένα νούµερο και µία διεύθυνση µνήµης.
Στις εντολές, που συντάσσονται µε διεύθυνση µνήµης (π.χ.
POP [0200]) η διεύθυνση µνήµης µπορεί να είναι µία σταθερή διεύθυνση ή συνδυασµός διεύθυνσης και καταχωρητών-δεικτών (BX, SI, DI, BP) που προστίθενται στην διεύθυνση µνήµης που δώσαµε, δίνοντας 24 διαφορετικούς τρόπους σύνταξης διευθύνσεων µνήµης :
Οι drivers και ο τρόπος χειρισµού του hardware Εκτός από το πρόγραµµα MONITOR που επιτρέπει την διαχείριση του µηχανήµατος και την συγγραφή και εκτέλεση προγραµµάτων, στην ROM υπάρχουν και οι οδηγοί των συσκευών Εισόδου/Εξόδου του µηχανήµατος (I/O drivers).
Οι οδηγοί αυτοί είναι στην ουσία υπορουτίνες που τις καλούµε µε µία εντολή δακοπής (INT xx) και όχι µε την εντολή CALL που είναι η κατ’εξοχήν εντολή για κλήση υπορουτινών.
Καλώντας αυτές τις υπορουτίνες µπορούµε να πραγµατοποιήσουµε διαδικασίες Εισόδου/Εξόδου µε την αντίστοιχη συσκευή.
Η κάθε υπορουτίνα δέχεται και παραµέτρους που καθορίζουν το ποιά ενέργεια Εισόδου/Εξοδου θα πραγµατοποιήσουν και πώς.
Οι παράµετροι δίνονται ως τιµές σε συγκεκριµένους καταχωρητές πριν από την εκτέλεση της ρουτίνας του οδηγού.
Για παράδειγµα, η εντολή INT 84 εκτελεί την υπορουτίνα του οδηγού για την οθόνη LCD.
Η ρουτίνα αυτή το µόνο που µπορεί να κάνει είναι να εµφανίσει στην οθόνη (στην τρέχουσα θέση του κέρσορα) ένα χαρακτήρα και να προχωρήσει τον κέρσορα στην επόµενη θέση.
Το ποιος χαρακτήρας θα εµφανιστεί καθορίζεται από την τιµή που θα βάλουµε στον καταχωρητή AL πριν την εκτέλεση της εντολής INT 84.
Η τιµή αυτή αντιστοιχεί στον ASCII κωδικό του χαρακτήρα που θέλουµε να εµφανιστεί (π.χ. ‘A’=41, ‘B’=42, …, ‘a’=61,…). εµφανίζει στην οθόνη LCD το γράµµα ‘Α’.
Στο Σχήµα 6 φαίνεται ο τρόπος µε τον οποίο το MONITOR και τα προγράµµατα του χρήστη µπορούν να απευθυνθούν στο hardware. οδηγών συσκευών Εισόδου/Εξόδου (I/O Drivers) Πρέπει εδώ να σηµειωθεί ότι ο χρήστης µπορεί να συντάξει προγράµµατα γλώσσας µηχανής τα οποία θα χρησιµοποιούν το hardware χωρίς την χρήση των οδηγών συσκευών που παρέχονται στην µνήµη ROM.
Αυτό όµως απαιτεί τόσο τη γνώση για το πώς ακριβώς µπορεί να προγραµµατιστεί η κάθε συσκευή Εισόδου / Εξόδου σε χαµηλό επίπεδο, όσο και αρκετό προγραµµατισµό (και debugging) από την πλευρά του χρήστη.
Οι οδηγοί συσκευών που βρίσκονται στην ROM και οι αντίστοιχοι κωδικοί διακοπών είναι οι Οδηγός Σειριακής Θύρας RS-232 ΙΝΤ 80 Μέσω του οδηγού αυτού µπορούµε να κάνουµε τα ακόλουθα :
Να αρχικοποιήσουµε την Σειριακή Θύρα (initialize).
Να µεταδώσουµε δεδοµένα (transmit).
Να λάβουµε δεδοµένα (receive).
Να διαβάσουµε την κατάσταση της σειριακής πόρτας (read status).
Οδηγός Πληκτρολογίου INT 81
Να διαβάσουµε ένα χαρακτήρα από το πληκτρολόγιο (read caracter).
Να διαβάσουµε µία ολόκληρη γραµµή από το πληκτρολόγιο (read command line)
Να διαβάσουµε την κατάσταση του πληκτρολογίου (read status).
Οδηγός Εκτυπωτή (Παράλληλης) INT 82
Να αρχικοποιήσουµε τον εκτυπωτή (initialize).
Να τυπώσουµε δεδοµένα (print data).
Να διαβάσουµε την κατάσταση του εκτυπωτή (read status).
Να προγραµµατίσουµε την θύρα ελέγχου του εκτυπωτή (write control port) Oδηγός Κάρτας Γραφικών Hercules ΙΝΤ 83
Να καθορίσουµε το σχήµα του κέρσορα (set cursor type).
Να εµφανίσουµε έναν χαρακτήρα στην τρέχουσα θέση του κέρσορα (display
Να καθορίσουµε τα χαρακτηριστικά (attribute) ενός χαρακτήρα (set attribute) Οδηγός Οθόνης LCD INT 84 Μέσω του οδηγού αυτού µπορούµε µόνο να εµφανίσουµε έναν οποιοδήποτε χαρακτήρα στην θέση του κέρσορα.
Επιστροφή στο MONITOR INT 85 Με την διακοπή αυτή επανεκκινείται το πρόγραµµα MONITOR.
Μπορούµε να την θέτουµε ως τελευταία εντολή ενός προγράµµατος.
Μηδενίζει τις τιµές των καταχωρητών, γι’ αυτό δεν ενδείκνυται για DEBUGGING ενός προγράµµατος.
H διακοπή αυτή χρησιµοποιείται έξυπνα από το πρόγραµµα MONITOR, κατά την εκτέλεση ενός προγράµµατος, µε καθορισµό διευθύνσεων παύσης (breakpoints).
Μπορεί να χρησιµοποιηθεί ως η τελευταία εντολή ενός προγράµµατος, καθώς µόλις εκτελείται, εµφανίζει τις τιµές των καταχωρητών και επιστρέφει στο MONITOR.
Κεφάλαιο 2: Ιστορία και Εξέλιξη των Υπολογιστών
Επηρεαζόµενες από την επικρατούσα µηχανιστική θεωρία της εποχής, η οποία θεωρούσε τα πάντα ως απλά ή σύνθετα µηχανικά συστήµατα, οι πρώτες υπολογιστικές µηχανές, που κατασκευάστηκαν τον 17ο αιώνα, ήταν καθαρά µηχανικά συστήµατα.
Οι µηχανές αυτές ήταν ένα σηµαντικό βήµα προόδου καθώς µπορούσαν να πραγµατοποιούν, σχετικά γρήγορα, χρονοβόρους υπολογισµούς.
Σαν µηχανικά συστήµατα, όµως, είχαν ανοχές και ατέλειες, ενώ η τεχνολογία της εποχής δεν µπορούσε να κατασκευάσει τα µέρη τους µε την απαιτούµενη Ο πρώτος που κατασκεύασε µια υπολογιστική µηχανή που λειτουργούσε ήταν ο Γάλλος επιστήµονας Blaise Pascal (1623-1662), προς τιµήν του οποίου ονοµάστηκε η γλώσσα προγραµµατισµού Pascal.
Η µηχανή του Pascal χρησιµοποιούσε γρανάζια και τροφοδοτούνταν χειροκίνητα µε µανιβέλα, ενώ µπορούσε να εκτελέσει µόνο αφαίρεση και Μερικά χρόνια αργότερα, ο Γερµανός µαθηµατικός Gottfried Wilhelm von Leibniz (1646-1716) κατασκεύασε µια βελτιωµένη µηχανή που µπορούσε να εκτελεί πρόσθεση, αφαίρεση, πολ/σµό και διαίρεση.
Η Μηχανή ∆ιαφορών του Charles Babbage
Επόµενος σταθµός στους µηχανικούς υπολογιστές ήταν η Μηχανή ∆ιαφορών (Difference Engine) του µαθηµατικού Charles Babbage (1792-1871).
Η µηχανή εκτελούσε µόνο πρόσθεση και αφαίρεση, χρησιµοποιούνταν για τον υπολογισµό πινάκων στην ναυσιπλοΐα και εκτελούσε µόνον έναν αλγόριθµο, τη µέθοδο των πεπερασµένων διαφορών µε χρήση πολυωνύµων.
Σηµαντική ήταν και η ικανότητα της µηχανής να εξάγει τα αποτελέσµατα, αποτυπώνοντας τα σε µια πλάκα χαλκογραφίας.
Στη συνέχεια ο Babbage εξέλιξε µια τελειότερη συσκευή, την Αναλυτική Μηχανή (Analytical Engine).
Η συσκευή αυτή εκτελούσε τις 4 βασικές πράξεις, δέχονταν είσοδο σε µορφή διάτρητων καρτών και έδινε έξοδο σε διάτρητες κάρτες και σε εκτύπωση.
Η µεγάλη καινοτοµία που εισήγαγε η µηχανή αυτή ήταν ότι µπορούσε να χρησιµοποιηθεί για διάφορες χρήσεις, τροφοδοτώντας την µε διαφορετικές κάρτες στην είσοδο.
Ο Babbage κατανόησε ότι, εφ' όσον η Αναλυτική Μηχανή µπορούσε να προγραµµατιστεί σε µια απλή συµβολική γλώσσα, χρειαζόταν να δηµιουργηθεί λογισµικό.
Για το σκοπό αυτό προσέλαβε σαν προγραµµατίστρια την Ada Augusta Lovelace, κόρη του Λόρδου Byron.
Η Ada Lovelace θεωρείται η πρώτη προγραµµατίστρια στον κόσµο και προς τιµήν της ονοµάστηκε η σηµερινή γλώσσα προγραµµατισµού Ada.
Παρά τις προχωρηµένες ιδέες του, ο Babbage ποτέ δεν κατάφερε να αποσφαλµατώσει τελείως το υλικό, προδοµένος από την τεχνολογία της εποχής του, η οποία αδυνατούσε να κατασκευάσει οδοντώσεις, τροχούς και γρανάζια µε τον απαιτούµενο βαθµό ακρίβειας.
Στα τέλη της δεκαετίας του '30, ο Γερµανός µηχανικός Konrad Zuse κατασκεύασε µια σειρά από αυτόµατες υπολογιστικές µηχανές χρησιµοποιώντας ηλεκτρονόµους (ρελέ), οι οποίες όµως καταστράφηκαν στον πόλεµο.
Λίγο αργότερα, στις ΗΠΑ, οι John Atanasoff και George Stibbitz σχεδίασαν αριθµοµηχανές.
Η συσκευή του Atanasoff χρησιµοποιούσε δυαδική αριθµητική και µνήµη από πυκνωτές αλλά δεν µπόρεσε να λειτουργήσει, προδοµένη από την ανεπαρκή τεχνολογία της εποχής.
Η µηχανή του Stibbitz, αν και πιο απλή, λειτούργησε και έγιναν αρκετές δηµόσιες επιδείξεις της.
Ένας άλλος µηχανικός που προσπάθησε να κατασκευάσει υπολογιστή γενικής χρήσης µε ηλεκτρονόµους ήταν ο Howard Aiken.
Το πρώτο του µοντέλο ήταν ο Mark I, ο οποίος χρησιµοποιούσε διάτρητη ταινία για είσοδο και έξοδο και είχε χρόνο εντολής 6 sec.
Ο Aiken κατασκεύασε και ένα πιο βελτιωµένο µοντέλο, τον Mark II αλλά µέχρι τότε οι µηχανικοί υπολογιστές ήταν ήδη ξεπερασµένοι και όλοι είχαν στραφεί στους ηλεκτρονικούς.
Πρώτη Γενιά Υπολογιστών - Λυχνίες Κενού (1945-1955)
Η ανακάλυψη της ηλεκτρονικής λυχνίας κενού από τον Lee de Forest στις αρχές του 20ου αιώνα έδωσε µια τεράστια ώθηση στην εξέλιξη των υπολογιστών, καθώς από µηχανικά ή ηλεκτροµηχανικά συστήµατα οι υπολογιστές έγιναν καθαρά ηλεκτρονικά συστήµατα, επιτυγχάνοντας υψηλές αποδόσεις και µεγαλύτερη αξιοπιστία.
Το βασικό ίσως ερέθισµα για την δηµιουργία του ηλεκτρονικού υπολογιστή ήταν ο Β' Παγκόσµιος Πόλεµος και οι αυξηµένες υπολογιστικές ανάγκες που προέκυψαν.
Το 1943 τέθηκε σε λειτουργία ο πρώτος ηλεκτρονικός υπολογιστής στον κόσµο ο COLOSSUS.
Σχεδιάστηκε από τον µαθηµατικό Alan Turing, ανήκε στην Βρετανική Κυβέρνηση και χρησιµοποιήθηκε µε επιτυχία για την αποκρυπτογράφηση µηνυµάτων των Γερµανών που είχαν κρυπτογραφηθεί µε την συσκευή ENIGMA.
Ελάχιστα στοιχεία έγιναν γνωστά για τον υπολογιστή αυτό λόγω του στρατιωτικού απορρήτου που ίσχυε γι' αυτόν.
Στις Η.Π.Α. υπήρχε η ανάγκη δηµιουργίας πινάκων βολών για το πυροβολικό, διαδικασία χρονοβόρα που απαιτούσε πολλά άτοµα ενώ τα λάθη ήταν συχνά.
Μετά από έγκριση του Στρατού ο John Mauchley, µε τον J.
Presper Eckert, ξεκίνησαν το 1943 την κατασκευή ενός ηλεκτρονικού υπολογιστή για τον υπολογισµό των πινάκων αυτών.
Το αποτέλεσµα ήταν ο ENIAC (Electronic Numerical Integrator and Computer), µια µηχανή βάρους 30 τόνων και ισχύος 140 KW, µε 18.000 λυχνίες και 1.500 ηλεκτρονόµους.
Ο προγραµµατισµός γινόταν µε τη ρύθµιση 6.000 διακοπτών και ενός πλήθους καλωδίων.
Ο ENIAC ολοκληρώθηκε το 1946, πολύ αργά για να επιτελέσει το σκοπό για τον οποίο κατασκευάστηκε.
Ωστόσο, επιδείχθηκε σε πολλούς ερευνητές και µηχανικούς και έδωσε το έναυσµα για την κατασκευή και άλλων παρόµοιων υπολογιστών.
Στα βήµατα του ENIAC, ακολούθησαν οι EDSAC (1949), JOHNIAC, ILLIAC, MANIAC και WEIZAC.
Οι δηµιουργοί του ENIAC Eckert και Mauchley άρχισαν την κατασκευή του EDVAC (Electronic Discrete Variable Automatic Computer), αλλά η κατασκευή διακόπηκε και οι δύο κατασκευαστές ίδρυσαν µια εταιρία η οποία εξελίχθηκε στην σηµερινή Unisys Ενας από τους κατασκευαστές του ENIAC, ο John von Neumann, ένας ιδιοφυής µηχανικός, ξεκίνησε την κατασκευή της δικής του εκδοχής του EDVAC, της µηχανής IAS.
Ο von Neumann διαπίστωσε ότι ο προγραµµατισµός των υπολογιστών µε έναν τεράστιο αριθµό διακοπτών και καλωδίων ήταν αργός, κοπιαστικός και άκαµπτος και κατέληξε στο συµπέρασµα ότι τα προγράµµατα µπορούσαν να παρασταθούν σε δυαδική µορφή στη µνήµη του υπολογιστή, µαζί µε τα δεδοµένα.
Ο βασικός σχεδιασµός που ο ίδιος παρουσίασε είναι γνωστός σήµερα ως Μηχανή von Neumann, πρωτοχρησιµοποιήθηκε στον EDSAC και στον IAS και εξακολουθεί να είναι η βάση όλων σχεδόν των ψηφιακών υπολογιστών, µέχρι και
Ο John Von Neumann
Την ίδια εποχή που κατασκευάζονταν οι IAS, ENIAC και οι άλλες µηχανές αυτού του τύπου, που προορίζονταν για αριθµητικούς υπολογισµούς, στο M.I.T. κατασκευάστηκε ο Whirlwind I, ο οποίος ήταν σχεδιασµένος για έλεγχο πραγµατικού χρόνου, και οδήγησε στην εφεύρεση της µνήµης µαγνητικών πυρήνων και τελικά στον πρώτο εµπορικό mini To 1952, o UNIVAC I, ο πρώτος εµπορικός υπολογιστής της Remington Rand που παρουσιάστηκε το 1951 και σχεδιάστηκε από τους Mauchley και Eckert, χρησιµοποιείται από το τηλεοπτικό δίκτυο CBS για να προβλέψει τον νικητή των εκλογών της χρονιάς Η IBM κατασκεύασε τον πρώτο υπολογιστή της µε λυχνίες, τον IBM 701, το 1953.
To 1956 κατασκεύασε τον IBM 704 και το 1958 τον IBM 709, που ήταν ο τελευταίος υπολογιστής
Το τρανζίστορ εφευρέθηκε στα εργαστήρια Bell Labs το 1948 από τους J.
Brattain και W.
Shockley, στους οποίους απονεµήθηκε το βραβείο Nobel Φυσικής το 1956 για την εφεύρεσή τους αυτή.
Το τρανζίστορ έφερε επανάσταση στους υπολογιστές και µέχρι το τέλος της δεκαετίας του '50 οι υπολογιστές µε λυχνίες είχαν καταργηθεί.
Ο πρώτος υπολογιστής µε τρανζίστορ κατασκευάστηκε στο Μ.Ι.Τ. και ακολουθούσε τη φιλοσοφία του Whirlwind.
Ονοµάστηκε TX-0 και προορίζονταν για τη δοκιµή του TX-2, ο οποίος όµως δεν απέδωσε τα αναµενόµενα.
Ενας από τους µηχανικούς που δούλεψαν στους TX, ο Kenneth Olsen, δηµιούργησε το 1957 την Digital Equipment Corporation (DEC) µε σκοπό την κατασκευή ενός εµπορικού υπολογιστή.
Σε 4 χρόνια ο PDP-1 ήταν γεγονός.
Είχε 4K λέξεις των 18 bit και χρόνο κύκλου 5 µsec.
Είχε τη µισή απόδοση του IBM 7090, διαδόχου µε τρανζίστορ του 709 και ταχύτερου υπολογιστή στον κόσµο την εποχή εκείνη, αλλά κόστιζε ένα κλάσµα της αξίας του ΙΒΜ.
Πουλήθηκαν µερικές δεκάδες PDP-1 και έτσι γεννήθηκε η βιοµηχανία των mini υπολογιστών.
Μερικά χρόνια αργότερα παρουσιάστηκε ο PDP-8 ο οποίος ήταν υπολογιστής των 12 bit αλλά πολύ φθηνότερος του PDP-1.
Σηµαντική καινοτοµία ήταν η χρήση ενός µόνο διαύλου, του Omnibus, για την σύνδεση όλων των κυκλωµάτων.
Πουλήθηκαν µερικές χιλιάδες PDP-8 και η DEC κατέκτησε την πρωτοκαθεδρία στο χώρο των mini υπολογιστών.
Ο mini Ηλεκτρονικός Υπολογιστής DEC PDP-1
Η IBM κατασκεύασε σαν απάντηση τους 7090 και 7094.
Οι δύο αυτοί υπολογιστές ήταν οι τελευταίοι τύπου ENIAC που κατασκευάστηκαν και κυριάρχησαν στο χώρο των επιστηµονικών υπολογιστών την δεκαετία του '60.
Παράλληλα, η IBM κατασκεύασε µια µικρή µηχανή, τον 1401, ο οποίος µπορούσε να γράφει και να διαβάζει σε µαγνητικές ταινίες, να διαβάζει και να τρυπά κάρτες και να δίνει εκτυπώσεις σαν έξοδο.
Ηταν απαράδεκτος για επιστηµονικούς σκοπούς αλλά πολύ καλός για τήρηση αρχείων µιας επιχείρησης και γνώρισε επιτυχία στο χώρο αυτό.
Το 1964 µια νέα εταιρία, η Control Data Corporation (CDC) παρουσίασε τον CDC-6600, µια µηχανή µία τάξη µεγέθους ταχύτερη από τον IBM 7094.
Χρησιµοποιούσε παραλληλία και άλλες προχωρηµένες τεχνικές για την εποχή του για να επιτύχει αυτή την υψηλή απόδοση.
Σχεδιαστής του 6600 ήταν ο ιδιοφυής Seymour Cray, ο οποίος αφιέρωσε τη ζωή του στην κατασκευή όλο και πιο γρήγορων υπολογιστών που σήµερα λέγονται υπερυπολογιστές (supercomputers) όπως ο 6600, ο 7600 και ο Cray-1.
Ο Ηλεκτρονικός Υπολογιστής CDC-6000
Υπήρξαν και άλλοι πολλοί υπολογιστές την εποχή εκείνη αλλά ένας ξεχωρίζει για εντελώς διαφορετικό λόγο και αξίζει να αναφερθεί, ο Burroughs B5000.
Οι σχεδιαστές υπολογιστών ήταν ολοκληρωτικά απασχοληµένοι µε το υλικό ώστε να παράγουν υπολογιστές ταχύτερους ή φθηνότερους, αδιαφορώντας για το λογισµικό.
Οι σχεδιαστές του B5000 ακολούθησαν διαφορετική τακτική.
Κατασκεύασαν µια µηχανή ειδικά για προγραµµατισµό σε Algol 60, έναν πρόδροµο της Pascal, και περιέλαβαν πολλές δυνατότητες στο υλικό για να διευκολύνουν τη δουλειά του µεταγλωττιστή.
Έτσι, γεννήθηκε η ιδέα ότι και το λογισµικό
Τρίτη Γενιά - Ολοκληρωµένα Κυκλώµατα (1965-1980)
Η εφεύρεση του ολοκληρωµένου κυκλώµατος πυριτίου από τον Robert Noyce το 1958 επέτρεψε να τοποθετηθούν δεκάδες τρανζίστορ σε ένα µόνο chip.
Ετσι έγινε δυνατή η κατασκευή υπολογιστών µικρότερων, γρηγορότερων και φθηνότερων από τους υπολογιστές µε τρανζίστορ της προηγούµενης γενιάς.
Μερικοί από τους σηµαντικότερους υπολογιστές αυτής της γενιάς περιγράφονται πιο κάτω.
Το 1964 η IBM ήταν ήδη κυρίαρχη στην αγορά των υπολογιστών, όµως είχε ένα µεγάλο πρόβληµα µε τις δύο πιο επιτυχηµένες µηχανές της, τον 7094 και τον 1401, ήταν τελείως ασύµβατοι µεταξύ τους.
Πολλές εταιρίες είχαν και τους 2 υπολογιστές και δυσανασχετούσαν καθώς έπρεπε να διατηρούν δύο ξεχωριστά τµήµατα προγραµµατισµού.
Ετσι, ο αντικαταστάτης των δύο αυτών υπολογιστών, ο System/360, έκανε ένα ριζοσπαστικό βήµα.
Αποτελούσε µια οικογένεια από 5-6 υπολογιστές, µε διαφορετικές αποδόσεις και τιµή, οι οποίοι όµως µπορούσαν να τρέχουν τα ίδια προγράµµατα.
Το Model 30 προορίζονταν να αντικαταστήσει τους 1401, το Model 75 τους 7094 ενώ µεταξύ τους υπήρχαν τα µοντέλα Model 40, Model 50 και Model 65, µε κλιµακούµενη απόδοση και τιµή.
Ο Ηλεκτρονικός Υπολογιστής IBM System/360
Η ιδέα της οικογένειας υπολογιστών ήταν επιτυχηµένη και σύντοµα ακολουθήθηκε και από τους άλλους κατασκευαστές.
Άλλη µια καινοτοµία του System/360 ήταν ο πολυπρογραµµατισµός (multiprogramming), δηλαδή η ταυτόχρονη φόρτωση και εκτέλεση πολλών προγραµµάτων.
Επίσης, οι υπολογιστές της σειράς είχαν την ικανότητα να εξοµοιώνουν τους 1401 και 7094, ώστε να µπορούν να εκτελούνται και παλαιότερα προγράµµατα για τους υπολογιστές αυτούς.
Τέλος ο χώρος διευθύνσεων ήταν τεράστιος για την εποχή του, φθάνοντας τα 16 MB.
Την σειρά 360 διαδέχθηκαν οι σειρές 370, 4300, 3080 Στο χώρο των mini υπολογιστών, η DEC κυκλοφόρησε τον PDP-11, ακολουθώντας τη φιλοσοφία του 360.
Ο PDP-11 ήταν εξαιρετικά επιτυχηµένος, ιδίως στα Πανεπιστήµια, και διατήρησε την πρωτοκαθεδρία της DEC στους mini υπολογιστές.
Τέταρη Γενιά-Ολοκλήρωση µεγάλης κλίµακας (1980-σήµερα) ¾ Τεχνολογία LSI και VLSI, χιλιάδες και εκατοµµύρια τρανζίστορ σε ένα chip.
Pentium 4, 55 εκατοµµύρια τρανζίστορ.
Αυγή των προσωπικών υπολογιστών (PC – Personal ¾ Εµφάνιση του Intel 8080.
Πρώτοι Η/Υ σε κίτ, χωρίς λειτουργικό.
Λειτουργικό CP/M ¾ Αλλες CPU, Ζ80 Zilog (1976), 6502 MOS Tech Corp. (1976). ¾ Steve Jobs και Steve Wozniak, Apple Computers, Apple και Apple II µε επεξεργαστή ¾ IBM PC (1981) µε 8088 και 16 Kb RAM και δισκέτα.
Ανοικτή αρχιτεκτονική, επέκταση µε κάρτες.
Αντιγραφή σε PC-compatibles.
Microsoft MS-DOS. 464 (Z80), Atari (6502) µε ενσωµατωµένη BASIC. ¾ Ανάπτυξη επεξεργαστών 8086, 80286, 80386, 80486, Pentium, Pentium Pro, Pentium ¾ Ανάπτυξη επεξεργαστών RISC για Σταθµούς Εργασίας, HP, SUN.
Στη δεκαετία του '80, η τεχνολογία VLSI (Very Large Scale Integration) επέτρεψε να τοποθετηθούν αρχικά δεκάδες και εκατοντάδες χιλιάδες και αργότερα εκατοµµύρια τρανζίστορ σε ένα µόνο chip.
Η εξέλιξη αυτή οδήγησε σε µικρότερους και σε φθηνότερους υπολογιστές και τελικά στους προσωπικούς υπολογιστές (PC, Personal Computer).
Οι προσωπικοί υπολογιστές χρησιµοποιούνται µε πολύ διαφορετικό τρόπο από τους µεγάλους υπολογιστές.
Χρησιµεύουν για επεξεργασία κειµένου, για λογιστικά φύλλα και για πολλές έντονα αλληλεπιδραστικές εφαρµογές, τις οποίες οι µεγαλύτεροι υπολογιστές δεν µπορούν Οι πρώτοι προσωπικοί υπολογιστές είχαν συνήθως µορφή kit.
Το kit περιελάµβανε ένα τυπωµένο κύκλωµα, έναν µικροεπεξεργαστή Intel 8080, συνήθως, και µερικά ακόµη chip, µερικά καλώδια, ένα τροφοδοτικό και ίσως µια µονάδα δισκέτας.
Η συναρµολόγηση του υπολογιστή γίνονταν από τον αγοραστή και επίσης το λογισµικό γράφονταν από αυτόν.
Αργότερα, το λειτουργικό σύστηµα CP/M, που γράφτηκε από τον Gary Kildall, έγινε δηµοφιλές στους υπολογιστές µε 8080.
Σταδιακά οι προσωπικοί υπολογιστές άρχισαν να πωλούνται συναρµολογηµένοι.
Ενας από τους πρώτους ήταν ο Apple, και αργότερα ο Apple II, των Steve Jobs και Steve Wozniak ο οποίος είχε τον µικροεπεξεργαστή 6502 και γνώρισε µεγάλη επιτυχία.
Ο Προσωπικός Ηλεκτρονικός Υπολογιστής APPLE II (1977)
Η IBM µπήκε στο χώρο των PC σχετικά αργά, στις αρχές του '80.
Ακολουθώντας µια τακτική η οποία επηρέασε βαθύτατα την εξέλιξη των PC στις επόµενες δεκαετίες, η IBM κατασκεύασε τον IBM PC τo 1981 χρησιµοποιώντας υλικά του εµπορίου και δηµοσιεύοντας ελεύθερα τα σχέδια του υπολογιστή.
Η κίνηση αυτή έγινε από την IBM µε σκοπό να µπορέσουν τρίτοι κατασκευαστές να παράγουν κάρτες επέκτασης για τον IBM PC αλλά τελικά πολλές εταιρίες αντέγραψαν ολόκληρο τον υπολογιστή, δηµιουργώντας κλώνους (clones) του IBM PC (ή IBM-συµβατά, IBM-compatibles) και ξεκινώντας µια ολόκληρη βιοµηχανία προσωπικών υπολογιστών η οποία κυριάρχησε τελικά στο χώρο αυτό.
Ο προσωπικός ηλεκτρονικός υπολογιστής IBM-PC (1981)
Τη δεκαετία του '80 παρουσιάστηκαν και άλλα PC µε CPU που δεν ήταν της Intel.
Ετσι, για κάποιο διάστηµα κυριάρχησαν στην αγορά οι υπολογιστές της Sinclair, της Amstrad, της Atari, της Commodore κ.α.
Οι υπολογιστές αυτοί βασίζονταν σε µικροεπεξεγασές όπως ο Ζ80 της Zilog (1976), ο 6502 της MOS Tech Corp. (1976) και ο 68000 της Motorolla, και ονοµάστηκαν Home Computers.
Στην κατηγορία αυτή αξίζει να αναφέρουµε τον Sinclair Spectrum (Z80), τον Commodore 64 (6502), τον Amstrad CPC-464 (Z80) και CPC-6128 (Ζ80) µε τη πρώτη µονάδα δισκέτας (για Home Computer) µε µέγεθος 200 ΚΒ και εγγραφή και στις δύο όψεις της δισκέτας µε drive µονής κεφαλής που απαιτούσε αλλαγή πλευράς !.
Επίσης µπορούµε να αναφέρουµε τον Atari (6502) µε ενσωµατωµένη BASIC, τον BBC και Electron (6502) τον Oric Atmos αλλά και την Amiga που ήταν υπολογιστής ορόσηµο για τα
Όµως µέχρι το τέλος της δεκαετίας του ΄80 η επικράτηση των IBM-συµβατών PC έναντι των Home Computers ήταν ολοκληρωτική καθώς οι πρώτοι είχαν επαγγελµατικές προδιαγραφές και δυνατότητες και ανοιχτή αρχιτεκτονική, ενώ οι τιµές τους έπεφταν διαρκώς.
Η πρώτη έκδοση του IBM PC ήταν εξοπλισµένη µε το λειτουργικό σύστηµα MS- DOS που προερχόταν από την µικρή, τότε, Microsoft Corporation.
Η Microsoft µαζί µε την IBM κατασκεύασαν ένα λειτουργικό σύστηµα που εκµεταλλεύονταν τις δυνατότητες των νέων CPU της Intel, το OS/2.
Το OS/2 απέτυχε εµπορικά και κυριάρχησε ένα άλλο λειτουργικό που ετοίµαζε η Microsoft παράλληλα µε το OS/2, τα Windows.
Το πώς τελικά δυο µικρές τότε εταιρίες, η Intel και η Microsoft, κατόρθωσαν να εκθρονίσουν την IBM, µια εταιρία µε τεράστια ισχύ και πόρους, αποτελεί Case-study που διδάσκεται στις οικονοµικές σχολές σε όλο τον κόσµο.
Στα µέσα της δεκαετίας του '80 κάνει την εµφάνισή της µια νέα αρχιτεκτονική, η RISC, η οποία υλοποιούσε CPU µε µικρό και απλό σύνολο εντολών, µε σκοπό την αύξηση της απόδοσης.
Άλλη µια εξέλιξη προς την κατεύθυνση αυτή ήταν και η ανάπτυξη των Υπερβαθµωτών (superscalar) CPU τη δεκαετία του '90.
Εξέλιξη και Κατηγορίες Υπολογιστών
Η βιοµηχανία των υπολογιστών εξελίσσεται µε ταχείς ρυθµούς.
Η βασική κινητήρια δύναµη είναι η ικανότητα των κατασκευαστών chip να ενσωµατώνουν σε ένα chip όλο και περισσότερα τρανζίστορ, γεγονός που οδηγεί σε µεγαλύτερες µνήµες και ισχυρότερους
Η επιβεβαίωση του νόµου του Moore από το 1970 έως το 1998
Ο ρυθµός της τεχνολογικής προόδου µπορεί να συνοψιστεί σε µια εµπειρική παρατήρηση που λέγεται Νόµος του Moore.
Ο νόµος αυτός πήρε το όνοµα του από τον Gordon Moore, συνιδρυτή της Intel και προβλέπει ότι ο αριθµός των τρανζίστορ που µπορούν να ενσωµατωθούν σε ένα chip (και συνεπώς και η υπολογιστική ισχύς) διπλασιάζεται κάθε 18 µήνες, γεγονός που σηµαίνει ετήσια αύξηση περίπου 60%.
Στην Εικ.
φαίνεται η επαλήθευση του Νόµου του Moore για chip CPU.
Ο Νόµος αυτός αναµένεται να ισχύει για αρκετά χρόνια ακόµη και το τέλος της συνεχούς αυτής εξέλιξης φαίνεται να είναι οι Κβαντικοί υπολογιστές, όπου θα µπορεί να αποθηκεύεται 1 bit πληροφορίας στο spin Εκτός από τους κβαντικούς υπολογιστές, άλλοι εναλλακτικοί υπολογιστές πάνω στους οποίους γίνεται έρευνα είναι οι Φωτονικοί Υπολογιστές (Photonics), οι οποίοι χρησιµοποιούν οπτικούς κρυστάλλους και φως αντί για τρανζίστορ και ρεύµα, και οι Βιολογικοί υπολογιστές, οι οποίοι θα αποτελούνται από οργανικά µέρη.
Οι τεχνολογίες αυτές αναµένεται να ξεπεράσουν τους περιορισµούς που ισχύουν για τη σηµερινή µορφή των υπολογιστών αλλά απέχουν πολλά χρόνια ακόµη από την µαζική τους παραγωγή.
Τελειώνοντας, θα αναφέρουµε το σηµερινό φάσµα των διαθέσιµων υπολογιστών
Κατηγορίες Υπολογιστών και κλίµακα κόστους Τύπος Τιµή σε $ Παράδειγµα εφαρµογής Αναλώσιµος Υπολογιστής 1 Ευχετήριες µουσικές κάρτες Ενσωµατωµένος Υπολογιστής 10 Ρολόγια, αυτοκίνητα, οικιακές συσκευές Υπολογιστής παιχνιδιών 100 Οικιακά video games Προσωπικός Υπολογιστής 1.000 Επιτραπέζιοι ή φορητοί υπολογιστές ∆ιακοµιστής (Server) 10.000 Σταθµός εργασίας ή διακοµιστής δικτύου Συστοιχία σταθµών εργασίας 100.000 Mini υπολογιστής τµήµατος 1.000.000 Κεντρικός υπολογιστής τράπεζας Υπερυπολογιστής 10.000.000 Επιστηµονικές εφαρµογές Στο κατώτερο σηµείο του φάσµατος υπάρχουν µεµονωµένα chip τα οποία βρίσκονται στο εσωτερικό ευχετήριων καρτών, έξυπνων καρτών κ.α.
Η αξία τους είναι ελάχιστη και γι' αυτό Στο επόµενο επίπεδο έχουµε τους υπολογιστές που είναι ενσωµατωµένοι σε διάφορες καταναλωτικές ηλεκτρονικές συσκευές (Embedded computers) όπως τηλέφωνα, τηλεοράσεις, παιγνίδια, συσκευές CD κ.α.
Οι υπολογιστές αυτοί περιέχουν έναν µικροεπεξεργαστή, λιγότερο από 1 MB µνήµης και ελάχιστες δυνατότητες εισόδου/εξόδου.
Ένα σκαλοπάτι πιο πάνω βρίσκονται οι µηχανές για video games.
Πρόκειται για κανονικούς υπολογιστές µε ειδικές δυνατότητες γραφικών αλλά µε περιορισµένο λογισµικό και µηδενική σχεδόν επεκτασιµότητα.
Στην ίδια κατηγορία βρίσκονται οι ηλεκτρονικές ατζέντες, οι φορητοί ψηφιακοί βοηθοί (personal digital assistants, PDA) και τα τερµατικά για το Web.
Περιέχουν έναν µικροεπεξεργαστή, µερικά MB µνήµης και κάποιο είδος οθόνης.
Οι προσωπικοί υπολογιστές, στο επόµενο επίπεδο, έχουν ουσιαστικά ταυτιστεί µε τη λέξη 'υπολογιστής'.
Περιέχουν µικροεπεξεργαστή, πολλά MB µνήµης, σκληρό δίσκο πολλών GB, διάφορες περιφερειακές συσκευές, προηγµένο λειτουργικό σύστηµα, πολλές δυνατότητες επέκτασης και διαθέτουν µεγάλο φάσµα διαθέσιµου λογισµικού.
Οι CPU της Intel µε τα λειτουργικά συστήµατα της Microsoft κυριαρχούν στο χώρο αυτό.
Οι διακοµιστές δικτύου, είτε για τοπικά δίκτυα είτε για το Internet, είναι ενισχυµένοι προσωπικοί υπολογιστές, µε έναν ή περισσότερες CPU, µνήµη µέχρι GB, συστοιχίες δίσκων πολλών GB και δικτυακές δυνατότητες υψηλής ταχύτητας.
Η Συστοιχία σταθµών εργασίας (Cluster of Workstations, COW) αποτελείται από προσωπικούς υπολογιστές συνδεδεµένους µεταξύ τους σε γρήγορο δίκτυο, οι οποίοι εκτελούν ειδικό λογισµικό που επιτρέπει σε όλες τις µηχανές να συνεργάζονται για να επιλύσουν ένα πρόβληµα, επιστηµονικό ή τεχνικό.
Κλιµακώνονται εύκολα και µπορεί να περιλαµβάνουν από λίγους σταθµούς εργασίας µέχρι µερικές χιλιάδες.
Η συστοιχία έχει την απόδοση ενός mini υπερυπολογιστή.
Τα mainframes, µε µέγεθος δωµατίου, είναι συνήθως απόγονοι του ΙΒΜ 360.
Οι περισσότεροι δεν είναι πιο γρήγοροι από τους πιο γρήγορους διακοµιστές, αλλά έχουν αυξηµένες δυνατότητες εισόδου/εξόδου και είναι εξοπλισµένοι µε συστοιχίες δίσκων που περιέχουν ακόµη και ΤΒ (=1012 byte) πληροφοριών.
Είναι εξαιρετικά δαπανηροί και σε πολλές περιπτώσεις χρησιµοποιούνται κυρίως εξαιτίας της µεγάλης επένδυσης σε λογισµικό, δεδοµένα, διαδικασίες λειτουργίας και προσωπικό που αντιπροσωπεύουν.
Στο ανώτερο επίπεδο βρίσκονται οι υπερυπολογιστές (supercomputers), οι οποίοι έχουν ταχύτατες CPU, πολλά GB κύριας µνήµης και πολύ γρήγορους δίσκους και δίκτυα.
Χρησιµοποιούνται για την επίλυση σύνθετων επιστηµονικών προβληµάτων όπως η προσοµοίωση συγκρουόµενων γαλαξιών, η σύνθεση νέων φαρµάκων, η πρόγνωση του
Ο Υπερ-υπολογιστής Cray-1 (1976)
Κεφάλαιο 3.
Βασικά και σύνθετα ψηφιακά κυκλώµατα
Τα βασικά στοιχεία από τα οποία αποτελούνται οι υπολογιστές είναι αρκετά απλά.
Τα περισσότερα κυκλώµατα δηµιουργούνται από κατάλληλους συνδυασµούς πυλών (gates), οι οποίες είναι η βάση υλικού πάνω στην οποία οικοδοµούνται όλοι οι ψηφιακοί υπολογιστές.
Οι συνδυασµοί των πυλών δηµιουργούν σύνθετα κυκλώµατα που µπορούν να εκτελούν αριθµητικές και λογικές πράξεις, συνδυαστικές πράξεις κ.α.
Για την ανάλυση των κυκλωµάτων αυτών χρησιµοποιείται η δίτιµη Άλγεβρα Boole.
Υλοποίηση πυλών µε τρανζίστορ a) πύλη NOT, b) πύλη NAND, c) πύλη NOR
Σε ένα ψηφιακό κύκλωµα υπάρχουν µόνο 2 λογικές τιµές.
Συνήθως ένα σήµα µεταξύ 0 και 1 Volt αντιπροσωπεύει τη µία τιµή (π.χ. το λογικό 0) και ένα σήµα µεταξύ 2 και 5 Volt αντιπροσωπεύει την άλλη τιµή (π.χ. το λογικό 1).
Τιµές έξω από τις περιοχές αυτές δεν επιτρέπονται.
Οι πύλες είναι µικροσκοπικές ηλεκτρονικές συσκευές που µπορούν να υπολογίζουν διάφορες συναρτήσεις αυτών των δίτιµων σηµάτων.
Το βασικό ηλεκτρονικό εξάρτηµα των πυλών είναι τα τρανζίστορ.
Στην παραπάνω εικόνα φαίνεται ο τρόπος υλοποίησης των πυλών NOT, NAND, NOR.
Στην υλοποίηση της πύλης NOT, που υλοποιείται µε ένα µόνο τρανζίστορ (περίπτωση (a) του σχήµατος), παρατηρούµε ότι :
Η είσοδος στην πύλη οδηγείται στη βάση του τρανζίστορ (base),
Η έξοδος της πύλης λαµβάνεται από το συλλέκτη (collector), ο οποίος είναι συνδεδεµένος στην τάση τροφοδοσίας (πολωµένος) µέσω µιας αντίστασης, ενώ
Ο εκποµπός (emitter) της πύλης είναι γειωµένος.
Σύµφωνα µε τη λειτουργία του τρανζίστορ όταν εφαρµόζουµε τάση στην βάση του τότε η γραµµή εκποµπού - συλλέκτη «άγει», δηλαδή έχει µεγάλη αγωγιµότητα και παρουσιάζει εξαιρετικά µικρή αντίσταση.
Αντίθετα όταν δεν υπάρχει τάση στην βάση του τρανζίστορ, τότε η γραµµή εκποµπού - συλλέκτη παρουσιάζει µεγάλη αντίσταση και πρακτικά θεωρείται Σύµφωνα λοιπόν µε τα παραπάνω όταν στην είσοδο της πύλης εφαρµόζεται λογικό 0, δηλαδή «όχι τάση», τότε η γραµµή εκποµπού - συλλέκτη είναι ανοιχτό κύκλωµα, και εποµένως ο συλλέκτης ταυτίζεται µε την τάση τροφοδοσίας, οπότε στην έξοδο της πύλης εµφανίζονται τα 5 Volt της τροφοδοσίας.
Αντίθετα, όταν στην είσοδο της πύλης εφαρµόζεται το λογικό 1, δηλαδή 5 Volt τότε η γραµµή εκποµπού - συλλέκτη άγει και αποτελεί σχεδόν βραχυκύκλωµα, οπότε η τάση εξόδου Vout συνδέεται µε την γη και εποµένως είναι σε δυναµικό 0 Volt.
Άρα η πύλη βγάζει στην έξοδό της το λογικό 0.
Εποµένως η πύλη αυτή µε είσοδο 0 βγάζει έξοδο 1, και µε είσοδο 1 βγάζει έξοδο 0, δηλαδή λειτουργεί σωστά ως µία πύλη NOT.
Στην υλοποίηση της πύλης NAND ( σχήµα (b) ), έχουµε δύο τρανζίστορ που είναι συνδεδεµένα έτσι ώστε οι γραµµές εκποµπού - συλλέκτη να είναι σε σειρά.
Έτσι λοιπόν αν µια από τις εισόδους V1 ή V2 είναι στα 0 volt, τότε ένα από τα δύο τρανζίστορ δεν θα άγει (θα είναι ανοικτό κύκλωµα), και εποµένως η έξοδος της πύλης θα ταυτίζεται µε την τάση τροφοδοσίας οπότε θα είναι στο λογικό 1.
Αν τώρα και οι δύο είσοδοι είναι στο λογικό 1, τότε και τα δύο τρανζίστορ θα άγουν, και εποµένως η έξοδος της πύλης θα είναι γειωµένη και άρα στο λογικό 0.
Έτσι επαληθεύεται ο πίνακας αλήθειας της πύλης NAND.
Στην υλοποίηση της πύλης NOR ( σχήµα (c) ), έχουµε δύο τρανζίστορ που είναι συνδεδεµένα έτσι ώστε οι γραµµές εκποµπού - συλλέκτη να είναι παράλληλα.
Έτσι λοιπόν αν µια από τις εισόδους V1 ή V2 είναι στο λογικό 1 (5 volt), τότε υπάρχει σύνδεση της εξόδου µε την γη και εποµένως η έξοδος της πύλης είναι στο λογικό 0.
Αν τώρα και οι δύο είσοδοι είναι στο λογικό 0 (0 volt), τότε κανένα από τα δύο τρανζίστορ δεν άγει, και εποµένως η έξοδος της πύλης θα ταυτίζεται µε την Vcc (5 volt) και άρα θα είναι στο λογικό
Έτσι επαληθεύεται ο πίνακας αλήθειας της πύλης NOR.
Επίσης, στην επόµενη εικόνα φαίνονται τα σύµβολα και οι Πίνακες Αληθείας των 5 βασικών πυλών NOT, NAND, NOR, AND και OR.
Σύµβολα και πίνακες αληθείας για 5 βασικές πύλες
Αν και οι πύλες NAND και NOR προκύπτουν µε συνδυασµό των απλών πυλών NOT, AND και OR, πολλοί σχεδιαστές προτιµούν να χρησιµοποιούν αυτές τις πύλες στο σχεδιασµό κυκλωµάτων διότι οι NAND και NOR υλοποιούνται µε 2 τρανζίστορ έναντι 3 των απλών πυλών.
Με βάση δε την Αρχή της Ισοδυναµίας Κυκλωµάτων, και οι πύλες NOT, AND, OR µπορούν να κατασκευαστούν µε συνδυασµό των NAND και NOR, όπως φαίνεται στην
Υλοποίηση πυλών a) NOT, b) AND, c) OR, µόνο µε πύλες NAND ή NOR Σε επίπεδο ολοκληρωµένων κυκλωµάτων χρησιµοποιούνται οι ακόλουθες τεχνολογίες κατασκευής πυλών : ∆ιπολική Τεχνολογία.
Υπάρχουν οι ακόλουθοι τύποι διπολικών πυλών : TTL (Transistor-Transistor Logic).
Ο βασικός τύπος πυλών που λειτουργούν στα 5 Volt και έχουν χρόνο απόκρισης t=10nsec (10x10-9 sec), που σηµαίνει ότι µπορούν να λειτουργήσουν σε συχνότητες χρονισµού έως και f = 1 / t = 1/(10x10-9) = 1 / 10-8 = IIL (Integrated Injection Logic) Λειτουργούν µε µικρή τάση (~0.8 V) αλλά έχουν χρόνο απόκρισης µεγαλύτερο από αυτόν της κατηγορίας TTL.
Ο χρόνος απόκρισής τους είναι της τάξης των 20-50 nsec.
Εποµένως µπορούν να λειτουργήσουν σε συχνότητες χρονισµού στην περιοχή 20-50 MHz.
Χρησιµοποιείται για κυκλώµατα υψηλής ταχύτητας.
Έχουν χρόνο απόκρισης της τάξης των 0.3 – 2 nsec οπότε µπορούν να χρονιστούν σε Τεχνολογία MOS (Metal Oxide Semiconductor).
Υλοποιούνται µε τρανζίστορ FET (Field Efect Transistor).
Οι πύλες MOS είναι πολύ πιο αργές από τις διπολικές (10-100 φορές) αλλά απαιτούν ελάχιστη ισχύ και καταλαµβάνουν ελάχιστο χώρο.
Οι πύλες αυτές εµφανίζονται σε πολλές παραλλαγές όπως PMOS, NMOS, HMOS και CMOS.
Ο Μ/Ε Intel 8088 είναι τεχνολογίας HMOS.
Για πολλά χρόνια το όριο µεγέθους των τρανζίστορ στα ολοκληρωµένα κυκλώµατα µεγάλης κλίµακας ολοκλήρωσης (VLSI), ήταν στα 0,6 µ (micron) ή 600 nm (nanometers).
Όµως 3 µεγάλες κατασκευάστριες εταιρείες, η Intel, η AMD και η Motorolla ένωσαν τις δυνάµεις τους και το ΧΧΧΧΧΧΧΧΧΧ εφηύραν την λιθογραφική µέθοδο ακτίνων Χ που ξεπέρασε το αρχικό όριο και έφτασε άνετα στα 0,09 µ (micron) ή 90 nm (nanometers).
Η τεχνολογία αυτή σήµερα έχει φτάσει µέχρι και στο όριο των 45 nm όπως στους Μικροεπεξεργαστές Pentium 4 Για τις συνδέσεις µεταξύ των τρανζίστορ χρησιµοποιούνταν κατά κόρον το αλουµίνιο, καθώς είναι ένα φτηνό µέταλλο µε καλή αγωγιµότητα και ελατότητα.
Από το 1997 όµως, αντί για το αλουµίνιο χρησιµοποιείται χαλκός, που αν και ακριβότερος, διαθέτει ακόµα καλύτερη αγωγιµότητα αλλά και ελατότητα, δηλαδή µπορεί να δώσει νήµατα εξαιρετικά µικρής διατοµής (µικρότερης από 0,1 µ = 100 nm) χωρίς να σπάει.
Υλοποίηση Συναρτήσεων Boole
Στον σχεδιασµό ψηφιακών ηλεκτρονικών κυκλωµάτων, αρχικά προσδιορίζεται η συνάρτηση της Αλγεβρας Boole που θέλουµε να υλοποιήσουµε και, κατόπιν, προσπαθούµε να σχεδιάσουµε ένα κύκλωµα µε πύλες το οποίο να υλοποιεί την συνάρτηση αυτή.
Ο σχεδιασµός απλοποιείται αν, χρησιµοποιώντας τους κανόνες της άλγεβρας Boole, µετασχηµατίσουµε την συνάρτηση σε άθροισµα (OR) 2n γινοµένων (AND).
Στη συνέχεια θα δώσουµε ένα παράδειγµα σχεδιασµού κυκλώµατος µε βάση δοθείσα συνάρτηση, χωρίς να µπούµε σε πολλές λεπτοµέρειες, ώστε να αντιληφθεί ο σπουδαστής τις βασικές αρχές της σχεδίασης υπολογιστικών κυκλωµάτων.
Έστω ότι θέλουµε να κατασκευάσουµε ένα ψηφιακό κύκλωµα που να υλοποιεί την
Τα βήµατα που ακολουθούµε στον σχεδιασµό του κυκλώµατος είναι τα ακόλουθα :
Γράφουµε τον Πίνακα Αληθείας της συνάρτησης
Προσθέτουµε στις εισόδους πύλες NOT για την παραγωγή του συµπληρώµατος κάθε
Σχεδιάζουµε µια πύλη AND για κάθε όρο που έχει bit µε τιµή 1 στη στήλη των
Συνδέουµε τις πύλες AND µε τις κατάλληλες εισόδους
Στέλνουµε την έξοδο όλων των πυλών AND σε µια πύλη OR Στην επόµενη εικόνα φαίνεται το ψηφιακό κύκλωµα που προκύπτει, το οποίο χρησιµοποιεί συνολικά 8 πύλες.
Το κύκλωµα που προέκυψε είναι λειτουργικό αλλά δεν είναι ακόµη βελτιστοποιηµένο.
Κατασκευαστικά, είναι προτιµότερο να χρησιµοποιείται ο ίδιος τύπος πυλών.
Έτσι, στο κύκλωµα αυτό είναι προτιµότερο να αντικατασταθούν οι πύλες NOT, AND και OR µε τους ισοδύναµους συνδυασµούς NAND και NOR.
Οι πύλες NAND και NOR λέγονται και «Πλήρεις Πύλες» γιατί είναι οι µόνες µε τις οποίες µπορεί να υλοποιηθεί
Κύκλωµα υλοποίησης της συνάρτησης Μ(A,B,C) και πίνακας αληθείας
Οι πύλες δεν κατασκευάζονται ούτε πωλούνται µεµονωµένα, αλλά σε µονάδες που λέγονται Ολοκληρωµένα Κυκλώµατα (Integrated Circuits, IC) ή απλά chips.
Ένα chip είναι ένα τετράγωνο κοµµάτι πυριτίου, πάνω στο οποίο τοποθετείται ένας αριθµός πυλών.
Τα µικρά ολοκληρωµένα κυκλώµατα είναι συνήθως συσκευασµένα σε ένα ορθογώνιο πλαστικό ή κεραµικό περίβληµα που τους παρέχει µηχανική στήριξη και προστασία από το περιβάλλον.
Κατά µήκος των πλευρών τους υπάρχουν 2 παράλληλες σειρές ακροδεκτών, οι οποίοι κολλούνται απ’ ευθείας πάνω στην πλακέτα (Printed Circuit Board, PCB) ή εισάγονται σε ειδικές βάσεις.
Κάθε ακροδέκτης συνδέεται µε την είσοδο ή έξοδο µιας πύλης του chip ή µε την τροφοδοσία ή γείωση του ολοκληρωµένου.
Οι συσκευασίες αυτές µε τις 2 παράλληλες σειρές ακροδεκτών λέγονται DIP (Dual Inline Package) και έχουν συνήθως 14,16,18,20,22,24,28,40,64 ή 68 ακροδέκτες.
Τα µεγαλύτερα σε µέγεθος chip χρησιµοποιούν συνήθως τετραγωνικές συσκευασίες µε ακροδέκτες είτε από κάτω είτε και στις 4 πλευρές.
Ανάλογα µε τον αριθµό των πυλών που περιέχουν, τα chip χωρίζονται στις παρακάτω Κυκλώµατα SSI (Small Scale Integration).
Ολοκλήρωση µικρής κλίµακας.
Περιέχουν 1- Κυκλώµατα MSI (Medium Scale Integration).
Ολοκλήρωση µεσαίας κλίµακας.
Κυκλώµατα LSI (Large Scale Integration).
Ολοκλήρωση µεγάλης κλίµακας.
Περιέχουν Κυκλώµατα VLSI (Very Large Scale Integration).
Ολοκλήρωση πολύ µεγάλης κλίµακας.
Περιέχουν πάνω από 100.000 πύλες Στην επόµενη εικόνα φαίνεται το σχηµατικό διάγραµµα ενός κοινού chip SSI που περιέχει 4
Ολοκληρωµένο κύκλωµα SSI µε 4 πύλες NAND.
Κατά τον σχεδιασµό κυκλωµάτων, θεωρούµε τις πύλες ιδανικές µε την έννοια ότι η έξοδος εµφανίζεται αµέσως µόλις εφαρµοστεί η είσοδος.
Στην πραγµατικότητα, όλα τα chip έχουν µια Καθυστέρηση Πύλης (Gate Delay), η οποία περιλαµβάνει το χρόνο διάδοσης του σήµατος µέσω του chip και το χρόνο µεταγωγής, και κυµαίνεται από 0,3 έως 50 nsec.
Εκτός από την καθυστέρηση πύλης, υπάρχει και άλλο ένα µέγεθος που είναι σηµαντικό στα ολοκληρωµένα κυκλώµατα και αυτό είναι το λεγόµενο fan-out.
Το fan-out είναι στην ουσία ένας αριθµός που εκφράζει το πόσες πύλες ίδιας τεχνολογίας µπορούµε να συνδέσουµε στην έξοδο µιας πύλης, έτσι ώστε στην έξοδο της τελευταίας πύλης να µπορεί να γίνεται σαφής διάκριση µεταξύ των τιµών 0 και 1.
Εποµένως το fan-out εκφράζει το πόσα στάδια (από πύλη σε πύλη) µπορεί να έχει ένα ψηφιακό κύκλωµα που σκοπεύουµε να υλοποιήσουµε µε ολοκληρωµένα κυκλώµατα της συγκεκριµένης τεχνολογίας.
Ενώ στα chip SSI κάθε είσοδος ή έξοδος µιας πύλης αντιστοιχεί σε έναν ακροδέκτη, στα chip MSI και πάνω είναι τεχνικά δύσκολο έως αδύνατον να έχει κάθε πύλη ακροδέκτες, καθώς θα απαιτούνταν µεγάλος αριθµός ακροδεκτών, που σε ένα chip VLSI θα ήταν µερικά εκατοµµύρια!
Γι' αυτό, στα chip αυτά ένας αριθµός πυλών συνδυάζονται εσωτερικά για να προσφέρουν µια χρήσιµη λειτουργία ενώ εξωτερικά απαιτούν έναν µικρό αριθµό ακροδεκτών.
Στη συνέχεια θα εξετάσουµε µερικά τέτοια κυκλώµατα που χρησιµοποιούνται
Πολλές εφαρµογές ψηφιακής λογικής απαιτούν ένα κύκλωµα µε πολλές εισόδους και πολλές εξόδους, στο οποίο οι έξοδοι καθορίζονται µονοσήµαντα από τις τρέχουσες εισόδους.
Τα κυκλώµατα αυτά λέγονται Συνδυαστικά (Combinational).
Θα εξετάσουµε εν συντοµία µερικά βασικά συνδυαστικά κυκλώµατα.
Οι Αποκωδικοποιητές (Decoders) είναι κυκλώµατα µε n εισόδους και 2n εξόδους.
Ανάλογα µε την τιµή στις γραµµές εισόδου επιλέγεται µία από τις εξόδους.
Για την υλοποίηση του κυκλώµατος, για καθεµία από τις εισόδους λαµβάνουµε και την αντιστροφή της.
Στην έξοδο του κυκλώµατος έχουµε τόσες πύλες AND όσες και οι
Σε κάθε πύλη AND που είναι πολλαπλών εισόδων, οδηγούµε τις κατάλληλες γραµµές των εισόδων η των αντίστροφών τους.
Για παράδειγµα η έξοδος D0 θέλουµε να ενεργοποιείται (να είναι σε λογικό 1) στην περίπτωση που και οι τρεις είσοδοι θα είναι 0, δηλαδή (A,B,C)=(0,0,0).
Για να ενεργοποιηθεί όµως η πύλη και να δώσει στην έξοδο λογικό 1, θα πρέπει όλες οι είσοδοι της να είναι µονάδα.
Έτσι οδηγούµε στην είσοδο της πύλης αυτής τα αντίστροφα των εισόδων, δηλαδή Οµοίως, η έξοδος D1 θα πρέπει να ενεργοποιείται όταν οι είσοδοι θα είναι : (A,B,C)=(0,0,1).
Εποµένως θα οδηγήσουµε στην 2η πύλη AND τα ( A , B ,C).
Με παρόµοιο τρόπο καθορίζουµε τις εισόδους και στις υπόλοιπες πύλες.
Οι αποκωδικοποιητές χρησιµοποιούνται στους υπολογιστές κυρίως για επιλογή chip ή κυκλωµάτων.
Στην επόµενη εικόνα φαίνεται ένας αποκωδικοποιητής 3 σε 8.
Μια εφαρµογή του κυκλώµατος αυτού µπορεί να είναι η επιλογή chip µνήµης.
Εστω ένας υπολογιστής µε µνήµη που αποτελείται από 8 chip, καθένα από τα οποία περιέχει 1MB.
Το chip 0 περιέχει τις διευθύνσεις 0-1MB, το chip 1 τις διευθύνσεις 1-2MB κ.ο.κ.
Όταν ζητείται µια διεύθυνση µνήµης πως θα γνωρίζει το κύκλωµα ελέγχου της µνήµης ποιο chip να προσπελάσει;
Η απάντηση είναι χρησιµοποιώντας τα 3 bit υψηλής τάξης των διευθύνσεων για την επιλογή ενός από τα 8 chip.
Τα 3 αυτά bit οδηγούνται στην είσοδο του αποκωδικοποιητή 3 σε 8 και ανάλογα µε την τιµή που έχουν ενεργοποιούν ένα από τα 8 chip µνήµης, καθένα από τα οποία είναι συνδεδεµένο µε µία έξοδο του αποκωδικοποιητή.
Οι Πολυπλέκτες (Multiplexers) είναι κυκλώµατα µε 2n εισόδους, µία έξοδο και n εισόδους ελέγχου που επιλέγουν µία από τις εισόδους.
Η επιλεγµένη είσοδος συνδέεται τότε µε την έξοδο.
Στην επόµενη εικόνα φαίνεται ένας πολυπλέκτης 8 εισόδων, 1 εξόδου και 3 γραµµών ελέγχου.
Οι γραµµές D0-D7 αποτελούν τις εισόδους του ενώ οι γραµµές A,B,C είναι οι γραµµές ελέγχου.
Οι 3 γραµµές ελέγχου µπορούν να πάρουν 23=8 δυνατούς συνδυασµούς τιµών, κάθε ένας εκ των οποίων επιλέγει µια από τις 8 εισόδους.
Για την υλοποίηση του κυκλώµατος, για καθεµία από τις γραµµές ελέγχου λαµβάνουµε και την αντιστροφή της.
Στην έξοδο του κυκλώµατος έχουµε τόσες πύλες AND όσες και οι είσοδοι οι οποίες οδηγούνται όλες σε µία πύλη OR πολλαπλών εισόδων.
Σε κάθε πύλη AND που είναι επίσης πολλαπλών εισόδων, οδηγούµε την αντίστοιχη είσοδο και τις κατάλληλες γραµµές ελέγχου ή τα αντίστροφά τους.
Για παράδειγµα, η είσοδος D0 θα οδηγηθεί στην έξοδο όταν οι γραµµές ελέγχου θα είναι (A,B,C)=(0,0,0).
Για να γίνει αυτό θα πρέπει να ενεργοποιηθεί η 1η πύλη AND.
Αυτό σηµαίνει ότι θα πρέπει όλες οι είσοδοι της 1ης πύλης AND που προέρχονται από τις γραµµές ελέγχου να είναι όλες 1.
Έτσι το τι θα βγει στην έξοδο εξαρτάται αποκλειστικά από την είσοδο D0.
Αν η είσοδος D0 είναι 0 τότε η έξοδος της πύλης AND θα είναι επίσης 0.
Αν όµως η είσοδος D0 είναι 1 τότε και η έξοδος της πύλης θα είναι 1, αφού και οι άλλες είσοδοι που προέρχονται από τις γραµµές ελέγχου είναι 1.
Έτσι οδηγούµε στην είσοδο της πύλης αυτής τα αντίστροφα των γραµµών ελέγχου, δηλαδή τα ( A , B ,C ).
Πρέπει εδώ να σηµειωθεί ότι όταν οι γραµµές ελέγχου είναι (A,B,C)=(0,0,0) τότε µόνο η 1η πύλη AND ενεργοποιείται, ενώ όλες οι άλλες παραµένουν απενεργοποιηµένες, δηλαδή βγάζουν στην έξοδό τους 0, ανεξάρτητα από την αντίστοιχη είσοδο, καθώς από τις εισόδους τους που προέρχονται από τις γραµµές ελέγχου υπάρχει τουλάχιστον ένα 0.
Οµοίως η είσοδος D1 θα οδηγείται στην έξοδο όταν οι γραµµές ελέγχου θα είναι : (A,B,C)=(0,0,1).
Εποµένως θα οδηγήσουµε στην 2η πύλη AND την δεύτερη είσοδο (D1) και τα ( A , B ,C).
Με παρόµοιο τρόπο καθορίζουµε τις εισόδους και στις υπόλοιπες πύλες.
Η συγκεντρωτική πύλη OR στην έξοδο του κυκλώµατος κάνει την εξής δουλειά: Αν εµφανιστεί µία µονάδα από οποιαδήποτε πύλη AND τότε αυτή οδηγείται στην έξοδο.
Αν όλες οι πύλες AND δίνουν 0 (ακόµα και η ενεργοποιηµένη) τότε η έξοδος θα είναι 0.
Συνήθης εφαρµογή των πολυπλεκτών στους υπολογιστές είναι ο διαµοιρασµός κάποιου κυκλώµατος σε πολλά άλλα.
Για παράδειγµα, µια οµάδα αγωγών στην µητρική πλακέτα µπορεί να χρησιµοποιείται άλλοτε σαν µέρος του data bus και άλλοτε σαν µέρος του address bus.
Ο πολυπλέκτης τοποθετείται στο σηµείο όπου πολλοί δίαυλοι καταλήγουν Άλλη χρήση είναι η µετατροπή παράλληλων δεδοµένων σε σειριακά.
Στο κύκλωµα της εικόνας για παράδειγµα, από τη στιγµή που στην είσοδο του πολυπλέκτη εµφανιστούν τα παράλληλα δεδοµένα, δίνοντας στις γραµµές ελέγχου διαδοχικά τις τιµές 000 έως 111 µε ένα κύκλωµα µετρητή (counter), στην έξοδο θα εµφανιστούν διαδοχικά τα δεδοµένα εισόδου σε σειριακή µορφή.
Ο ρυθµός σειριακής µετάδοσης των δεδοµένων στην έξοδο καθορίζεται από τον ρυθµό µε τον οποίο αλλάζει τιµές ο µετρητής (counter).
Επίσης θα πρέπει κατά την επαναφορά των τιµών στις γραµµές ελέγχου από το 111 ξανά στο 000 θα πρέπει να ειδοποιείται η συσκευή που εξάγει παράλληλα δεδοµένα ώστε να εµφανίσει την επόµενη Επίσης ο πολυπλέκτης χρησιµοποιείται για ανάγνωση µνήµης.
Υποθέστε ότι πριν από κάθε µια από τις εισόδους βρίσκεται και ένα κελί µνήµης.
Στο παράδειγµα του σχήµατος θα έχουµε µια µνήµη µε οκτώ συνολικά κελιά.
Για να διαβάσουµε ένα οποιοδήποτε κελί αρκεί να σχηµατίσουµε στις γραµµές ελέγχου την κατάλληλη «διεύθυνση µνήµης», δηλαδή τον κατάλληλο ψηφιακό αριθµό από 000 έως 111.
∆ίνοντας την κατάλληλη διεύθυνση στις γραµµές ελέγχου το αντίστοιχο κελί (γραµµή εισόδου) οδηγείται στην έξοδο, η οποία βέβαια αποτελεί τον κοινό δίαυλο δεδοµένων από τον οποίο γίνεται η ανάγνωση της µνήµης.
Πολυπλέκτης 8 εισόδων, 1 εξόδου και 3 γραµµών ελέγχου
Το αντίστροφο κύκλωµα ονοµάζεται Αποπολυπλέκτης (Demultiplexer) και δροµολογεί το σήµα της µοναδικής εισόδου του σε µία από τις 2n εξόδους του, ανάλογα µε τις τιµές στις n γραµµές ελέγχου.
Οι Αποπολυπλέκτες (Demultiplexers) είναι κυκλώµατα µε 1 είσοδο, n γραµµές ελέγχου και 2n εξόδους.
Ανάλογα µε τον συνδυασµό των τιµών στις γραµµές ελέγχου, η είσοδος οδηγείται σε µία από τις εξόδους.
Στην επόµενη εικόνα φαίνεται ένας αποπολυπλέκτης 4 εξόδων, 1 εισόδου και 2 γραµµών ελέγχου.
Οι 2 γραµµές ελέγχου µπορούν να πάρουν 22=4 δυνατούς συνδυασµούς τιµών, κάθε ένας εκ των οποίων συνδέει την µοναδική είσοδο στην αντίστοιχη έξοδο. όσες και οι έξοδοι.
Σε κάθε πύλη AND που είναι επίσης πολλαπλών εισόδων, οδηγούµε την µοναδική Για παράδειγµα, η είσοδος θα οδηγηθεί στην 1η έξοδο όταν οι γραµµές ελέγχου θα είναι (A1,Α0)=(0,0).
Για να γίνει αυτό θα πρέπει να ενεργοποιηθεί η 1η πύλη AND.
Αυτό ελέγχου να είναι όλες 1.
Έτσι το τι θα βγει στην έξοδο της πύλης AND εξαρτάται αποκλειστικά από την είσοδο D.
Αν η είσοδος D είναι 0 τότε η έξοδος της πύλης AND θα είναι επίσης 0.
Αν όµως η είσοδος D είναι 1 τότε και η έξοδος της πύλης θα είναι 1, αφού και οι άλλες είσοδοι που προέρχονται από τις γραµµές ελέγχου είναι 1.
Έτσι οδηγούµε στην είσοδο της πύλης αυτής τα αντίστροφα των γραµµών ελέγχου, δηλαδή τα ( 1A , 0A ).
Πρέπει εδώ να σηµειωθεί ότι όταν οι γραµµές ελέγχου είναι (A1,Α0)=(0,0) τότε µόνο η 1η πύλη AND ενεργοποιείται, ενώ όλες οι άλλες παραµένουν απενεργοποιηµένες, δηλαδή βγάζουν στην έξοδό τους 0, ανεξάρτητα από την είσοδο, καθώς από τις εισόδους τους που προέρχονται από τις γραµµές ελέγχου υπάρχει τουλάχιστον ένα 0.
Οµοίως η είσοδος D θα οδηγείται στην 2η έξοδο όταν οι γραµµές ελέγχου θα είναι : (A1,Α0)=(0,1).
Εποµένως θα οδηγήσουµε στην 2η πύλη AND την µοναδική είσοδο D και τα ( 1A ,Α0).
Με παρόµοιο τρόπο καθορίζουµε τις εισόδους και στις υπόλοιπες πύλες.
Συνήθης εφαρµογή των αποπολυπλεκτών στους υπολογιστές είναι ο διαµοιρασµός πλακέτα µπορεί να χρησιµοποιείται άλλοτε σαν µέρος του data bus και άλλοτε σαν µέρος του address bus.
Ο αποπολυπλέκτης τοποθετείται στο σηµείο όπου ένας δίαυλος διαµοιράζεται Άλλη χρήση είναι η µετατροπή σειριακών δεδοµένων σε παράλληλα.
Στο κύκλωµα της εικόνας για παράδειγµα, µπορούµε να εφαρµόσουµε το σειριακό σήµα στην µοναδική είσοδο D.
Εν συνεχεία δίνοντας στις γραµµές ελέγχου διαδοχικά τις τιµές 00 έως 11 µε ένα κύκλωµα µετρητή (counter), τα σειριακά bit θα τοποθετούνται στην κατάλληλη έξοδο, σχηµατίζοντας µία «παράλληλη» λέξη.
Ο ρυθµός µε τον οποίο αλλάζει τιµές ο µετρητής (counter) θα πρέπει να ταυτίζεται µε τον ρυθµό σειριακής µετάδοσης των δεδοµένων.
Επίσης θα πρέπει κατά την επαναφορά των τιµών στις γραµµές ελέγχου από το 11 ξανά στο 00 θα πρέπει να ειδοποιείται η συσκευή που διαβάζει τα παράλληλα δεδοµένα ώστε να διαβάσει την ολοκληρωµένη λέξη και να µπει σε αναµονή για την επόµενη.
Επίσης ο αποπολυπλέκτης χρησιµοποιείται για εγγραφή µνήµης.
Υποθέστε ότι µετά από κάθε µια από τις εξόδους βρίσκεται και ένα κελί µνήµης.
Στο παράδειγµα του σχήµατος θα έχουµε µια µνήµη µε τέσσερα συνολικά κελιά.
Για να γράψουµε σε ένα οποιοδήποτε κελί αρκεί να σχηµατίσουµε στις γραµµές ελέγχου την κατάλληλη «διεύθυνση µνήµης», δηλαδή τον κατάλληλο ψηφιακό αριθµό από 00 έως 11.
∆ίνοντας την κατάλληλη διεύθυνση στις γραµµές ελέγχου, η µοναδική είσοδος που θα αποτελεί τον κοινό δίαυλο δεδοµένων οδηγείται στο αντίστοιχο κελί µνήµης (γραµµή εξόδου).
Αποπολυπλέκτης 1 εισόδου, 2 γραµµών ελέγχου και 4 εξόδων
Οι Συγκριτές (Comparators) είναι κυκλώµατα που συγκρίνουν τα δεδοµένα στην είσοδό τους και δίνουν ανάλογη τιµή στην έξοδό τους.
Στην επόµενη εικόνα φαίνεται ένας απλός συγκριτής ο οποίος δέχεται σαν είσοδο τις 4-bit λέξεις Α και Β και στην έξοδο δίνει τιµή 1 αν είναι ίσες και 0 αν είναι άνισες.
Το κύκλωµα βασίζεται στην πύλη XOR η οποία δίνει έξοδο 0 όταν οι είσοδοι της είναι ίσες και 1 όταν είναι διαφορετικές.
Ο πίνακας αληθείας της XOR που µπορεί να χρησιµοποιηθεί για σύγκριση αριθµών Αν οι 2 λέξεις εισόδου είναι ίσες, και οι 4 XOR θα δώσουν έξοδο 0.
Οι έξοδοι των XOR αποτελούν την είσοδο µιας NOR.
Αν η έξοδος της NOR είναι 1 οι λέξεις εισόδου είναι ίδιες αλλιώς είναι διαφορετικές.
Συγκριτής δύο λέξεων των 4 bit
Προγραµµατιζόµενοι Λογικοί Πίνακες (Programmable Logic Arrays – PLAs)
Όπως είδαµε πιο πάνω, κάθε συνάρτηση µπορεί να κατασκευαστεί αν µετατραπεί σε άθροισµα 2n γινοµένων, όπου τα γινόµενα υλοποιούνται µε πύλες AND και τα αθροίσµατα µε πύλες OR.
Οι Προγραµµατιζόµενοι Λογικοί Πίνακες (Programmable Logic Array - PLAs) είναι κυκλώµατα γενικής χρήσης τα οποία µπορούν να προγραµµατιστούν από τον χρήστη για την υλοποίηση µιας λογικής συνάρτησης αθροίσµατος γινοµένων.
Στην επόµενη εικόνα φαίνεται ένα PLA 12 εισόδων και 6 εξόδων.
Καρδιά του κυκλώµατος αυτού είναι ένας πίνακας πυλών AND στην είσοδο και ένας πίνακας πυλών OR στην έξοδο.
Όταν το ολοκληρωµένο κύκλωµα κατασκευάζεται στο εργοστάσιο, όλες οι πύλες επικοινωνούν µεταξύ τους µέσω εύτηκτων ασφαλειών, δηλαδή ασφαλειών που καίγονται εύκολα αν περάσει από µέσα τους ρεύµα κατάλληλης έντασης.
Ο χρήστης, µπορεί να προγραµµατίσει το PLA χρησιµοποιώντας ένα ειδικό κύκλωµα PLA-Programmer, το οποίο καίει επιλεκτικά κάποιες ασφάλειες, εφαρµόζοντας υψηλή τάση στο chip, αφήνοντας έτσι µόνο τις επιθυµητές συνδέσεις για την υλοποίηση της εκάστοτε συνάρτησης.
Προγραµµατιζόµενος Λογικός Πίνακας 12 εισόδων και 6 εξόδων µε 50 πύλες AND
Στην κατηγορία αυτή ανήκουν τα κυκλώµατα που πραγµατοποιούν αριθµητικές πράξεις.
Οι Ολισθητές (Shifters) είναι κυκλώµατα n εισόδων, n εξόδων και 1 γραµµής ελέγχου.
Η έξοδος του κυκλώµατος είναι τα bit εισόδου µετατοπισµένα κατά 1 bit.
Την φορά της ολίσθησης, προς τα δεξιά ή αριστερά, καθορίζει το bit στη γραµµή ελέγχου.
Σε µία ψηφιακή λέξη η ολίσθηση προς τα αριστερά σηµαίνει πολλαπλασιασµός επί 2, ενώ ολίσθηση προς τα δεξιά σηµαίνει διαίρεση δια 2.
Στην επόµενη εικόνα φαίνεται ένας ολισθητής 8 bit.
Τα bit εισόδου D0-D7 εµφανίζονται στην έξοδο S0-S7 µετατοπισµένα κατά 1 bit δεξιά ή αριστερά, ανάλογα µε την τιµή στην γραµµή ελέγχου C.
Στον ολισθητή όλα τα bit του αριθµού εκτός από τα δύο ακραία (D0 και D7) οδηγούνται σε ένα ζευγάρι πυλών AND.
Σε κάθε τέτοιο ζευγάρι στην δεξιά AND συνδέεται η γραµµή C ενώ στην αριστερή AND η αντίστροφη της.
Έτσι αν η γραµµή ελέγχου έχει την τιµή 0 και προφανώς η αντίστροφή της έχει τιµή 1, «ενεργοποιούνται» οι «αριστερές» πύλες AND οδηγώντας τα bits προς τα αριστερά (shift left).
Προσέξτε ότι σε αυτή την περίπτωση το bit D0 δεν οδηγείται πουθενά και χάνεται.
Προσέξτε επίσης ότι το bit S7 σχηµατίζεται από την έξοδο της «δεξιάς» πύλης που αντιστοιχεί στο bit εισόδου D6, η οποία λόγω του ότι έχει στην είσοδο την γραµµή C που είναι 0, δίνει και στην έξοδό της 0, και έτσι πάντα το bit S7 παίρνει την τιµή 0 σε περίπτωση αριστερής ολίσθησης.
∆ηλαδή η λέξη «γεµίζει» από δεξιά µε µηδενικά.
Αν αντίθετα η γραµµή ελέγχου έχει την τιµή 1 και προφανώς η αντίστροφή της έχει τιµή 0, «ενεργοποιούνται» οι «δεξιές» πύλες AND οδηγώντας τα bits προς τα δεξιά (shift right).
Προσέξτε ότι σε αυτή την περίπτωση το bit D7 δεν οδηγείται πουθενά και χάνεται.
Προσέξτε επίσης ότι το bit S0 σχηµατίζεται από την έξοδο της «αριστερής» πύλης που αντιστοιχεί στο bit εισόδου D1, η οποία λόγω του ότι έχει στην είσοδο την γραµµή C (το αντίστροφο της C) που είναι 0, δίνει και στην έξοδό της 0, και έτσι πάντα το bit S0 παίρνει την τιµή 0 σε περίπτωση δεξιάς ολίσθησης.
∆ηλαδή η λέξη «γεµίζει» από αριστερά µε Σηµειώστε επίσης ότι τα παραπάνω ισχύουν για τον ολισθητή του σχήµατος στον οποίο τα bit της λέξης εµφανίζονται µε ανάποδη σειρά από την συνηθισµένη.
Ολισθητής λέξης των 8 bit ε µία γραµµή ελέγχου για ολίσθηση δεξιά ή αριστερά
Οι ολισθητές χρησιµοποιούνται στις Αριθµητικές και Λογικές Μονάδες (ALUs) για να υλοποιούν τις εντολές ολίσθησης και περιστροφής του σετ εντολών γλώσσας µηχανής του επεξεργαστή (π.χ.
SHL, SHR, SAR, ROL, ROR, RCL, RCR), αλλά όπως προαναφέρθηκε µπορεί να χρησιµοποιηθούν και για πολλαπλασιασµό ή διαίρεση µε το 2 ή µε δυνάµεις του 2.
Επίσης µπορούν να χρησιµοποιηθούν για µετατροπή λέξεων από παράλληλες σε σειριακές.
Αυτό µπορεί να γίνει ως εξής:
Η λέξη εµφανίζεται ως είσοδος στον ολισθητή.
Εκτελούνται διαδοχικές π.χ. oλισθήσεις δεξιά ,
Λαµβάνονται τα bit της λέξης µε σειριακό τρόπο (ένα-ένα) από το bit S7 Τα βήµατα 2 και 3 µπορούν ισοδύναµα να γίνουν :
Εκτελούνται διαδοχικές oλισθήσεις αριστερά, Αυτό που διαφέρει στις δύο εναλλακτικές υλοποιήσεις είναι η σειρά µετατροπής των bit.
Στην πρώτη περίπτωση τα bits λαµβάνονται σειριακά µε την ακολουθία D7Æ D0, ενώ στην δεύτερη περίπτωση µε την ακολουθία D0Æ D7.
Οι Αθροιστές (Adders) είναι κυκλώµατα που χρησιµοποιούνται για την πρόσθεση ακεραίων.
Η απλούστερη µορφή αθροιστή είναι ο Ηµιαθροιστής (Half-Adder).
Στην επόµενη εικόνα φαίνεται ένας ηµιαθροιστής ο οποίος προσθέτει 2 αριθµούς του 1 bit.
Στην έξοδο εµφανίζεται το άθροισµα των 2 εισόδων και το κρατούµενο.
Ο ηµιαθροιστής είναι κατάλληλος για την πρόσθεση των bit χαµηλής τάξης δύο λέξεων εισόδου µε πολλά bit αλλά είναι ακατάλληλος για πρόσθεση bit στο µέσον των λέξεων, καθώς δεν υπολογίζει στην πράξη το ενδεχόµενο κρατούµενο που προέρχεται από την προηγούµενη πρόσθεση χαµηλότερης τάξης bit.
Ηµιαθροιστής 2 λέξεων του ενός bit και ο πίνακας αληθείας του
Συνδυάζοντας 2 ηµιαθροιστές µπορούµε να υλοποιήσουµε τον Πλήρη Αθροιστή (Full Adder), ο οποίος δέχεται σαν είσοδο εκτός από τα 2 bit που πρόκειται να προστεθούν και το κρατούµενο που προέκυψε από προηγούµενη πράξη.
Ένα τέτοιο κύκλωµα φαίνεται στην
Πλήρης Αθροιστής 2 λέξεων του ενός bit και ο πίνακας αληθείας του
Για την πρόσθεση δύο λέξεων των 16, 32 ή 64 bit, χρησιµοποιούµε πολλούς πλήρεις αθροιστές παράλληλα, µε τρόπο ώστε η έξοδος και τα κρατούµενο του προηγούµενου να αποτελεί είσοδο του επόµενου.
Ανάλογα µε τον τρόπο που συνδέονται οι επιµέρους πλήρεις αθροιστές προκύπτει είτε ο Αθροιστής Κυµατοειδούς ∆ιάδοσης Κρατουµένου (Ripple Carry Adder) είτε ο ταχύτερος Αθροιστής Επιλογής Κρατουµένου (Carry Select Adder).
Αριθµητικές και Λογικές Μονάδες (Arithmetic and Logic Units – ALUs)
Οι Αριθµητικές & Λογικές Μονάδες (Arithmentic and Logic Unit, ALU) είναι υπεύθυνες για την εκτέλεση αριθµητικών πράξεων σε ακεραίους, καθώς και λογικών πράξεων (AND, OR, XOR, …) και συγκρίσεων, όπως και εκτέλεση πράξεων ολίσθησης και περιστροφής.
Περιέχουν τα κατάλληλα ψηφιακά κυκλώµατα για την εκτέλεση των πράξεων αυτών, δύο εισόδους δεδοµένων A και B για την προσκόµιση των αριθµών που θα συµµετέχουν στην πράξη, καθώς και µία είσοδο εντολής στην οποία η CPU τοποθετεί ένα κατάλληλο κωδικό αριθµό για να καθορίσει το τι πράξη θα γίνει.
Στην απλούστερη περίπτωση, όπως αυτή του παρακάτω σχήµατος, µπορούν να περιέχουν ένα µόνο σύνθετο κύκλωµα που εκτελεί τις πράξεις AND, OR, NOT και την αριθµητική πρόσθεση, µεταξύ 2 bit εισόδου.
Για πράξεις σε λέξεις των n bits συνδέονται n τέτοια κυκλώµατα.
Στην επόµενη εικόνα φαίνεται ένα τέτοιο κύκλωµα.
Αριθµητική και Λογική Μονάδα του 1 bit µε πράξεις AND, OR, NOT και πρόσθεση.
Τα bit εισόδου εφαρµόζονται στις εισόδους A και B.
Στην κάτω αριστερή γωνία υπάρχει ένας αποκωδικοποιητής δύο εισόδων (F0 & F1) ο οποίος επιλέγει µία από τις 4 ανωτέρω πράξεις.
∆ηλαδή στις εισόδους F0, F1 εφαρµόζεται ένας διψήφιος δυαδικός αριθµός από 00 έως και 11 ο οποίος καθορίζει το ποια πράξη θα εκτελεστεί.
Εποµένως ο αριθµός αυτός (F0,F1) είναι στην ουσία ο κωδικός εντολής που δέχεται η ALU.
Ο αποκωδικοποιητής (decoder) στη συνέχεια ενεργοποιεί (φέρνει σε λογικό 1) µία από τις 4 εξόδους του, ανάλογα µε τον συνδυασµό των εισόδων.
Η αντιστοιχία των αριθµών µε τις πράξεις στο συγκεκριµένο παράδειγµα ALU είναι η ακόλουθη: Αριθµός κωδικού εντολής της
Αντίστοιχη Πράξη που θα εκτελεστεί
Στην επάνω αριστερή γωνία υπάρχει η Λογική µονάδα η οποία εκτελεί τις πράξεις AND, OR και NOT.
Στην κάτω δεξιά γωνία υπάρχει ένας πλήρης αθροιστής ο οποίος πραγµατοποιεί την αριθµητική πρόσθεση.
Όπως µπορούµε να δούµε, και οι 4 πράξεις πραγµατοποιούνται µέσα στο κύκλωµα ταυτόχρονα.
Ωστόσο, το ποια θα εµφανιστεί στην έξοδο εξαρτάται από το ποια από τις γραµµές εξόδου του αποκωδικοποιητή έχει τιµή 1.
Αυτό υλοποιείται οδηγώντας την έξοδο της κάθε πράξης σε µια πύλη AND µαζί µε την αντίστοιχη γραµµή εξόδου του αποκωδικοποιητή.
Επειδή για κάθε εντολή που δέχεται η ALU µόνο µια έξοδος του αποκωδικοποιητή ενεργοποιείται (έρχεται σε λογικό 1), ενώ όλες οι υπόλοιπες παραµένουν σε λογικό 0, από τις τέσσερις πύλες AND οι τρεις θα είναι απενεργοποιηµένες (θα βγάζουν στην έξοδο λογικό 0) καθώς στην είσοδό τους θα λαµβάνουν ένα τουλάχιστον µηδενικό, από την έξοδο του αποκωδικοποιητή.
Μία µόνο πύλη θα λαµβάνει λογικό ένα από την έξοδο του αποκωδικοποιητή, και έτσι το αποτέλεσµα που θα βγάζει στην έξοδό της θα εξαρτάται αποκλειστικά από το αποτέλεσµα της αντίστοιχης πράξης.
Τέλος, τα σήµατα ελέγχου ENA και ΕΝΒ µπορούν να ενεργοποιήσουν ή να απενεργοποιήσουν τις εισόδους A και Β αντίστοιχα ενώ το INVA όταν έχει τιµή 1 δίνει στον κύκλωµα σαν είσοδο το Α αντεστραµµένο.
Η συγκεντρωτική πύλη OR στην έξοδο του κυκλώµατος κάνει την εξής δουλειά: Αν Κυκλώµατα όπως αυτό που περιγράφηκε κυκλοφορούν στο εµπόριο και ονοµάζονται ∆υαδικές Μονάδες (Bit Slices).
Συνδέοντας παράλληλα πολλές τέτοιες µονάδες µπορούν να εκτελεστούν πράξεις σε λέξεις οποιουδήποτε εύρους σε bit.
Κυκλώµατα Ρολογιού (Clocks)
Σε κάθε υπολογιστή, η σειρά µε την οποία πραγµατοποιούνται οι διάφορες ενέργειες είναι κρίσιµη, ενώ κάποιες ενέργειες πρέπει να πραγµατοποιούνται πριν από κάποιες άλλες ή ταυτόχρονα µε αυτές.
Για την επίτευξη του απαιτούµενου συγχρονισµού χρησιµοποιούνται κυκλώµατα ταλαντωτών, τα οποία ονοµάζονται απλά Ρολόγια (clocks) και παράγουν τετραγωνικούς παλµούς µε ακριβές πλάτος και συχνότητα.
Για την επίτευξη της απαιτούµενης υψηλής ακρίβειας στη συχνότητα, τα ρολόγια χρησιµοποιούν συνήθως κρυστάλλους χαλαζία (quartz), ενώ οι συχνότητες συνεχώς αυξάνουν σε τιµή, έχοντας ξεπεράσει τα 3 GHz.
Το χρονικό διάστηµα µεταξύ των αντίστοιχων ακµών δύο διαδοχικών παλµών του ρολογιού λέγεται Χρόνος Κύκλου Ρολογιού (Clock Cycle Time) και είναι της τάξης των nsec (10-9 sec).
Συνήθως, ένα µόνο σήµα από το ρολόι δεν επαρκεί για τον συγχρονισµό όλων των ενεργειών που πρέπει να πραγµατοποιηθούν σε έναν κύκλο ρολογιού.
Γι' αυτό, ο κύκλος ρολογιού υποδιαιρείται σε επιµέρους τµήµατα.
Ένας κοινός τρόπος για να γίνει αυτό είναι η υποκλοπή του σήµατος της πρωτεύουσας γραµµής του ρολογιού και η εφαρµογή της σε ένα κύκλωµα γνωστής καθυστέρησης.
Έτσι, παράγεται ένα δευτερεύον σήµα ρολογιού που βρίσκεται σε διαφορά φάσης µε το πρωτεύον.
Αν χρειάζονται επιπλέον σήµατα, ακολουθείται η ίδια µέθοδος µε πρόσθετα κυκλώµατα καθυστέρησης.
Στην επόµενη εικόνα φαίνεται ένα ρολόι µε 2 εξόδους.
Στην συγκεκριµένη περίπτωση υπάρχουν 4 χρονικές αναφορές για διακριτά συµβάντα : Ακµή ανόδου σήµατος C1 Ακµή καθόδου σήµατος C1 Με τη σύνδεση διαφορετικών συµβάντων στις διάφορες ακµές του παλµού µπορεί να επιτευχθεί η απαιτούµενη χρονική ακολουθία.
Κύκλωµα Ρολογιού και παραγόµενες παλµοσειρές
Ορισµένα συµβάντα δεν σχετίζονται µε διακριτές χρονικές στιγµές αλλά µε χρονικά διαστήµατα.
Κάποιο συµβάν, για παράδειγµα, µπορεί να συµβεί µόνον όταν το σήµα C1 είναι στην υψηλή κατάσταση και όχι ακριβώς στην ακµή ανόδου του.
Στην προηγούµενη περίπτωση, τα χρονικά διαστήµατα που δηµιουργούνται από την επικάλυψη των C1 και C2
Στην επόµενη εικόνα (πηγή Intel) φαίνεται ο χρονισµός των σηµάτων του 8088.
Βασική παλµοσειρά αναφοράς είναι αυτή που παράγει το ρολόι του συστήµατος (CLK) που για τον 8088 λειτουργεί σε συχνότητα 4,77 MHz.
Κάθε διαδικασία µεταφοράς δεδοµένων δια µέσω των διαύλων του επεξεργαστή (CPU bus cycle) αποτελείται από τουλάχιστον 4 κύκλους του ρολογιού CLK.
Αυτοί φαίνονται στην εικόνα ως Τ1, Τ2, Τ3 και Τ4.
Η διεύθυνση αποστέλλεται από τον επεξεργαστή προς την µνήµη (µέσω του MAR) κατά τον κύκλο Τ1.
Τα δεδοµένα µεταφέρονται µέσω του διαύλου δεδοµένων κατά την διάρκεια των Τ3 και Τ4.
Ο κύκλος Τ2 χρησιµοποιείται κυρίως για την αλλαγή της κατεύθυνσης της ροής των δεδοµένων στον δίαυλο δεδοµένων (read/write).
Βασικός χρονισµός των σηµάτων του 8088
Κυκλώµατα Μνήµης (Memory Circuits)
Ένα βασικό συστατικό κάθε υπολογιστή είναι η µνήµη, η οποία χρησιµοποιείται για την αποθήκευση δεδοµένων και εντολών.
Βέβαια σε έναν Η/Υ υπάρχουν πολλά συστήµατα µνήµης όπως οι µνήµες µαγνητικής αποθήκευσης (σκληροί δίσκοι) ή οπτικής αποθήκευσης (CD, DVD, κ.λ.π.).
Εδώ αναφερόµαστε σε ηλεκτρονικές µνήµες (solid state) RΑΜ που υλοποιούνται µε πύλες.
Στις επόµενες παραγράφους θα εξετάσουµε τα βασικά συστατικά ενός συστήµατος µνήµης, σε επίπεδο πυλών.
Κυκλώµατα Μανδάλωσης (Latch Circuits)
Για να δηµιουργηθεί µια µνήµη του 1 bit χρειάζεται ένα κύκλωµα που να "θυµάται" µε κάποιον τρόπο τις προηγούµενες τιµές εισόδου.
Τέτοια κυκλώµατα µπορούν να κατασκευαστούν από δύο πύλες NAND ή NOR και ανατροφοδότηση και ονοµάζονται Κυκλώµατα Μανδάλωσης (Latch Circuits).
Σε αντίθεση µε τα συνδυαστικά κυκλώµατα, οι έξοδοι ενός τέτοιου κυκλώµατος δεν καθορίζονται µονοσήµαντα από τις τρέχουσες εισόδους.
∆ιακρίνουµε τις παρακάτω κατηγορίες κυκλωµάτων µανδάλωσης : Κύκλωµα Μανδάλωσης SR (SR Latch).
Ένα τέτοιο κύκλωµα έχει 2 εισόδους (S,R) και 2 συµπληρωµατικές εξόδους (Q, Q ).
Στο κύκλωµα αυτό, όταν δίνεται στιγµιαία η τιµή 1 στο S το κύκλωµα καταλήγει στην κατάσταση Q=1, ενώ για S=0 καταλήγει στην κατάσταση Q=0, ανεξάρτητα από την κατάσταση που βρισκόταν προηγουµένως.
Το κύκλωµα από δω και πέρα παραµένει στην κατάσταση αυτή, ανεξάρτητα από τις τιµές της εισόδου S.
Για να αλλάξει κατάσταση πρέπει να δοθεί στιγµιαία στο R η τιµή 1, οπότε το κύκλωµα τίθεται στην κατάσταση Q=0.
Η είσοδος R, εποµένως, εκτελεί reset στο κύκλωµα και το επαναφέρει στην κατάσταση Q=0.
Το κύκλωµα δηλαδή "θυµάται" και συγκρατεί την τιµή της εισόδου S µέχρι να γίνει reset, ανεξάρτητα από τις τιµές στην είσοδο.
Εκµεταλλευόµενοι αυτή την ιδιότητα µπορούµε να κατασκευάζουµε µνήµες υπολογιστών.
Χρονισµένο Κύκλωµα Μανδάλωσης SR (Clocked SR Latch).
Στο κύκλωµα αυτό έχει προστεθεί άλλη µια είσοδος που συνήθως είναι το σήµα του ρολογιού, µε σκοπό να καθορίζεται από το σήµα αυτό το χρονικό διάστηµα κατά το οποίο το κύκλωµα µανδάλωσης αντιλαµβάνεται τις µεταβολές στα S και R.
Έτσι, όταν το σήµα του ρολογιού παίρνει τιµή 1 το κύκλωµα εκτελεί τη λειτουργία µνήµης που είδαµε πιο πάνω, ενώ όταν είναι 0 το κύκλωµα είναι αδιάφορο στις τιµές στις εισόδους S,R και η κατάσταση του παραµένει αµετάβλητη και απροσδιόριστη.
Χρονισµένο Κύκλωµα Μανδάλωσης SR Χρονισµένο Κύκλωµα Μανδάλωσης D (Clocked D Latch).
Το κύκλωµα αυτό αποτελεί βελτίωση του προηγουµένου και διορθώνει την ασαφή συµπεριφορά του όταν S=R=1.
Εχει 2 εισόδους, την D, που περιέχει το προς αποθήκευση bit, και το σήµα του ρολογιού.
Όταν το ρολόϊ έχει τιµή 1, διαβάζεται και αποθηκεύεται η τιµή της εισόδου D, η οποία είναι διαθέσιµη στην έξοδο Q.
Το κύκλωµα αυτό χρησιµοποιείται κυρίως στην κατασκευή µνηµών για υπολογιστές.
Χρονισµένο Κύκλωµα Μανδάλωσης D
∆ισταθή Κυκλώµατα (FLIP-FLOP)
Σε πολλά κυκλώµατα είναι απαραίτητο να γίνεται δειγµατοληψία της τιµής κάποιας γραµµής σε µια συγκεκριµένη χρονική στιγµή και να αποθηκεύεται η τιµή αυτή.
Σε αυτό το είδος του κυκλώµατος, που λέγεται ∆ισταθές Κύκλωµα ή flip-flop, η αλλαγή κατάστασης δεν γίνεται όταν το ρολόι έχει τιµή 1 αλλά κατά τη µετάβαση του ρολογιού από το 0 στο 1 (ακµή ανόδου) και από το 1 στο 0 (ακµή καθόδου).
Έτσι το µήκος του παλµού του ρολογιού δεν έχει σηµασία, εφ' όσον η αλλαγή κατάστασης γίνεται γρήγορα.
Συνεπώς, ενώ τα κυκλώµατα µανδάλωσης είναι ενεργοποιούµενα µε επίπεδο (level triggered), τα δισταθή κυκλώµατα είναι ενεργοποιούµενα µε ακµή (edge triggered).
Η διαφορά αυτή µεταξύ τους επιβάλλει διαφορετικό λογικό σχεδιασµό αλλά η λειτουργία που επιτελούν είναι η ίδια.
Στην επόµενη εικόνα φαίνεται ένα D Flip-Flop.
∆ισταθές Κύκλωµα D (D Flip-Flop)
Kαι στην επόµενη εικόνα φαίνονται τα καθιερωµένα σύµβολα για τα κυκλώµατα µανδάλωσης και τα δισταθή κυκλώµατα.
Τα σύµβολα για (a), (b) κυκλώµατα µανδάλωσης D και (c),(d) δισταθή κυκλώµατα D
Τα δισταθή κυκλώµατα µπορούν να λειτουργούν είτε ανεξάρτητα είτε πολλά µαζί σε συνδυασµό ώστε να σχηµατίζουν µονάδες µνήµης των n bit.
Στην επόµενη εικόνα φαίνεται ένα chip 14 ακροδεκτών µε 2 ανεξάρτητα D Flip-Flop και ένα chip των 20 ακροδεκτών µε 8 συνδεδεµένα D Flip-Flop που σχηµατίζουν έναν καταχωρητή (register) των 8 bit.
Συνδέοντας 2 τέτοια chip παράλληλα µπορούµε να δηµιουργήσουµε έναν καταχωρητή των 16 bit κ.ο.κ.
Ολοκληρωµένο κύκλωµα (a) µε δύο ανεξάρτητα δισταθή κυκλώµατα D και (b) καταχωρτής 8 bit µε συνδυασµό 8 δισταθών κυκλωµάτων D
Γενικά για τους Μικροεπεξεργαστές
Οι Μικροεπεξεργαστές (Microprocessors) είναι κυκλώµατα LSI/VLSI που περιέχουν µεγάλο αριθµό ψηφιακών κυκλωµάτων οµαδοποιηµένα σε υποµονάδες.
Εκτελούν βασικές αριθµητικές και λογικές λειτουργίες καθώς και λειτουργίες ελέγχου και µεταφορά δεδοµένων από/προς τη µνήµη και τις περιφερειακές συσκευές.
Καθοδηγούνται από σειρές εντολών γλώσσας µηχανής (πρόγραµµα) που συντάσσονται µε βάση ένα πεπερασµένο σετ εντολών, ειδικό για κάθε µικροεπεξεργαστή.
Χαρακτηρίζονται από το εύρος του διαύλου δεδοµένων (µήκος λέξης) που ταυτίζεται µε το µέγεθος των βασικών καταχωρητών και είναι 4, 8, 16, 32, 64, 128 bit, … Χαρακτηρίζονται από την µέγιστη συχνότητα λειτουργίας τους (100KHz .. 10GHz) που καθορίζεται από ένα κύκλωµα χρονισµού (clock).
Στη συσκευασία τους έχουν µεγάλο αριθµό pin (16...478) για σύνδεση µε την τροφοδοσία, τους διαύλους, τις γραµµές ελέγχου και διακοπών και τις υπόλοιπες υποµονάδες ενός Οι µικροεπεξεργαστές (Μ/Ε) εκτοπίζουν τα παραδοσιακά ηλεκτρονικά από σχεδόν κάθε πεδίο που περιλαµβάνει προγραµµατισµό ή αυτόµατο έλεγχο.
Έτσι, εκτός από την κατασκευή Η/Υ χρησιµοποιούνται σε οικιακές συσκευές, συσκευές γραφείου, ηλεκτρονικά παιγνίδια, στην αυτοκινητοβιοµηχανία κ.α.
Τα πλεονεκτήµατα που παρουσιάζουν οι Μ/Ε έναντι άλλων λύσεων είναι : 9 Λιγότερα εξαρτήµατα, γεγονός που σηµαίνει µικρότερος όγκος, µειωµένη κατανάλωση ενέργειας και µεγαλύτερη αξιοπιστία 9 ∆υνατότητα προγραµµατισµού, γεγονός που σηµαίνει απλοποίηση του σχεδιασµού, µικρότερος χρόνος ανάπτυξης και δυνατότητα µετατροπών
Η ιστορία των Μ/Ε ξεκινά µε τον 4-bit Μ/Ε 4004 της Intel το 1971.
Το chip αποτελούνταν από 2.300 τρανζίστορ και εκτελούσε περίπου 60.000 πράξεις/sec.
Προορίζονταν για την υλοποίηση υπολογιστών τσέπης (calculator) αλλά αποτέλεσε µεγάλη εµπορική επιτυχία και άνοιξε το δρόµο για την δηµιουργία των µικροϋπολογιστών.
Η Intel εξέλιξε τη σειρά των Μ/Ε της και κυριαρχεί στο χώρο αυτό µέχρι σήµερα µε τη σειρά 80X86 και αργότερα τη σειρά των Pentium.
Άλλη µια σειρά που γνώρισε εµπορική επιτυχία είναι η σειρά 68X00 της Motorola.
∆ιάφορες άλλες σχεδιάσεις εµφανίστηκαν µε επιτυχία για κάποιες περιόδους στην αγορά αλλά δεν συνέχισαν να εξελίσσονται, όπως ο Z-80 της Zilog, ο 6502 της Rockwell κ.α.
Για να έχει ο αναγνώστης ένα µέτρο σύγκρισης, θα πρέπει να αναφέρουµε ότι οι σύγχρονοι Μ/Ε έχουν περισσότερα από 500.000.000 (500 εκατοµµύρια) τρανζίστορ και εκτελούν µερικές δεκάδες εκατοµµύρια πράξεις/sec.
Στον επόµενο πίνακα παρατίθενται συγκριτικά τα στοιχεία των πρώτων ιστορικών Μ/Ε
Ονοµα Ετος MHz Tρανζίστορ Μνήµη Σχόλια 8080 1974 2 6.000 64K Πρώτος µ/ε γενικής χρήσης 80286 1982 8-12 134.000 16M Αύξηση χώρου διευθύνσεων σε 16Μ και προστασία µνήµης
Pentium 1993 60-233 3.1 M 4GB ∆ύο γραµµές διοχέτευσης Pentium Pro 1995 150-200 5.5 M 4GB ∆ύο επίπεδα ενσωµατωµένης µνήµης cache Pentium II 1997 233-400 7.5 M 4GB Pentium Pro µε MMX
Ονοµα Ετος Πλάτος Καταχωρητών 68000 1979 32 4 16Μ Πρώτο µέλος της οικογένειας 68010 1983 32 16 16Μ Υποστήριξη εικονικής µνήµης 68030 1987 32 32 4G On-Chip διαχείριση µνήµης
Εσωτερική δοµή µικροεπεξεργαστων
Μπλόκ διάγραµµα του εσωτερικού ενός µικροεπεξεργαστή µε τα βασικά του µέρη
Αν και οι Μ/Ε αποτελούν πολύπλοκα ψηφιακά κυκλώµατα στην σχεδίαση αλλά και στην υλοποίηση τους, και κάθε Μ/Ε είναι σίγουρα διαφορετικός από τους άλλους, ωστόσο όλοι οι Μ/Ε αποτελούνται από κάποια στάνταρ µέρη, που είναι τα ακόλουθα : Καταχωρητές (Registers) : αποτελούν µικρές µνήµες µίας λέξης µε µέγεθος ίδιο µε αυτό της κλάσης του µικροεπεξεργαστή.
Οι καταχωρητές χρησιµοποιούνται για την προσκόµιση δεδοµένων µέσα στον επεξεργαστή από τη µνήµη και τις περιφερειακές συσκευές, για την τροφοδοσία των αριθµητικών και λογικών µονάδων µε δεδοµένα για την εκτέλεση πράξεων, καθώς επίσης και για την αποθήκευση ενδιάµεσων και τελικών αποτελεσµάτων.
Πρακτικά σε ένα πρόγραµµα γλώσσας µηχανής οι καταχωρητές είναι για τον προγραµµατιστή οι µόνιµες µεταβλητές του προγράµµατος τις οποίες µπορεί να Αριθµητική και Λογική Μονάδα (Arithmetic and Logic Unit – ALU ) : µονάδα που εκτελεί αριθµητικές και λογικές πράξεις (+, -, AND, OR, ..) Μονάδα Κινητής Υποδιαστολής (Floating Point Unit – FPU) : µονάδα που εκτελεί πράξεις κινητής υποδιαστολής (µε δεκαδικά).
Μονάδα Ελέγχου (Control Unit) : Η µονάδα αυτή, είναι η πιο σηµαντική µονάδα µέσα σε έναν µικροεπεξεργαστή καθώς αποτελεί τον «εγκέφαλο» του συστήµατος.
Είναι υπεύθυνη για την ακολουθιακή εκτέλεση των βηµάτων που απαιτούνται για την ολοκλήρωση των εντολών γλώσσας µηχανής, τη λήψη και αποστολή σηµάτων ελέγχου στον εξωτερικό κόσµο (µητρική κάρτα – µνήµη – περιφερειακές συσκευές), και τον συντονισµό όλων των επιµέρους τµηµάτων ενός µικροεπεξεργαστή.
Εσωτερικός δίαυλος δεδοµένων
Εξωτερικός δίαυλος διευθύνσεων Εξωτερικός δίαυλος δεδοµένων
Περιλαµβάνει τον καταχωρητή εντολής (Instruction Register – IR), τον αποκωδικοποιητή εντολής (Decoder) και ROM µικροκώδικα για την εκτέλεση των εντολών.
∆έχεται είσοδο από το ρολόι και τις γραµµές διακοπών (Interrupts).
Εσωτερικός δίαυλος δεδοµένων (Internal Data Bus) : γραµµή µίας λέξης που ενώνει εσωτερικά τους καταχωρητές και τις υποµονάδες.
Ενώνεται µε τον εξωτερικό δίαυλο δεδοµένων (External Data Bus) προς τη µνήµη και τις περιφερειακές συσκευές.
Ενδιάµεση Μνήµη επιπέδου 1 (Level 1 Cache memory) : µικρή µνήµη που λειτουργεί ως buffer ανάµεσα στην RAM και την CPU.
Τα βασικά µέρη ενός µικροεπεξεργαστή
Οι καταχωρητές είναι µνήµες µίας λέξης (data) ή εύρους διευθύνσεων (address).
Υλοποιούνται µε Flip-Flop µεγάλης ταχύτητας.
Μεταφέρουν δεδοµένα από και προς το Data Bus.
Υπάρχουν δύο κατηγορίες καταχωρητών :
Καταχωρητές γενικής χρήσης : εκτελούν όλες τις δυνατές λειτουργίες (πράξεις, µεταφορά δεδοµένων).
Συνδέονται άµεσα µε την ALU, την FPU και το Data Bus.
Ενώ όλοι οι καταχωρητές γενικής χρήσης είναι ισοδύναµοικ, συνήθως ένας από τους καταχωρητές γενικής χρήσης είναι «πιο ίσος» από τους άλλους.
Αυτός συνήθως ονοµάζεται «Συσσωρευτής» (Accumulator), και έχει µεγαλύτερα προνόµια από τους υπόλοιπους.
Αυτό σηµαίνει ότι υπάρχουν πράξεις και εντολές που εκτελούνται µόνο µε τον συσσωρευτή αλλά και το ότι οι εντολές που χρησιµοποιούν τον συσσωρευτή συνήθως είναι µικρότερες σε αριθµό byte.
Στον επεξεργαστή 8088 τον ρόλο του συσσωρευτή έχει ο ΑΧ.
Οι καταχωρητές γενικής χρήσης συνήθως χρησιµοποιούνται για όλες της εργασίες όπως : αριθµητικές πράξεις, λογικές πράξεις, συγκρίσεις,
Καταχωρητές ειδικής χρήσης : Οι Καταχωρητές ειδικής χρήσης έχουν συγκεκριµένο ρόλο µέσα στον επεξεργαστή.
Υπάρχουν όµως πολλά είδη καταχωρητών ειδικής χρήσης a.
Καταχωρητές ∆ιευθύνσεων (Address Registers): Καταχωρούν διευθύνσεις που σχετίζονται µε την εκτέλεση των εντολών.
Συνδέονται µε το δίαυλο διευθύνσεων για σχηµατισµό διεύθυνσης.
Συνδέονται και µε το Data Bus για φόρτωση διευθύνσεων από την µνήµη. i.
∆είκτης Εντολής (Instruction Pointer – IP) : ειδικός καταχωρητής διεύθυνσης που φυλάσσει την διεύθυνση εκτέλεσης της επόµενης εντολής.
Αυξάνεται αυτόµατα από τη µονάδα ελέγχου.
Εξάγεται στο Address Bus για να προσκοµιστεί η επόµενη ii.
Καταχωρητές ∆είκτη (Index Register): χρησιµοποιούνται για προσπέλαση της µνήµης υπό τη µορφή πίνακα.
Περιέχουν είτε τη διεύθυνση βάσης (προστίθεται η µετατόπιση) ή την µετατόπιση (προστίθεται η διεύθυνση βάσης). iii.
Καταχωρητές Τµηµάτων (Segment Registers): κρατούν διευθύνσεις τµηµάτων κώδικα, δεδοµένων, στοίβας και έξτρα τµήµαστος.
Σχηµατίζουν διευθύνσεις µαζί µε τους καταχωρητές δεικτών που έχουν το offset κοµµάτι της διεύθυνσης. iv.
∆είκτης Στοίβας (Stack Pointer – SP) : περιέχει την διεύθυνση κορυφής της στοίβας (Stack).
Η στοίβα είναι συγκεκριµένη περιοχή µνήµης µε δοµή LIFO που γεµίζει από πάνω προς τα κάτω.
Χρησιµοποιείται για προσωρινή αποθήκευση της κατάστασης της CPU πριν από την εκτέλεση υπορουτινών.
Την διαχειριζόµαστε µε εντολές PUSH και POP. b.
Καταχωρητής Εντολής (Instruction Register-IR): περιέχει τον κώδικα της εντολής που θα εκτελεστεί.
Είναι µέρος της µονάδας ελέγχου και συνδέεται µε το Data Bus. c.
Καταχωρητής Σηµαιών (Flag Register-FG): καταχωρητής που αποτελείται από µεµονωµένα bits που λειτουργούν ως σηµαίες κατάστασης (flags).
Οι σηµαίες διαµορφώνονται µετά από την εκτέλεση κάθε εντολής και εξαρτώνται από το αποτέλεσµα της εντολής.
Ορισµένα bits λειτουργούν και ως διακόπτες που ενεργοποιούν / απενεργοποιούν λειτουργίες.
Ελέγχεται από εντολές διακλάδωσης JE, JNE, JL, JLE, JNL,JNLE...
Τα bit του καταχωρητή σηµαιών Τα bit του καταχωρητή σηµαιών στον 8088 είναι τα ακόλουθα: i. (CY) Carry – Κρατούµενο : αποθηκεύει το επιπλέον bit που µπορεί να προκύψει από αριθµητικές πράξεις (κρατούµενο – δανεικό).
Μπορεί να χρησιµοποιηθεί για πράξεις αριθµών πολλαπλών λέξεων (Add with Carry – Carry Propagation).
Επίσης αποθηκεύει το bit υπερχείλισης σε εντολές ολίσθησης και περιστροφής.
Μπορεί να τεθεί 1 ή 0 µε ειδικές εντολές : STC, CLC, CMC.
Ελέγχεται από εντολές διακλάδωσης JB/JNAE, JBE/JNA, JNB, JAE, JNBE/JA. ii. (PF) Parity – Ισοτιµία : γίνεται 1 όταν το αποτέλεσµα µίας πράξης είναι δυαδικός αριθµός που έχει ζυγό αριθµό µονάδων.
Ελέγχεται από εντολές διακλάδωσης iii. (AF) Auxiliary Carry–Βοηθητικό Κρατούµενο : γίνεται 1 όταν σε µία πράξη µεταφέρεται κρατούµενο από το byte χαµηλής τάξης στο byte υψηλής τάξης (low iv. (ΖF) Zero – Μηδενικό : γίνεται 1 όταν το αποτέλεσµα οποιασδήποτε εντολής δώσει αποτέλεσµα 0.
Ελέγχεται µε εντολές διακλάδωσης JE/JZ, JNE/JNZ, v. (SF) Sign – Αρνητικό : γίνεται 1 όταν το αποτέλεσµα οποιασδήποτε πράξης δώσει αποτέλεσµα αρνητικό µε την σύµβαση συµπληρώµατος ως προς 2 (MSB=1).
Ελέγχεται από εντολές διακλάδωσης JS, JNS, JL/JNGE, JLE/JNG, JNL/JGE, vi. (TF) Trap – Παγίδευση : Σηµαία Βηµατικής Εκτέλεσης, όταν είναι 1 εκτελεί τις εντολές βήµα-βήµα για debugging.
Μπορεί να αλλάξει µε τη βοήθεια των εντολών PUSHF και POPF ως εξής: PUSHF Σώζει τον FG στο Stack POP AX Τον αντιγράφει στον AX PUSH AX Σώζει την νέα τιµή στο stack POPF Την αντιγράφει στον FG Όταν η σηµαία είναι «1» τότε στην αρχή της εκτέλεσης κάθε εντολής γλώσσας µηχανής ο 8088 παράγει το Interrupt 01h.
Έτσι αν εµείς έχουµε αλλάξει την διεύθυνση του Interrupt 01h και έχουµε βάλει διεύθυνση δικής µας ρουτίνας, µπορούµε πριν από κάθε εκτέλεση εντολής να παρεµβάλλεται δικός µας κώδικας για διαδικασίες debugging.
Η παραπάνω τεχνική µας επιτρέπει να εκτελούµε ένα πρόγραµµα βήµα-βήµα, και ενδιάµεσα να µπορούµε να βλέπουµε π.χ. τις τιµές των καταχωρητών, της µνήµης κ.λ.π.
Όταν η σηµαία είναι «0» τότε ∆ΕΝ παράγεται το Interrupt 01h στην αρχή εκτέλεσης κάθε εντολής. vii. (IF) Interrupt – ∆ιακοπή : όταν είναι 1 επιτρέπει την διακοπή του προγράµµατος από Interrupt (Interrupt Request) για την εκτέλεση συγκεκριµένης ρουτίνας εξυπηρέτησης της διακοπής.
Όταν είναι 0 απαγορεύει τις διακοπές.
Αλλάζει µε εντολές CLI, STI. viii. (DF) Direction – Κατεύθυνση : όταν είναι 1, οι STOSB, CMPSB, κ.λ.π.) εκτελούνται από υψ δηλαδή ανάποδα από το κανονικό που ισχύει για ix. (OF) Overflow – Υπερχείλιση : Σηµαία Υ αποτέλεσµα µίας πράξης ξεπερνά το όριο των π 32768…+32767.
Ελέγχεται µε εντολές δια
Οι εσωτερικοί καταχωρητές του µικροεπεξεργαστ Οι εσωτερικοί καταχωρητές δεν είναι προσπελάσιµ αλλά εξυπηρετούν την εσωτερική λειτουργία του µι εσωτερικοί καταχωρητές σε έναν µικροεπεξεργαστή είναι :
εντολές των string (π.χ.
LODSB, ηλές διευθύνσεις προς χαµηλές, DF=0.
Αλλάζει µε εντολές CLD, περχείλισης, γίνεται 1 όταν το ροσηµασµένων αριθµών δηλαδή - κλάδωσης JO, JNO, JL/JNGE, οι από εντολές γλώσσας µηχανής, κροεπεξεργαστή.
Οι πιο κοινοί Memory Data Register (MDR): καταχωρητής µίας λέξης που αποθηκεύει την πληροφορία που εισέρχεται στον Μ/Ε από το Data Bus.
Είναι στην ουσία ο «πορτιέρης» του διαύλου δεδοµένων.
Οτιδήποτε εισέρχεται στον µικροεπεξεργαστή από τον δίαυλο δεδοµένων αποθηκεύεται πρώτα σε αυτόν.
Επίσης οτιδήποτε εξέρχεται από τον µικροεπεξεργαστή προς τον δίαυλο δεδοµένων αποθηκεύεται πρώτα σε αυτόν.
Αποτελεί στην ουσία buffer διασύνδεσης του Μ/Ε µε τον δίαυλο δεδοµένων.
Στον 8088 έχει µέγεθος 8 bit, όσα και ο δίαυλος δεδοµένων.
Memory Address Register (MAR): καταχωρητής εύρους διεύθυνσης στον οποίο καταχωρείται η σχηµατιζόµενη διεύθυνση µνήµης για να προωθηθεί στο address bus.
Είναι στην ουσία ο «πορτιέρης» του διαύλου διευθύνσεων.
Οποιαδήποτε διεύθυνση σχηµατίζει ο Μ/Ε στον δίαυλο διευθύνσεων αποθηκεύεται πρώτα σε αυτόν.
Αποτελεί στην ουσία buffer διασύνδεσης του Μ/Ε µε τον δίαυλο διευθύνσεων.
Στον 8088 έχει µέγεθος 20 bit όσα και ο δίαυλος διευθύνσεων.
Address Data Register (ADR): καταχωρητής εύρους διεύθυνσης στον οποίο καταχωρείται µέσω του Data Bus και του MDR η διεύθυνση που είναι παράµετρος µίας εντολής (π.χ. η 0200 στην εντολή ADD AX, [0200]).
Έχει µέγεθος 16 bit.
Effective Address Register (EAR): καταχωρητής εύρους διεύθυνσης στον οποίο υπολογίζονται οι τελικές διευθύνσεις µνήµης µε δεικτοδοτούµενες και έµµεσες διευθυνσιοδοτήσεις π.χ. στην εντολή ADD AX, [1234+SI] αποθηκεύει το αποτέλεσµα της πρόσθεσης 1234+SI που εκτελείται στην ALU.
Έχει µέγεθος 16 bit.
Scratch Pad Register (SCR) : καταχωρητής προχείρου µε εύρος ίδιο µε αυτό των υπόλοιπων καταχωρητών γενικής χρήσης (16 bit στον 8088).
Χρησιµοποιείται για καταχώρηση παραµέτρων των 16 bit που δεν χωράνε εξ’ ολολκήρου στον MDR.
Συνήθως στους Μ/Ε υπάρχουν περισσότεροι του ενός καταχωρητές προχείρου που αποθηκεύουν ενδιάµεσα αποτελέσµατα και έτσι βοηθάνε στην εκτέλεση των σύνθετων εντολών, χωρίς να χρειαστεί να χρησιµοποιηθεί η µνήµη RAM για τον σκοπό αυτό, η οποία είναι πολύ πιο αργή στην απόκριση απ’ ότι οι καταχωρητές του Μ/Ε.
Στο µπλοκ διάγραµµα φαίνεται ότι οι καταχωρητές διευθύνσεων όπως είναι ο ADR ο EAR, ο SP και ο IP συνδέονται απευθείας στον καταχωρητή MAR.
Βέβαια σύµφωνα µε τα παραπάνω οι καταχωρητές ADR, EAR, SP και IP έχουν µέγεθος 16 bit, ενώ o καταχωρητής MAR έχει µέγεθος 20 bits.
Εδώ λοιπόν υπάρχει µια ανακολουθία.
Πώς δηλαδή οι καταχωρητές µεγέθους 16 bits αποθηκεύονται στον καταχωρητή MAR των 20 bits που σχηµατίζει µέσα του την τελική διεύθυνση µνήµης που θα προσπελαστεί από 0 έως 1 ΜΒ;
Η απάντηση είναι απλή αν σκεφτούµε τη µέθοδο σχηµατισµού διευθύνσεων που ισχύει στον επεξεργαστή 8088 και που δεν είναι άλλη από την µέθοδο segment:offset.
Στην ουσία το περιεχόµενο των καταχωρητών ADR, EAR, SP και IP είναι το offset κοµµάτι της διεύθυνσης.
Αυτό πρέπει να συνδυαστεί µε το κατάλληλο segment κοµµάτι ώστε να µας δώσει την τελική διεύθυνση.
Όταν οι καταχωρητές ADR και EAR περιέχουν διεύθυνση δεδοµένων και εξάγονται στον MAR για προσπέλαση των δεδοµένων αυτών, για παράδειγµα στην εντολή: ADD AX, [1234], όπου ο ADR θα αποθηκεύσει µέσω του MDR την διεύθυνση 1234, SUB BX, [5678+SI] , όπου ο EAR θα αποθηκεύσει το αποτέλεσµα της πρόσθεσης τότε, οι καταχωρητές αυτοί (ADR ή EAR) θα συνδυαστούν µε τον καταχωρητή τµήµατος DS, δηλαδή η τελική διεύθυνση των 20 bit που θα προωθηθεί στον MAR θα προκύψει ως MAR = DS : ADR = DS * 16 + ADR, ή
Στην περίπτωση του καταχωρητή IP τα πράγµατα είναι πιο απλά.
Ο καταχωρητής αυτός πάντα περιέχει την διεύθυνση της επόµενης εντολής που θα εκτελεστεί, και εποµένως αφού αφορά το τµήµα κώδικα, συνδυάζεται πάντα µε τον CS register, δηλαδή :
Επίσης στην περίπτωση του καταχωρητή SP, που «δείχνει» πάντα την κορυφή της στοίβας (stack), αυτός πάντα συνδυάζεται µε τον καταχωρητή τµήµατος SS (Stack Segment register) :
Η Αριθµητική και Λογική Μονάδα Η Αριθµητική και Λογική Μονάδα (Arithmetic and Logic Unit – ALU) είναι υπεύθυνη για την εκτέλεση αριθµητικών πράξεων σε ακεραίους, καθώς και λογικών πράξεων (AND, OR, XOR, …) και συγκρίσεων, όπως και εκτέλεση πράξεων ολίσθησης και περιστροφής.
Εκτελεί πρόσθεση, αφαίρεση, ενδεχοµένως και πολλαπλασιασµό και διαίρεση, πράξεις της άλγεβρας Boole, όπως AND, OR, XOR, NOT, ολίσθηση (shift) ή περιστροφή (rotation) δεξιά ή αριστερά.
Περιέχει τα κατάλληλα ψηφιακά κυκλώµατα για την εκτέλεση των πράξεων αυτών, όπως συστοιχία πλήρων αθροιστών (full-adders), Ολισθητές (shifters), και συστοιχίες πυλών για εκτέλεση λογικών πράξεων.
Επίσης περιέχει δύο εισόδους δεδοµένων A και B για την προσκόµιση των αριθµών που θα συµµετέχουν στην πράξη, καθώς και µία είσοδο εντολής στην οποία η CPU τοποθετεί ένα κατάλληλο κωδικό αριθµό για να καθορίσει το τι πράξη θα γίνει.
Στο παρακάτω σχήµα φαίνεται χονδρικά η δοµή µίας ALU µε τις δύο εισόδους δεδοµένων Α και Β και την έξοδο του αποτελέσµατος.
Στην απλούστερη περίπτωση, όπως αυτή του παρακάτω σχήµατος, µπορούν να περιέχουν ένα µόνο σύνθετο κύκλωµα που εκτελεί τις πράξεις AND, OR, NOT και την αριθµητική πρόσθεση, µεταξύ 2 bit εισόδου.
Για πράξεις σε λέξεις των n bits συνδέονται n τέτοια
Παράδειγµα απλής ALU που µπορεί να κάνει 4 πράξεις σε δεδοµένα του 1 bit.
Από το σετ εντολών ου 8088 ένα µεγάλο µέρος αυτών, οι Εντολές Αριθµητικών και Λογικών Πράξεων καθώς και οι Εντολές Ολίσθησης και Περιστροφής, εκτελούνται στην ALU.
Τέτοιες εντολές είναι για παράδειγµα οι ακόλουθες:
Μονάδα Κινητής Υποδιαστολής (Floating Point Unit – FPU) Η Μονάδα Κινητής Υποδιαστολής (Floating Point Unit – FPU) εκτελεί πράξεις µε Οι δεκαδικοί αριθµοί που χειρίζεται η FPU ακολουθούν συγκεκριµένη κωδικοποίηση που αναλύεται σε επόµενο κεφάλαιο, και στην ουσία αποτελείται από έναν αριθµό «βάσης» που είναι δυαδικός προσηµασµένος ακέραιος αλλά θεωρείται κατά σύµβαση ότι κατά απόλυτη τιµή είναι στην περιοχή 0..1, και από έναν προσηµασµένο ακέραιο «εκθέτη» που καθορίζει το πραγµατικό µέγεθος του αριθµού.
∆ηλαδή η κωδικοποίηση είναι ως εξής :
Ο προσηµασµένος εκθέτης µπορεί να µας δώσει πολύ µικρούς αριθµούς (αρνητικοί εκθέτες) ή πολύ µεγάλους αριθµούς (θετικοί εκθέτες).
H FPU µπορεί να εκτελεί αλγεβρικές πράξεις µε δεκαδικούς αριθµούς όπως πρόσθεση, αφαίρεση πολλαπλασιασµό και διαίρεση.
Επίσης µπορεί να εκτελεί πράξεις σύγκρισης, όπως ==, >=, <=, !=, όπως επίσης και έλεγχο για άπειρο (INF) ή για η αποδεκτούς αριθµούς (NAN – Not A Number).
Έχει δικές της εντολές που αναγνωρίζει και τις οποίες οδηγεί η µονάδα ελέγχου στην FPU για την εκτέλεση της σωστής πράξης.
Επίσης έχει και δικούς της καταχωρητές για καταχώρηση των αριθµών που θα συµµετέχουν στην πράξη ή θα αποθηκεύσουν ενδιάµεσα αποτελέσµατα (data registers), όπως επίσης και καταχωρητές που αντανακλούν την κατάσταση της FPU ή του αποτελέσµατος της πράξης (status registers).
Στο παρακάτω σχήµα φαίνεται η εικόνα ενός µπλόκ διαγράµµατος µιας απλής FPU.
Μπλοκ διάγραµµα απλής FPU
Στο διάγραµµα αυτό φαίνονται καθαρά οι γραµµές προσκόµισης των δύο αριθµών που θα συµµετέχουν στην πράξη και που φαίνονται στο διάγραµµα µε τα ονόµατα op1 και op2.
Επίσης φαίνεται η είσοδος της εντολής για την πράξη που θα εκτελέσει η µονάδα κινητής υποδιαστολής (operation type).
Επίσης φαίνεται η µονάδα εκτέλεσης των πράξεων (calculation unit) όπως και η µονάδα που κάνει τις συγκρίσεις (Compare).
Τα αποτελέσµατα των µονάδων αυτών καταχωρούνται σε ειδικούς καταχωρητές αποτελεσµάτων όπως και καταχωρητές κατάστασης (status).
Στην επόµενη εικόνα φαίνεται το µπλοκ διάγραµµα µιας πιο σύνθετης µονάδας κινητής υποδιαστολής.
Στη µονάδα αυτή είναι εµφανές ότι υπάρχουν δύο ανεξάρτητοι αγωγοί προσκόµισης εντολών µε τις ονοµασίες Instruction 1 και Instruction 2.
Οι δύο αυτοί αγωγοί επιτρέπουν την ταυτόχρονη προσκόµιση δύο εντολών στη µονάδα.
Εφόσον οι εντολές αυτές είναι ανεξάρτητες µεταξύ τους µπορεί και να εκτελεστούν παράλληλα.
Έτσι αυξάνεται η αποδοτικότητα της µονάδας στην ταχύτητα εκτέλεσης εντολών.
Η κωδικοποίηση των δεκαδικών αριθµών
Οι δεκαδικοί αριθµοί στους Η/Υ ακολουθούν συγκεκριµένη κωδικοποίηση που καθιερώθηκε το 1985 µε το στάνταρ IEEE 754, το οποίο και υποστηρίζεται από την µεγάλη πλειοψηφία των µικροεπεξεργαστών παγκοσµίως.
Πριν εµβαθύνουµε στην κωδικοποίηση των δεκαδικών, θα αναλύσουµε την δυαδική κωδικοποίηση των κλασµατικών αριθµών.
Όπως ένας ακέραιος µπορεί να παρασταθεί ως δυαδικός αριθµός, π.χ. ο αριθµός 17910 αντιστοιχεί στον δυαδικό αριθµό 1 0 1 1 0 0 1 1 2 , το οποίο φαίνεται παραστατικά σύµφωνα µε την παρακάτω αναλυση :
Συµβολή των bits 1x27 0x26 1x25 1x24 0x23 0x22 1x21 1x20 έτσι κατ’ επέκταση µπορούµε να έχουµε και δυαδικούς αριθµούς που να περιλαµβάνουν δεκαδική τελεία.
Σε ένα τέτοιο αριθµό, τα ψηφία στα δεξιά της τελείας πολλαπλασιάζονται µε αρνητικές δυνάµεις του 2.
Για παράδειγµα ο δυαδικός κλασµατικός αριθµός : 1 0 1 1 . 1 0 1 0 1 αναπαριστά τον αριθµό :
Γενικά ένας κλασµατικός δυαδικός αριθµός της µορφής : αναπαριστά τον αριθµό:
Παραδείγµατα δυαδικών κλασµατικών αριθµών :
Προφανώς η µετατόπιση (shift) ενός κλασµατικού δυαδικού αριθµού προς τα αριστερά πολλαπλασιάζει τον αριθµό επί 2, ενώ η µετατόπιση προς τα δεξιά τον διαιρεί δια 2.
Ο αριθµός 0.11111111111111…….2 προφανώς τείνει στην µονάδα χωρίς ποτέ βέβαια να την φτάνει, δηλαδή ταυτίζεται µε τον αριθµό 0.99999999999999……10.
Για τον λόγο αυτό συµβολίζεται ως «1.0-ε» όπου «ε» ένας πολύ µικρός αριθµός.
Η αναπαράσταση αυτή έχει βέβαια και κάποιους περιορισµούς.
Ο βασικός περιορισµός είναι ότι µπορεί να αναπαραστήσει µε πεπερασµένο πλήθος ψηφίων µόνο αριθµούς της µορφής X/2k, δηλαδή αριθµούς οι οποίοι µας δίνουν ακέραιο αριθµό χωρίς κλασµατικό µέρος όταν πολλαπλασιαστούν µε κάποια δύναµη του 2 (2k).
Έτσι οι αριθµοί όπως 1/3 = 0.3333333, ή 1/5 = 0.2, κ.λ.π. αναπαρίστανται µε άπειρα επαναλαµβανόµενα ψηφία στο δεκαδικό µέρος του αριθµού : Αναπαράσταση αριθµών κινητής υποδιαστολής Με βάση τους κλασµατικούς αριθµούς που αναλύθηκαν παραπάνω κτίζεται και η αναπαράσταση των αριθµών κινητής υποδιαστολής που χρησιµοποιείται στους Η/Υ. η αναπαράσταση αυτή αποτελείται από 3 µέρη όπως φαίνεται παρακάτω:
S : είναι το bit προσήµου (sign bit) που παίρνει τιµές 0 για θετικό πρόσηµο (+) και 1 για αρνητικό πρόσηµο (-) Ε : είναι ένας ακέραιος εκθέτης στον οποίο υψώνεται το 2 για να δηµιουργήσει µία δύναµη του 2 που πολλαπλασιάζει τον αριθµό.
Εκφράζει το µέγεθος του αριθµού δηλαδή το πόσο µεγάλος ή µικρός είναι ο αριθµός.
Μεγάλα θετικά νούµερα δηµιουργούν πολύ µεγάλους αριθµούς, ενώ µεγάλα αρνητικά νούµερα δηµιουργούν πολύ µικρούς αριθµούς.
Ονοµάζεται Exponent δηλαδή εκθέτης.
Μ : είναι ένας κλασµατικός αριθµός στην περιοχή 1.0 ≤ M ≤ 2.0 που καθορίζει τα σηµαντικά ψηφία του αριθµού (την ακρίβεια του αριθµού) και ονοµάζεται Mantissa
Τυπικά ο αριθµός που κωδικοποιείται µε τα 3 αυτά πεδία είναι ο αριθµός Για να κωδικοποιήσουµε έναν αριθµό κινητής υποδιαστολής µε αυτό τον τρόπο κάνουµε τα
Μετατρέπουµε τον αριθµό σε κλασµατικό δυαδικό
Τον µετατοπίζουµε δεξιά (διαίρεση δια 2) τόσες φορές όσες χρειάζεται ώστε να έρθει στην µορφή 1.ΧΧΧΧΧΧ…, δηλαδή να υπάρχει µόνο µία µονάδα στα αριστερά της δεκαδικής τελείας και όλο το υπόλοιπο νούµερο να είναι στα αριστερά της
Υπολογίζουµε πόσες µετατοπίσεις κάναµε και το νούµερο αυτό αποτελεί τον εκθέτη.
Παράδειγµα ο αριθµός 51.984375 θα κωδικοποιηθεί µε τα ακόλουθα βήµατα:
Μετατρέπεται σε κλασµατικό δυαδικό και γίνεται 110011.111111
Μετατοπίζεται 5 φορές στα δεξιά και γίνεται 1.10011111111
Επειδή η Mantissa πάντα είναι της µορφής 1.ΧΧΧΧΧΧΧ…, η µονάδα στα αριστερά της δεκαδικής τελείας δεν αποθηκεύεται στον αριθµό αλλά εννοείται, καθώς δεν αποτελεί πληροφορία που πρέπει να αποθηκευθεί.
Έτσι στην κωδικοποίηση αυτή κερδίζουµε 1 bit στην ακρίβεια του αριθµού.
∆ηλαδή αντί για τον αριθµό M= 1.10011111111 αποθηκεύεται ο αριθµός M= 0.10011111111, δηλαδή τελικά µε την αφαίρεση του «0.» το οποίο δεν χρειάζεται, ο αριθµός Μ που αποθηκεύεται θα είναι M= 10011111111.
Στον αριθµό αυτό εννοείται ότι προηγείται η µονάδα και η δεκαδική τελεία.
Επίσης για να µπορούµε να καταχωρούµε και αρνητικούς εκθέτες οι εκθέτες αποθηκεύονται µε ένα offset ή bias το οποίο τυπικά είναι offset=+127.
∆ηλαδή οι αριθµοί εκθετών από Ε=0 έως Ε=126 αντιστοιχούν στους πραγµατικούς εκθέτες -127 έως -1, ο αριθµός εκθέτη Ε=127 αντιστοιχεί σε µηδενικό εκθέτη, και οι αριθµοί εκθετών Ε=128 έως Ε=254 αντιστοιχούν στους πραγµατικούς εκθέτες +1 έως +127.
Ο αριθµός εκθέτη Ε=255 είναι δεσµευµένος για να κωδικοποιήσει την τιµή του άπειρου (infinite ή ∞).
Έτσι ο αριθµός του παραπάνω παραδείγµατος θα κωδικοποιηθεί τελικά ως εξής :
S=0 δηλαδή ο αριθµός είναι θετικός E=100001002 = 13210=(127+5) δηλαδή ο εκθέτης είναι 5 (127 είναι το offset ή bias) Και ο αριθµός που σχηµατίζεται είναι ο :
Τύποι και µεγέθη δεκαδικών αναπαραστάσεων Υπάρχουν τρεις τύποι δεκαδικών αναπαραστάσεων που διαφέρουν στο πλήθος των bits που προβλέπουν για κάθε κοµµάτι του κωδικοποιηµένου αριθµού.
Έτσι έχουµε τους τύπους : Τύπος Bits Εκθέτη Bits Mantissa Σύνολο Bits (µαζί µε Single precision (τύπος float
Double precision (τύπος double στην γλώσσα C) (χρησιµοποιείται µόνο από (ένα bit δεν
Μερικές χαρακτηριστικές τιµές στην κωδικοποίηση των αριθµών είναι οι ακόλουθες: 0 ή 1 255 Οποιαδήποτε τιµή ΝΑΝ (Not A Number)
Παρακάτω φαίνεται ένας πίνακας της Intel που αναφέρει πιο αναλυτικά τις τιµές αυτές στην κωδικοποίηση των αριθµών κινητής υποδιαστολής:
Πίνακας της Intel για την κωδικοποίηση των αριθµών κινητής υποδιαστολής
Πράξεις µεταξύ δεκαδικών αριθµών Οι πράξεις που γίνονται µε τους κωδικοποιηµένους δεκαδικούς αριθµούς γίνονται ακολουθώντας το στάνταρ IEEE 754.
Στην γενική περίπτωση οι δύο αριθµοί που θα συµµετέχουν στην πράξη αποκωδικοποιούνται σε κλασµατικούς δυαδικούς αριθµούς.
Στη συνέχεια πραγµατοποιείται η πράξη επάνω σε αυτούς µε δυαδική αριθµητική.
Το αποτέλεσµα που προκύπτει κανονικοποιείται και µετατρέπεται πάλι σε κωδικοποιηµένο αριθµό κινητής υποδιαστολής.
Σε µερικές περιπτώσεις πράξεων µπορεί όµως η διαδικασία να απλοποιηθεί και να επιταχυνθεί όπως στην περίπτωση της προσθέσεις και της αφαίρεσης.
Η πρόσθεση και ή αφαίρεση δέχονται δύο τελεσταίους αριθµούς που θα συµµετέχουν στην πράξη.
Αν και οι δύο αριθµοί είναι αποδεκτοί δεκαδικοί αριθµοί και δεν ανήκουν σε κάποια από τις ειδικές περιπτώσεις (όπως NAN ή ∞) τότε ακολουθούνται οι παρακάτω κανόνες για την πραγµατοποίηση της πράξης.
Αρχικά συγκρίνονται οι εκθέτες των δύο αριθµών.
Αν οι εκθέτες είναι οι ίδιοι τότε µπορούν άµεσα να προστεθούν τα κοµµάτια των δύο αριθµών που περιέχουν τα σηµαντικά τους ψηφία (mantissa)
Aν το αποτέλεσµα της πράξης είναι συµβατό µε την κωδικοποίηση, δηλαδή είναι 1.0 ≤ M ≤ 2.0, τότε η πράξη έχει ολοκληρωθεί και ο αριθµός του αποτελέσµατος έχει τον ίδιο εκθέτη µε τους αρχικούς τελεσταίους.
Αν το αποτέλεσµα της πράξης δεν είναι συµβατό, δηλαδή Μ<1.0 ή Μ>2.0 τότε θα πρέπει να γίνει µια διαδικασία κανονικoποίησης η οποία θα φέρει την ακρίβεια του αριθµού (mantissa) στα σωστά όρια επηρεάζοντας τον εκθέτη.
Για παράδειγµα αν το αποτέλεσµα 10.10102 και ο εκθέτης ήταν 1012 (510) τότε η mantissa θα γίνει 1.010102 και ο εκθέτης θα αυξηθεί κατά ένα και θα γίνει 1102 (610)
Εάν όµως οι εκθέτες των δύο αριθµών διαφέρουν τότε ο αριθµός µε τον µικρότερο εκθέτη παραµένει ο ίδιος, ενώ αριθµός µε τον µεγαλύτερο εκθέτη πολλαπλασιάζεται επί δύο (αριστερή µετατόπιση) και ο εκθέτης του µειώνεται κατά ένα, τόσες φορές όσες χρειάζεται ώστε να εξισωθούν οι δύο εκθέτες.
Στη συνέχεια η πράξη εξελίσσεται όπως και προηγουµένως Το πρόσηµο του αριθµού καθορίζεται ως εξής.
Αν το αποτέλεσµα είναι µη µηδενικό, τότε το πρόσηµο του αποτελέσµατος ταυτίζεται µε το πρόσηµο του αρχικού αριθµού (τελεσταίου) που είχε τη µεγαλύτερη απόλυτη τιµή.
∆ιαφορετικά εάν το αποτέλεσµα είναι µηδενικό, τότε το πρόσηµο του είναι 0 (θετικό) και το αποτέλεσµα είναι «+0», εκτός εάν και οι δύο αρχικοί αριθµοί ήταν αρνητικοί οπότε γίνεται 1 (αρνητικό) και το αποτέλεσµα είναι «-0».
Η αφαίρεση είναι η ίδια µε την πρόσθεση αρκεί να αλλαχθεί το πρόσηµο του δεύτερου
Οι εκθέτες είναι ίδιοι άρα προστίθενται τα +1.0101 και +1.1010, µε αποτέλεσµα 10.1111 και µαζί µε τον εκθέτη και το πρόσηµο θα είναι +10.1111 x 2101.
Το αποτέλεσµα της mantissa (significand) δεν είναι στα όρια [1.0,2.0) και εποµένως πρέπει να κανονικοποιηθεί.
Έτσι η mantissa θα διαιρεθεί δια 2 (µετατόπιση δεξιά) και ο εκθέτης θα αυξηθεί κατά ένα, δηλαδή 9 Η mantissa θα γίνει 10.1111 Æ 1.01111 , και Το τελικό αποτέλεσµα της πρόσθεσης που είναι επίσης και συµβατό µε την κωδικοποίηση των δεκαδικών αριθµών θα είναι : +1.01111 x 2110
Αρχικά η αφαίρεση θα γίνει πρόσθεση αντιστρέφοντας το πρόσηµο του δεύτερου αριθµού, Οι εκθέτες δεν είναι ίδιοι άρα αυτός µε τον µικρότερο εκθέτη (ο πρώτος) θα παραµείνει αναλλοίωτος.
Ο δεύτερος από τους δύο θα πρέπει να αλλαχθεί ώστε να αποκτήσει τον ίδιο εκθέτη µε τον πρώτο.
Έτσι στον αριθµό +1.011 x 2110 θα µειωθεί ο εκθέτης κατά ένα (διαίρεση δια δύο) και θα µετατοπιστεί η mantissa µία θέση αριστερά (πολλαπλασιασµός επί 2).
Άρα 9 Ο εκθέτης θα γίνει 110 Æ101 , και Έτσι η πράξη ανάγεται στην παρακάτω : Εποµένως τώρα προστίθενται τα +1.0011 και +10.11, µε αποτέλεσµα 11.1111 και µαζί µε τον εκθέτη και το πρόσηµο θα είναι +11.1111 x 2101.
Το αποτέλεσµα της mantissa
Οι ειδικές περιπτώσεις συνοψίζονται στα παρακάτω:
Η µονάδα ελέγχου είναι το πιο σηµαντικό κοµµάτι σε ένα µικροεπεξεργαστή.
Αποτελεί στην ουσία τον «εγκέφαλο» της CPU ο οποίος είναι υπεύθυνος για τον συντονισµό και την λειτουργία όλων των υπόλοιπων τµηµάτων του µικροεπεξεργαστή.
Η µονάδα ελέγχου αναλαµβάνει την σειριακή φόρτωση των εντολών γλώσσας µηχανής του προγράµµατος που εκτελείται κάθε φορά στο εσωτερικό του επεξεργαστή, την αναγνώριση της κάθε εντολής και των παραµέτρων της, και την αποστολή των κατάλληλων σηµάτων ελέγχου προς τα υπόλοιπα τµήµατα τα CPU (όπως καταχωρητές, εσωτερικοί δίαυλοι, ALU, FPU, level 1 cache, κ.λ.π.) µε την κατάλληλη σειρά και τον κατάλληλο χρονισµό, ώστε να εκτελεστεί µε επιτυχία η κάθε εντολή.
Είναι προφανές ότι το σετ εντολών που αναγνωρίζει µία CPU , όπως οι 90 εντολές που αναγνωρίζει ο 8088, είναι κωδικοποιηµένες µέσα στην κατασκευή της µονάδας ελέγχου.
∆ηλαδή η µονάδα ελέγχου είναι αυτή που είναι υπεύθυνη για το γεγονός ότι ένας επεξεργαστής όπως ο 8088 αναγνωρίζει το συγκεκριµένο σετ εντολών (π.χ. 90 εντολές στον 8088).
Έτσι αν θέλουµε να ξανασχεδιάσουµε έναν επεξεργαστή ώστε να του προσθέσουµε την δυνατότητα να αναγνωρίζει 10 επιπλέον εντολές, το τµήµα της CPU που θα πρέπει να ξανασχεδιάσουµε είναι η µονάδα ελέγχου.
Το έργο οιπόν της µονάδας ελέγχου συνοψίζεται στα παραάτω:
Παίρνει είσοδο από το ρολόι του συστήµατος και µε βάση αυτό συγχρονίζει όλες τις
Παράγει σήµατα συγχρονισµού προς όλες τις υποµονάδες.
Προσκοµίζει κάθε εντολή και την αποθηκεύει στον IR.
Αποκωδικοποιεί την εντολή ενεργοποιώντας τις κατάλληλες υποµονάδες του Μ/Ε για την εκτέλεσή της.
Χειρίζεται τις εντολές µεταφοράς δεδοµένων µεταξύ καταχωρητών, ALU, FPU,
Συνδέεται και ελέγχει το Control Bus, που χρησιµοποιείται για έλεγχο όλου του
∆έχεται τις διακοπές Interrupts και τις προωθεί στον Μ/Ε και παράγει σήµατα διακοπής προς περιφερειακές συσκευές.
∆έχεται όλα τα υπόλοιπα σήµατα ελέγχου, όπως τα σήµατα ελέγχου του καναλιού DMA και αποκρίνεται σε αυτά.
Ο κύκλος εκτέλεσης κάθε εντολής υλοποιείται από τη µονάδα ελέγχου και έχει τρεις φάσεις :
Προσκόµιση Εντολής (fetch),
Αποκωδικοποίηση της εντολής και Υπολογισµός τελικής διεύθυνσης ή προσκόµιση τελικών δεδοµένων (decoding & effective address calculation / final data fetching),
Εκτέλεση εντολής (execution).
Οι µονάδες ελέγχου στους µικροεπεξεργαστές υλοποιούνται µε δύο διαφορετικές τεχνικές
Η πρώτη τεχνική είναι η κατασκευή µονάδων ελέγχου µε συνδυαστικά λογικά
Η δεύτερη τεχνική συνιστάται στην κατασκευή µικρο-προγραµµατιζόµενων µονάδων ελέγχου οι οποίες είναι κατασκευασµένες να εκτελούν εντολές γραµµένες σε µια γλώσσα µικρο-προγραµµατισµού (µικρο-εντολές).
Περιέχουν µια µόνιµη µνήµη ROM η οποία περιέχει ρουτίνες µικροκώδικα για όλες τις εντολές που αναγνωρίζει ο επεξεργαστής.
Στην υλοποίηση µονάδων ελέγχου µε λογικά κυκλώµατα (Hard-wired Control Unit) η µονάδα ελέγχου σχεδιάζεται εξολοκλήρου ως ένα πάρα πολύ σύνθετο ψηφιακό ακολουθιακό κύκλωµα.
Αυτό έχει την ικανότητα να αναγνωρίζει στην είσοδό του ένα µεγάλο σετ διαφορετικών αριθµών-εντολών και να αποκρίνεται σε κάθε τέτοια εντολή µε µια ακολουθία τιµών εξόδου οι οποίες οδηγούνται στα διάφορα τµήµατα του επεξεργαστή, όπως οι καταχωρητές, η εσωτερικοί δίαυλοι, η ALU, η FPU κ.λ.π., και τα ενεργοποιούν ακολουθιακά ώστε να εκτελεστεί µε επιτυχία η κάθε εντολή.
Όπως γίνεται προφανές η κατασκευή τέτοιων µονάδων ελέγχου είναι εξαιρετικά δύσκολη και τόσο πιο δύσκολη όσο µεγαλύτερο είναι το σετ εντολών που πρέπει να αναγνωρίσει η Βέβαια, επειδή η λειτουργία της µονάδας ελέγχου υλοποιείται εξολοκλήρου από υικό (hardware), οι µονάδες αυτές είναι ταχύτατες στην απόκρισή τους και στη λειτουργία τους.
Αυτό συµβάλλει στην ταχύτατη εκτέλεση εντολών γλώσσας µηχανής από τον µικροεπεξεργαστή.
Και αυτό βέβαια είναι το πλεονέκτηµα αυτής της τεχνολογίας κατασκευής µονάδων ελέγχου Οι εντολές γλώσσας µηχανής εκτελούνται πρακτικά σε ένα κύκλο εκτέλεσης Το µειονέκτηµα όµως σε αυτές τις µονάδες είναι ότι εάν θελήσουµε να αυξήσουµε το σετ εντολών του µικροεπεξεργαστή τότε θα πρέπει να ξανασχεδιάσουµε την µονάδα ελέγχου από την αρχή.
Εποµένως στις µονάδες αυτές δεν είναι εύκολο να επεκταθεί το σετ εντολών του µικροεπεξεργαστή, δηλαδή οι εντολές γλώσσας µηχανής που αναγνωρίζει Οι µονάδες αυτές που κατασκευάζονται µε ψηφιακά κυκλώµατα χωρίζονται σε δύο υπο- A.
Στις σύγχρονες µονάδες ελέγχου και B.
Στις ασύγχρονες µονάδες ελέγχου.
Στις σύγχρονες µονάδες ελέγχου η λειτουργία τους βασίζεται σε ένα ρολόι δηλαδή σε ένα ψηφιακό κύκλωµα που παράγει µια τετραγωνική παλµοσειρά αυστηρά Όλες οι ενέργειες της µονάδας ελέγχου γίνονται µε βάση τους παλµούς αυτού του Σε κάθε παλµό του ρολογιού εκτελείται και µια µικρό-λειτουργία µέσα στον επεξεργαστή καθοδηγούµενη από τη µονάδα ελέγχου Για παράδειγµα, µπορεί µέσα σε έναν παλµό του ρολογιού να εκτελείται µία πρόσθεση στην αριθµητική και λογική µονάδα ή να µεταφέρονται δεδοµένα από τον ένα καταχωρητή στον άλλο.
Επειδή όµως όλες αυτές οι ενέργειες δεν έχουν την ίδια διάρκεια, δηλαδή άλλες είναι γρήγορες και άλλες αργές, η περίοδος του ρολογιού είναι κατάλληλα ρυθµισµένη ώστε η µονάδα ελέγχου να προλαβαίνει να εκτελέσει ακόµα και την πιο αργή µικρό- Αυτό έχει όµως σαν συνέπεια, τόσο οι αργές λειτουργίες όσο και οι γρήγορες λειτουργίες να καταλαµβάνουν στην ουσία έναν παλµό του ρολογιού, µε αποτέλεσµα να υπάρχει αρκετός άεργος χρόνος στην εκτέλεση των λειτουργιών στη µονάδα ελέγχου, όπως φαίνεται στο παρακάτω σχήµα.
Παλµοσειρά του ρολογιού χρονισµού της µονάδας ελέγχου Εκτέλεση µικρο-λειτουργίας µεταβλητής διάρκειας στην έναρξη του παλµού
Εκτέλεση βηµάτων από σύγχρονη µονάδα ελέγχου Αυτό είναι και το µειονέκτηµα των σύγχρονων µονάδων ελέγχου.
Αντίθετα το πλεονέκτηµά τους είναι ότι είναι ευκολότερες στην κατασκευή σε σχέση µε την επόµενη τεχνική τις ασύγχρονες µονάδες ελέγχου.
Η δεύτερη κατηγορία µονάδων ελέγχου που κατασκευάζονται αποκλειστικά µε ψηφιακά κυκλώµατα είναι οι ασύγχρονες µονάδες ελέγχου.
Σε αυτές τις µονάδες δεν υπάρχει ρολόι πού να συγχρονίζει την εκτέλεση των µικρών λειτουργιών από τη µονάδα ελέγχου.
Αντίθετα µετά το πέρας κάθε µικρο-λειτουργίας διεγείρεται η έναρξη του επόµενου βήµατος.
Αυτή η τεχνική φαίνεται στο παρακάτω σχήµα:
Αντίστοιχη παλµοσειρά σύγχρονης µονάδας ελέγχου (για σύγκριση) Εκτέλεση µικρο-λειτουργίας µεταβλητής διάρκειας
Εκτέλεση µικρο-λειτουργιών από ασύγχρονη µονάδα ελέγχου
Εκτέλεση βηµάτων από ασύγχρονη µονάδα ελέγχου Με την τεχνική αυτή δεν υπάρχει πλέον άεργος χρόνος στη λειτουργία της µονάδας ελέγχου και έτσι αυξάνεται συνολικά η απόδοση του µικροεπεξεργαστή σχετικά µε την ταχύτητα εκτέλεσης εντολών.
Η ταχύτητα αυτών των µονάδων ελέγχου είναι και το πλεονέκτηµά τους.
Το µειονέκτηµά τους είναι ότι είναι δυσκολότερες στην σχεδίαση και την κατασκευή σε σχέση µε τις σύγχρονες µονάδες ελέγχου.
Η δεύτερη τεχνική κατασκευής µονάδων ελέγχου είναι οι µονάδες ελέγχου που λειτουργούν µε µικρό-προγραµµατισµό (Microprogrammed Control Unit).
Ξεκινώντας από τη δεκαετία του '50, µε τη σειρά System/360 της IBM, και µέχρι το τέλος της δεκαετίας του '70 κυριάρχησε η τάση οι εντολές να διερµηνεύονται µέσω µικροπρογράµµατος και να µην εκτελούνται απευθείας από το υλικό, ενώ βαθµιαία οι εντολές γίνονταν όλο και πιο σύνθετες.
Αποκορύφωµα αυτής της τάσης ήταν ο VAX της Digital Equipment Corporation, ο οποίος είχε εκατοντάδες διερµηνευόµενες εντολές και περισσότερους από 200 τρόπους για τον προσδιορισµό των τελεστέων των εντολών.
Σταδιακά, και µε την έλευση των RISC µ/ε (δες σχετικό κεφάλαιο) φάνηκε ότι η διερµηνευόµενες εντολές µείωναν την απόδοση.
Σήµερα η τάση είναι ένα µέρος των εντολών να είναι διερµηνευόµενες και ένα µέρος άµεσα εκτελέσιµες από το υλικό.
Σε αυτή την τεχνολογία οι µονάδες ελέγχου κατασκευάζονται ως «µικροί επεξεργαστές» καθώς έχουν την ικανότητα εκτέλεσης εντολών όπως και ένας µικροεπεξεργαστής.
Οι εντολές αυτές που ονοµάζονται µικρο-εντολές αφορούν στην εκτέλεση µικρών λειτουργιών µέσα στον επεξεργαστή.
Οι µικρο-εντολές ελέγχουν όλα τα εσωτερικά µέρη του Μ/Ε (διαύλους, εσωτερικούς καταχωρητές, κανονικούς καταχωρητές, ALU, FPU κ.λ.π.).
Οι µικρο-εντολές εκτελούνται σειριακά, δηλαδή η µία µετά την άλλη.
Όµως αρκετές µικρο-εντολές µπορούν να εκτελούνται και παράλληλα.
Ο παραλληλισµός στην εκτέλεση εντολών µικρο-κώδικα είναι θέµα έξυπνης σχεδίασης της µονάδας ελέγχου, και µπορεί να συµβάλλει σηµαντικά στην αύξηση της ταχύτητας του µικροεπεξεργαστή.
Κάθε εντολή γλώσσας µηχανής απαιτεί πολλούς κύκλους ρολογιού, καθώς υλοποιείται µε πολλές µικρολειτουργίες, δηλαδή µε πολλές µικρο-εντολές.
∆ηλαδή, κάθε εντολή γλώσσας µηχανής υλοποιείται ως µία ακολουθία εντολών µικροκώδικα.
Οι εντολές αυτές σχηµατίζουν µια γλώσσα προγραµµατισµού της µονάδας ελέγχου που ονοµάζεται γλώσσα µικρό-προγράµµατος η γλώσσα µικρο-κώδικα.
Είναι προφανές ότι η γλώσσα αυτή είναι κατά ένα επίπεδο κατώτερη από τη γλώσσα µηχανής.
Σε αυτή τη γλώσσα προγραµµατισµού δεν έχει πρόσβαση ο χρήστης αλλά µόνο ο κατασκευαστής του Για να µπορέσουν οι µονάδες ελέγχου αυτές να υλοποιήσουν ένα µεγάλο σετ εντολών γλώσσας µηχανής θα πρέπει να περιλαµβάνουν και µια µόνιµη µνήµη ROM µέσα στην µονάδα ελέγχου η οποία να περιλαµβάνει ένα µικρό-πρόγραµµα (ρουτίνα) µε µικρο- εντολές για κάθε εντολή γλώσσας µηχανής που αναγνωρίζει ο µικρό επεξεργαστής Έτσι µε την προσκόµιση µιας εντολής γλώσσας µηχανής από τη µνήµη του υπολογιστή, η εντολή αναγνωρίζεται, και στη συνέχεια η µονάδα ελέγχου αρχίζει την εκτέλεση της κατάλληλης ρουτίνας από την µνήµη ROM που αντιστοιχεί σε αυτή την εντολή Η ρουτίνα αυτή θα περιέχει όλα τα µικρό-βήµατα που είναι απαραίτητα για την επιτυχή εκτέλεση της εντολής µέσα στον επεξεργαστή Η µόνιµη µνήµη ROM περιέχει τόσες υπορουτίνες µικρο-κώδικα όσες είναι και οι εντολές που αναγνωρίζει ο επεξεργαστής.
Είναι προφανές ότι έτσι η εκτέλεση κάθε εντολής γλώσσας µηχανής ανάγεται στην εκτέλεση ενός µεγάλου αριθµού βηµάτων µικρο-εντολών από µια µηχανή που τις διαβάζει και τις εκτελεί και που στην περίπτωση αυτή είναι η µονάδα ελέγχου.
Αυτό κάνει τις µικρο-προγραµµατιζόµενες µονάδες ελέγχουν να είναι αργές στην εκτέλεση των εντολών γλώσσας µηχανής.
Και αυτό είναι το σηµαντικό µειονέκτηµα των µονάδων αυτών.
Το πλεονέκτηµά τους όµως είναι ότι είναι πολύ εύκολο ο σχεδιαστής τους να επεκτείνει το σετ εντολών τους.
Για να προστεθεί µια εντολή στο σετ εντολών που αναγνωρίζει ο επεξεργαστής, αρκεί να προσθέσει µία ακόµα υπορουτίνα µικρο-κώδικα µέσα στην ROM της µονάδας ελέγχου που να αντιστοιχεί στην επιπλέον εντολή.
Θα πρέπει να σηµειωθεί ότι υπάρχει πλήρης ισοδυναµία ανάµεσα σε εντολές και υλικό, καθώς η κάθε εντολή µπορεί να εκτελεστεί και από υλικό και αντιστρόφως.
Οι σχεδιαστές κάθε CPU αποφασίζουν κατά τα πρώτα στάδια της σχεδίασης ποιες λειτουργίες θα ενσωµατώσουν σε εντολές και ποιες σε υλικό.
Για παράδειγµα ακολούθως παρατίθενται µερικές µικροεντολές σε συµβολική µορφή µε την εξήγησή τους.
Παραδείγµατα εντολών µικροκώδικα : ¾ MAR←IP αντέγραψε τον καταχωρητή IP στον MAR (σε συνδυασµό µε τον CS).
Η διεύθυνση που επεριείχαν οι CS:IP εξάγεται στο Address Bus ¾ IP=IP+1 αύξησε τον IP κατά ένα ¾ Wait περίοδος παύσης µέχρι να αποκριθεί η µνήµη. ¾ MDR ← DB σύνδεσε τον MDR µε το Data Bus έτσι ώστε η λέξη (8 bit) που θα έρθει από το Data Bus να αποθηκευθεί στον MDR ¾ IR←MDR αποθήκευσε το περιεχόµενο του MDR στον καταχωρητή IR Η ακολουθία των παραπάνω µικρο-εντολών ολοκληρώνει ένα κύκλο επικοινωνίας µε την µνήµη RAM που ονοµάζεται και κύκλος µηχανής (machine cycle).
Κατά τον κύκλο αυτό η CPU αποστέλλει στην µνήµη την διεύθυνση του byte που θέλει να διαβάσει και αφού η µνήµη αποκριθεί, το byte διαβάζεται από τον δίαυλο δεδοµένων και αποθηκεύεται πρώτα στον MDR και στην συγκεκριµένη περίπτωση προωθείται και στον καταχωρητή IR.
Ο συγκεκριµένος κύκλος είναι στην ουσία ένας κύκλος προσκόµισης του opcode µίας εντολής γλώσσας µηχανής το οποίο διαβάζεται από την διεύθυνση νήµης που «δείχνει» ο IP (CS:IP) και αποθηκεύεται τελικά στον IR (Instruction Register), που βρίσκεται µέσα στην µονάδα ελέγχου, ώστε η εντολή να αποκωδικοποιηθεί , δηλαδή να καταλάβει η µονάδα ελέγχου για ποια εντολή πρόκειται.
Ο κύκλος αυτός επαναλαµβάνεται ο ίδιος, κάθε φορά που διαβάζεται µία νέα εντολή γλώσσας µηχανής από το τµήµα κώδικα στην
Στη συνέχεια παρατίθενται δύο µπλοκ διαγράµµατα που εξηγούν µε σχηµατικό τρόπο την λειτουργία των δύο τεχνικών υλοποίησης µονάδων ελέγχου: 1. µε Ψηφιακά Κυκλώµατα, και
Τωρινή Αποκωδικοποιητής Αποκωδικοποιητής Εξόδου ΚατάστασηΕπόµενης Κατάστασης
Μπλοκ διάγραµµα µονάδα ελέγχου υλοποιηµένης µε υλικό (hard-wired) : Στο διάγραµµα της µονάδας ελέγχου που λειτουργεί µε Ψηφιακά Κυκλώµατα φαίνεται ο τρόπος µε τoν οποίο λειτουργεί η µονάδα αυτή.
Ανά πάσα στιγµή η µονάδα ελέγχου βρίσκεται σε µια κατάσταση που αναφέρεται στο διάγραµµα ως «τωρινή κατάσταση».
Στην κατάσταση αυτή η µονάδα ελέγχου εκτελεί την τρέχουσα µικρό λειτουργία.
Η τωρινή κατάσταση περιλαµβάνει επίσης την κατάσταση των καταχωρητών και του flag register.
Η τωρινή κατάσταση ανά τροφοδοτείται σε ένα άλλο κοµµάτι του κυκλώµατος το οποίο δέχεται και τις εξωτερικές εισόδους.
Το κοµµάτι αυτό ονοµάζεται «αποκωδικοποιητής επόµενης κατάστασης».
Είναι υπεύθυνο για την παραγωγή της επόµενης κατάστασης της µονάδας ελέγχου, δηλαδή της µετάβασης στην επόµενη µικρο-λειτουργία που απαιτείται να εκτελεστεί µε βάση την προηγούµενη κατάσταση αλλά και τις εξωτερικές εισόδους.
Είσοδοι είναι ο κώδικας της εντολής γλώσσας µηχανής που εκτελείται κάθε στιγµή ή και άλλες εξωτερικές πληροφορίες, όπως για παράδειγµα τα σήµατα διακοπών (interrupts).
Ένα τρίτο τµήµα της µονάδας ελέγχου που ονοµάζεται «αποκωδικοποιητής εξόδου» είναι υπεύθυνο να παράγει τα κατάλληλα σήµατα ελέγχου προς τις διάφορες υπό-µονάδες του επεξεργαστή αποκωδικοποιώντας έτσι την τωρινή κατάσταση σε πολλαπλά σήµατα.
Τωρινή πρόγραµµα Αποκωδικοποιητής µικροROM ΚατάστασηΕπόµενης Κατάστασης
Μονάδα ελέγχου υλοποιηµένη µε µικροκώδικα (microprogrammed) : Στο διάγραµµα της µονάδας ελέγχου που λειτουργεί µε µικροπρογραµµατισµό φαίνεται ότι και εδώ υπάρχει η έννοια της «τωρινής κατάστασης» όπου η µονάδα ελέγχου εκτελεί την τρέχουσα µικρό-λειτουργία.
Η τωρινή κατάσταση επίσης ανατροφοδοτείται στον «αποκωδικοποιητή επόµενης κατάστασης» που είναι υπεύθυνος για την παραγωγή της επόµενης «τωρινής κατάστασης» της µονάδας ελέγχου.
Ο «αποκωδικοποιητής επόµενης κατάστασης» δέχεται επίσης και τις εξωτερικές εισόδους που είναι ο κώδικας της εντολής γλώσσας µηχανής που εκτελείται κάθε στιγµή αλλά και άλλες εξωτερικές πληροφορίες, όπως για παράδειγµα τα σήµατα διακοπών Η «τωρινή κατάσταση» οδηγεί στην εκτέλεση ενός µικρο-προγράµµατος από την µνήµη ROM που περιέχει τις ρουτίνες µικρο-κώδικα.
∆εν υπάρχει δηλαδή εδώ το τµήµα του «αποκωδικοποιητή εξόδου».
Στις µικροπρογραµµατιζόµενες µονάδες ελέγχου το εκάστοτε µικρο-πρόγραµµα είναι υπεύθυνο να πραγµατοποιήσει τις κατάλληλες ενέργειες που απαιτούνται για την υλοποίηση της «τωρινής κατάστασης», ενεργοποιώντας τις κατάλληλες υπό-µονάδες του επεξεργαστή και µε την κατάλληλη σειρά.
Ένας τυπικός Μ/Ε έχει δύο εσωτερικούς διαύλους :
Τον Εσωτερικό ∆ίαυλο ∆εδοµένων – Internal Data Bus : που είναι αµφίδροµος και συνδέει τους καταχωρητές µεταξύ τους.
Συνδέεται µε τον εξωτερικό δίαυλο δεδοµένων (external Data Bus) µέσω του εσωτερικού καταχωρητή MDR και εν συνεχεία των ακροδεκτών D0..D7 του chip, ώστε να µεταφέρει δεδοµένα προς και από τη µνήµη και τις περιφερειακές συσκευές.
Έχει πλάτος συνήθως µία λέξη (όση και η χωρητικότητα των καταχωρητών).
Στον 8088 το data bus έχει έυρος 8 bit ενώ οι καταχωρητές είναι των 16 bit.
H σύνδεση µε τον εξωτερικό δίαυλο γίνεται µέσω αποµονωτή (buffer) τον ρόλο του οποίου παίζει ο εσωτερικός καταχωρητής MDR.
Τον Εσωτερικό ∆ίαυλος ∆ιευθύνσεων – Internal Address Bus : συνδέεται µε τους καταχωρητές διευθύνσεων ώστε να σχηµατίζεται σε αυτόν η διεύθυνση µνήµης που πρέπει να προσπελαστεί.
Συνδέεται στον εξωτερικό δίαυλο διευθύνσεων µέσω του εσωτερικού καταχωρητή MAR και εν συνεχεία των ακροδεκτών A0..A19, ώστε να επιλέγει διευθύνσεις από τη µνήµη RAM, τη µνήµη ROM, ή τις περιφερειακές συσκευές.
Στον 8088 το Address Bus έχει εύρος 20 bit.
H σύνδεση µε τον εξωτερικό δίαυλο γίνεται µέσω αποµονωτή (buffer), τον ρόλο του οποίου παίζει ο εσωτερικός καταχωρητής MAR.
Στη συνέχεια παρατίθενται δύο τυπικοί µικροεπεξεργαστές και οι φωτογραφίες τους µε
Ο Pentium III, Katmai, έχει 9,5 εκατοµµύρια τρανζίστορ.
Το µέγεθος του ολοκληρωµένου κυκλώµατος είναι 12,3 επί 10,4 χιλιοστά (mm).
Βασίζεται σε τεχνολογία CMOS των 250 nm.
Oι συνδέσεις µεταξύ των τρανζίστορ αναπτύσσονται σε πέντε επίπεδα και είναι κατασκευασµένες από αλουµίνιο.
Η χρήση του αλουµινίου είναι αυτή που δίνει και το ασηµο-γαλάζιο χρώµα στη φωτογραφία του µικροεπεξεργαστή.
Στη συνέχεια επεξηγούνται οι συντοµογραφίες των τµηµάτων του επεξεργαστή που φαίνονται στην εικόνα.
Ο Pentium 4 είναι ένα ολοκληρωµένο κύκλωµα κατασκευασµένο µε 55 εκατοµµύρια τρανζίστορ.
Η επιφάνεια του ολοκληρωµένου κυκλώµατος ανέρχεται σε 217 τετραγωνικά χιλιοστά (mm2).
Η µνήµη cache επιπέδου ένα (level 1 cache) είναι χωρισµένη σε δύο κοµµάτια (split cache) : στη µνήµη cache εκτέλεσης εντολών (execution cache) που έχει χωρητικότητα 12.000 µικρό-εντολές και στη µνήµη cache δεδοµένων (data cache) η οποία ανέρχεται σε 8 KByte.
Η µνήµη cache επιπέδου δύο είναι κοινή και για εντολές και για δεδοµένα και ανέρχεται σε 256 KByte.
Κριτήρια Επιλογής Μκροεπεξεργαστή
Τα κριτήρια που θα πρέπει να λαµβάνονται υπ όψιν κατά την επιλογή ενός µικροεπεξεργαστή για την κατασκευή ενός συστήµατος µπορούν να αναλυθούν ως εξής :
Απόδοση.
Ο πιο ουσιαστικός παράγοντας κατά την επιλογή ενός µ/ε είναι το εάν ο υποψήφιος µ/ε παρέχει ικανοποιητική απόδοση στην εφαρµογή που θα χρησιµοποιηθεί.
Για την µέτρηση της απόδοσης µ/ε χρησιµοποιούνται τυποποιηµένα Μετροπρογράµµατα (benchmarks) τα οποία εκτελούν συνήθως επαναληπτικές λειτουργίες και παρέχουν ένα µέτρο σύγκρισης της απόδοσης διαφορετικών µ/ε.
Αριθµός µονάδων που θα παραχθούν.
Αποτελεί ένα ουσιαστικό κριτήριο που έχει να κάνει µε το κόστος.
Γενικά, για παραγωγή µικρών ή µεσαίων ποσοτήτων είναι οικονοµικότερη η χρήση ενός τυποποιηµένου µ/ε.
Για παραγωγή µεγάλης κλίµακας είναι πιθανόν οικονοµικότερη η χρήση ενός µ/ε κατά-παραγγελία, ο οποίος θα είναι βελτιστοποιηµένος για την συγκεκριµένη εφαρµογή.
∆ιαθεσιµότητα.
Σηµαντικό κριτήριο κατά την επιλογή µ/ε είναι η διαθεσιµότητα όλων των υποσυστηµάτων που απαιτούνται για τη λειτουργία του συστήµατος, όπως chipset υποστήριξης, chip µνήµης και I/O κ.α.
Λογισµικό.
Το υλικό µέρος του συστήµατος δεν µπορεί να λειτουργήσει χωρίς το κατάλληλο λογισµικό.
Κατά την επιλογή του µ/ε θα πρέπει να εξεταστεί εάν υπάρχουν διαθέσιµες έτοιµες εφαρµογές ή assemblers / compilers για την ανάπτυξη προγραµµάτων.
Εργαλεία Ανάπτυξης.
Η σχεδίαση του συστήµατος και η ανάπτυξη του λογισµικού διευκολύνεται και επιταχύνεται εάν είναι διαθέσιµα διάφορα εργαλεία ανάπτυξης όπως Αναπτυξιακά Συστήµατα, emulators του µ/ε κ.α.
Ειδικά Κριτήρια.
Η επιλογή µ/ε είναι πιθανόν να περιορίζεται από ειδικά κριτήρια.
Ετσι, η χαµηλή κατανάλωση παίζει σηµαντικό ρόλο σε φορητά συστήµατα, ενώ για στρατιωτική χρήση ο µ/ε θα πρέπει να πληροί συγκεκριµένες και αυστηρές προδιαγραφές
Μέτρηση της απόδοσης ενός Μικροεπεξεργαστή
Για την µέτρηση της απόδοσης και τη σύγκριση διαφορετικών µ/ε υπάρχουν ορισµένα διεθνώς αποδεκτά Μετροπρογράµµατα (Benchmarks) και µεγέθη, τα οποία αναλύονται πιο κάτω: ¾ MIPS (Million Instructions Per Second).
Είναι η παλιότερη µονάδα µέτρησης ταχύτητας µιας CPU και ισοδυναµεί περίπου µε τον αριθµό εντολών µηχανής που εκτελούνται σε ένα δευτερόλεπτο (second).
Τα MIPS αναφέρονται καθαρά στην απόδοση της CPU και έτσι δεν είναι αντιπροσωπευτικά της απόδοσης ενός πλήρους συστήµατος, καθώς εκεί παράγοντες όπως η µνήµη και οι περιφερειακές µονάδες επηρεάζουν σηµαντικά την τελική απόδοση του.
Χονδρικά, οι Intel 8088/86 απέδιδαν 0.25 MIPS ενώ οι Pentium ¾ FLOPS (Floating-Point Operations per Second).
Υπολογίζει τον αριθµό πράξεων κινητής υποδιαστολής ανά sec.
Οι πράξεις αυτές είναι πιο αργές από τις αντίστοιχες πράξεις ακεραίων.
Οι σύγχρονες CPU έχουν µια ειδική µονάδα για την εκτέλεση τέτοιων πράξεων (FPU, Floating Point Unit) και τα FLOPS δίνουν την απόδοση αυτής της µονάδας.
Από πολλούς τα FLOPS δεν θεωρούνται πλήρως αντιπροσωπευτικά της ταχύτητας µιας CPU καθώς δεν λαµβάνονται υπόψη παράγοντες όπως ο φόρτος της CPU, το είδος της πράξης κ.α.
Πολλαπλάσια του FLOP είναι το MFLOP και το GFLOP.
Ένα γνωστό µετροπρόγραµµα που υπολογίζει τα FLOPS είναι το Linpack.
Η απόδοση ενός υπερυπολογιστή CRAY-1 είναι περίπου 100 MFLOPS. ¾ Dhrystone.
Είναι ένα µετροπρόγραµµα που αναπτύχθηκε το 1984, είναι γραµµένο σε µια γλώσσα ανώτερου επιπέδου και υπολογίζει την απόδοση της CPU σε πράξεις ακεραίων, χωρίς να εκτελεί λειτουργίες Ι/Ο ή κλήσεις στο λειτουργικό σύστηµα.
Τα Dhrystones per second µετρούν το πόσες φορές µπορεί να εκτελεστεί ένα πρόγραµµα σε ένα sec. ¾ SPEC (Standard Performance Evaluation Corporation).
Είναι ένας µη κερδοσκοπικός οργανισµός που συγκροτήθηκε από εταιρίες κατασκευής υπολογιστών και µ/ε µε σκοπό την ανάπτυξη ενός τυποποιηµένου συνόλου µετροπρογραµµάτων για τη βιοµηχανία υπολογιστών.
Τα Μετροπρογράµµατα αυτά υπολογίζουν την απόδοση της CPU σε πράξεις ακεραίων και κινητής υποδιαστολής, καθώς και την απόδοση της µνήµης, των ¾ Τέλος, έχει αναπτυχθεί ένας µεγάλος αριθµός µετροπρογραµµάτων από διάφορες εταιρίες και περιοδικά πληροφορικής ανά τον κόσµο.
Είναι προφανές ότι δεν µπορεί να γίνει σύγκριση αποτελεσµάτων µεταξύ διαφορετικών µετροπρογραµµάτων.
Κεφάλαιο 5.
Η δοµή των εντολών Στο κεφάλαιο αυτό θα µελετήσουµε τις εντολές γλώσσας µηχανής.
Θα αναλύσουµε τη δοµή των εντολών γλώσσας µηχανής και τα τµήµατα από τα οποία αποτελούνται.
Θα εµβαθύνουµε στον τρόπο µε τον οποίον διαβάζονται οι εντολές γλώσσας µηχανής από τον επεξεργαστή, και στον τρόπο µε τον οποίον αποκωδικοποιούνται, ώστε να γίνει αντιληπτό από τον επεξεργαστή για ποια εντολή πρόκειται, ώστε να προβεί στην εκτέλεση των σωστών βηµάτων για την ολοκλήρωση της εντολής.
Επίσης θα αναλύσουµε τις εντολές στο επίπεδο µικρό-κώδικα που εκτελούν οι µικρο- προγραµµατιζόµενες µονάδες ελέγχου για την ολοκλήρωση των εντολών.
Θα αναλύσουµε γνωστές εντολές γλώσσας µηχανής του 8088 σε εντολές µικρό-κώδικα.
Επίσης θα µιλήσουµε για τους διάφορους τρόπους σύνταξης των εντολών γλώσσας µηχανής που αναφέρονται και ως τρόποι διευθυνσιοδότησης µνήµης, και το πώς αυτοί λειτουργούν.
Τέλος θα µιλήσουµε για δύο αρχιτεκτονικές κατασκευής επεξεργαστών την τεχνολογία CISC και την τεχνολογία RISC.
Οι εντολές γλώσσας µηχανής
Κάθε µικρο-επεξεργαστής διαθέτει ένα σετ εντολών που µπορεί να αναγνωρίζει και να εκτελεί.
Με βάση αυτό το σέτ, µπορεί ο προγραµµατιστής να αναπτύξει οποιοδήποτε πρόγραµµα οσοδήποτε πολύπλοκο και να είναι.
Το σετ εντολών του επεξεργαστή απαρτίζει στην ουσία µια γλώσσα προγραµµατισµού πολύ χαµηλού επιπέδου, στην οποία µεταφράζονται τα προγράµµατα που γράφονται σε όλες τις ανωτέρου επιπέδου γλώσσες, όπως η C η PASCAL η BASIC η JAVA κ.λ.π.
Η γλώσσα αυτή εµφανίζεται σε δύο µορφές:
την Συµβολική Γλώσσα Μηχανής (Assembly Language), που είναι µια µορφή των εντολών εύκολα αντιληπτή από τον άνθρωπο και που µπορεί ο προγραµµατιστής να αποµνηµόνευσει εύκολα (π.χ.
MOV AX,[1234]), και τον Κώδικα Μηχανής (Machine Code) που αποτελεί την αντιστοίχιση των συµβολικών εντολών σε αριθµούς (bytes) τους οποίους και µπορεί να αναγνωρίσει και να εκτελέσει τελικά ο επεξεργαστής (π.χ.
MOV AX,[1234] αντιστοιχεί σε «Β8 34 Τα προγράµµατα χαµηλού επιπέδου αναπτύσσονται σε συµβολική γλώσσα γιατί είναι ευκολότερη στην ανάπτυξη προγραµµάτων.
Η µετατροπή των συµβολικών εντολών που γράφει ο προγραµµατιστής στους αντίστοιχους αριθµούς του κώδικα µηχανής γίνεται µε ένα βοηθητικό πρόγραµµα που πρέπει να υπάρχει στον υπολογιστή και που ονοµάζεται Συµβολοµεταφραστής ή Assembler.
Η ύπαρξη Assembler µας διευκολύνει στο ότι µπορούµε να προγραµµατίζουµε σε συµβολική γλώσσα και όχι απευθείας µε αριθµούς του κώδικα µηχανής.
Ο σύµβολο-µεταφραστής µεταφράζει κάθε συµβολική εντολή στον κατάλληλο αριθµό bytes που αντιστοιχεί, και τοποθετεί τα bytes αυτά µε τη σειρά στη µνήµη.
Στη συνέχεια παίρνει την εποµένη εντολή, την µεταφράζει στα αντίστοιχα bytes της, και τα τοποθετεί αµέσως µετά από τα πρώτα στη µνήµη.
Έτσι κατά την διαδικασία της συµβολοµετάφρασης, στη µνήµη χτίζεται µια ακολουθία από bytes που αντιστοιχούν σε εντολές εκτελέσιµες από τον επεξεργαστή.
Όταν οι εντολές αυτές διαβαστούν και εκτελεστούν µε τη σειρά, θα αποτελέσουν ένα ολοκληρωµένο πρόγραµµα µε συγκεκριµένη λογική και αποτελέσµατα.
Κάθε πρόγραµµα που εκτελείται σε έναν υπολογιστή, είτε αυτός έχει λειτουργικό σύστηµα Windows, είτε αυτός έχει λειτουργικό σύστηµα Linux, ή οποιοδήποτε άλλο λειτουργικό σύστηµα, και ανεξάρτητα από τη γλώσσα προγραµµατισµού στην οποία αναπτύχθηκε η εφαρµογή, είτε αυτή ήταν απλή διαδικαστική γλώσσα, είτε ήταν αντικειµενοστραφής, είτε ήταν γλώσσα οπτικού προγραµµατισµού, αποτελείται από εντολές κώδικα µηχανής που αναγνωρίζει ο επεξεργαστής.
Οι γλώσσες προγραµµατισµού ανώτερου επιπέδου είναι µια εφεύρεση που µας επιτρέπει να προγραµµατίζουµε τους υπολογιστές µε πιο ανθρώπινο τρόπο από ότι ο «µηχανιστικός» και «κωδικοποιηµένος» κώδικας µηχανής, να φτιάχνουµε ευκολότερα µεγαλύτερα προγράµµατα και σε συντοµότερο χρόνο, και να µπορούµε να οργανώνουµε καλύτερα και να ξανα-χρησιµοποιούµε τα προγράµµατα που φτιάχνουµε.
Οποιοδήποτε όµως πρόγραµµα γραµµένο σε οποιαδήποτε γλώσσα, οποιασδήποτε τεχνοτροπίας, για να εκτελεστεί σε έναν υπολογιστή θα πρέπει πρώτα να µεταφραστεί σε κώδικα µηχανής, του επεξεργαστή που φιλοξενεί ο υπολογιστής.
Αυτό που εκτελείται στην ουσία είναι οι εντολές
Κάθε εντολή γλώσσας µηχανής της Κεντρικής Μονάδας Επεξεργασίας (KME) αποτελείται από 1 έως Ν bytes ανάλογα µε τον επεξεργαστή.
Στον 8088 οι εντολές γλώσσας µηχανής αποτελούνται από 1 έως 6 bytes.
Το πρώτο ή τα 2 πρώτα bytes της κάθε εντολής περιέχουν τον κωδικό της εντολής (Opcode).
Το opcode είναι ο χαρακτηριστικός κωδικός αριθµός κάθε εντολής που αναγνωρίζει ο επεξεργαστής.
Κάθε εντολή του κώδικα µηχανής διακρίνεται απόλυτα από το opcode της.
Όταν δηλαδή ο επεξεργαστής διαβάσει το opcode µίας εντολής, τότε καταλαβαίνει απόλυτα για ποια εντολή πρόκειται.
Επίσης καταλαβαίνει αν αυτή η εντολή ακολουθείται από παραµέτρους, πόσα byte είναι οι παράµετροι και ποια είναι η σηµασία κάθε παραµέτρου (αριθµός, διεύθυνση µνήµης, κ.λ.π.).
Κάθε εντολή, στην συµβολική της µορφή, όπως για παράδειγµα η εντολή MOV, µπορεί να έχει ένα πλήθος από διαφορετικά opcodes ανάλογα µε τα είδη διευθυνσιοδότησης που συντάσσεται.
Για να γίνει αυτό αντιληπτό παραθέτουµε 5 διαφορετικούς τρόπους σύνταξης της εντολής MOV καθώς και τα opcodes και τις παραµέτρους της καθεµιάς.
Opcode Παράµετρος Λειτουργία MOV AL,FF B0 FF 2 B0 FF Βάζει στον AL τον MOV BL,FF B3 FC 2 B3 FC Βάζει στον BL τον MOV AL,[1234] A0 34 12 3 A0 34 12 Æ 1234 Βάζει στον AL τον αριθµό (1 byte) που MOV AX,1234 B8 34 12 3 B8 34 12 Æ 1234 Βάζει στον AX τον MOV DX,5678 BA 78 56 3 BA 78 56 Æ 5678 Βάζει στον DX τον MOV AX,[2345] A1 45 34 3 A1 45 23 Æ 2345 Βάζει στον AX τον
MOV CX,[2345] 8B 0E 45 23 4 8B 0E 45 23 Æ 2345 Βάζει στον CX τον 8B 9C 45 23 4 8B 9C 45 23 Æ 2345 Βάζει στον BX τον
Τα επόµενα bytes µετά το opcode (αν υπάρχουν) περιέχουν παραµέτρους της εντολής (αριθµούς ή διευθύνσεις) και ονοµάζονται τελεσταίοι (operands).
Ακολουθεί ένας πίνακας µε τρία παραδείγµατα εντολών γλώσσας µηχανής που αποτελούνται από διαφορετικό αριθµό Bytes η κάθε µία. (αριθµός) 85 (low byte) 34
Όσα περισσότερα byte έχει µία εντολή τόσο περισσότερο χρόνο χρειάζεται για να εκτελεστεί.
Αυτό γίνεται κατανοητό γιατί όταν µια εντολή αποτελείται από µεγάλο πλήθος bytes, τότε θα απαιτηθεί πολύς χρόνος µόνο και µόνο για να µπορέσει να προσκοµιστεί η εντολή αυτή µέσα στον επεξεργαστή.
Είναι προφανές ότι µια εντολή των 4 bytes χρειάζεται διπλάσιο χρόνο για την προσκόµισή της στον επεξεργαστή από ότι µία εντολή των 2 bytes.
Επίσης, συνήθως οι εντολές των πολλών bytes είναι σύνθετες εντολές οι οποίες ακόµα και στο στάδιο της εκτέλεσής τους απαιτούν παραπάνω χρόνο από ότι οι απλούστερες εντολές.
Η εκτέλεση των εντολών γλώσσας µηχανής
Στο κεφάλαιο αυτό θα αναπτύξουµε τον τρόπο µε τον οποίον γίνεται η εκτέλεση των εντολών γλώσσας µηχανής µέσα στον επεξεργαστή.
Για την καλύτερη κατανόηση των εννοιών και για να έχουµε καλύτερη εποπτική εικόνα του επεξεργαστή, παραθέτουµε ακριβώς από κάτω ένα µπλοκ διάγραµµα του εσωτερικού του επεξεργαστή όπου φαίνονται οι, πολύ σηµαντικοί για τη διαδικασία αυτή, εσωτερικοί καταχωρητές.
Κάθε εντολή της KME εκτελείται σε 3 φάσεις :
Τα 3 αυτά βήµατα αναλύονται στις ακόλουθες ενέργειες:
Προσκόµιση της επόµενης εντολής από την µνήµη (από την διεύθυνση που «δείχνει» ο δείκτης IP).
Αποθήκευση του opcode της εντολής (1-2 byte) στον καταχωρητή
Αλλαγή του IP ώστε να δείχνει την επόµενη εντολή.
Προσδιορισµός του τύπου της εντολής από τη Μονάδα Ελέγχου.
∆ιάβασµα των τυχόν παραµέτρων της εντολής (αριθµός ή διεύθυνση) και αποθήκευση στους καταλληλους καταχωρητές.
Στην περίπτωση διεύθυνσης (παράµετρος εντολής) αυτή καταχωρείται στον καταχωρητή ADR.
Υπολογισµός της τελικής διεύθυνσης δεδοµένων (έµµεση ή δεικτοδοτούµενη
Ανάκτηση των τελικών δεδοµένων από την µνήµη.
Εκτέλεση της εντολής.
Αποθήκευση των αποτελεσµάτων στην κατάλληλη θέση (καταχωρητής ή διεύθυνση
Τα παραπάνω βήµατα αναλύονται περισσότερο ακολούθως:
Προσκόµιση της εντολής ¾ Βήµα 1 : προσκόµιση της εντολής (fetch).
Η επόµενη εντολή βρίσκεται στην διεύθυνση που δείχνει ο IP.
Το περιεχόµενο του IP µεταφέρεται στον καταχωρητή διεύθυνσης µνήµης (MAR) συνδυαζόµενο µε τον καταχωρητή τµήµατος CS (MAR=CS:IP=CSx16+IP), και από εκεί στον εξωτερικό δίαυλο διευθύνσεων (Address Bus).
Η διεύθυνση του IP αυξάνεται κατά 1 ώστε να δείχνει στο επόµενο byte (operands ή επόµενο opcode).
Η ενηµέρωση του IP γίνεται µετά από κάθε ανάγνωση µνήµης
Μετά από µία χρονική καθυστέρηση (χρόνος προσπέλασης µνήµης) το πρώτο byte της εντολής (opcode) εµφανίζεται στον εξωτερικό δίαυλο δεδοµένων (Data Bus)
Τα δεδοµένα του Data Bus αποθηκεύονται στον καταχωρητή δεδοµένων (MDR).
Το περιεχόµενο του MDR µεταφέρεται στον καταχωρητή εντολής (IR).
Αν η εντολή περιέχει 2 opcodes τότε τα βήµατα 2-6 επαναλαµβάνονται άλλη µία
Στο παρακάτω σχήµα φαίνεται η «εικόνα» που έχει στην µνήµη µία εντολή γλώσσας µηχανής µε 2 opcode και 2 byte παραµέτρων, τοποθετηµένη στην διεύθυνση µνήµης 0100:0000.
Ο IP ήδη έχει την τιµή 0000 ενώ ο CS την τιµή 0100, δηλαδή «δείχνει» σε αυτή την εντολή και είναι έτοιµη να αναγνωστεί και να εκτελεστεί :
Εικόνα στην µνήµη µίας εντολής γλώσσας µηχανής µε 2 opcode και 2 byte παραµέτρων, τοποθετηµένη στην διεύθυνση µνήµης 0100:0000.
Τα παραπάνω βήµατα αναλύονται παρακάτω µε συµβολικές εντολές µικροπρογράµµατος: 1 MAR Å IP Το περιεχόµενο του IP αντιγράφεται στον MAR συνδυαζόµενο µε τον καταχωρητή τµήµατος CS 2 IP Å IP + 1 Ο IP αυξάνεται κατά 1 ώστε να δείχνει στο επόµενο byte που ανάλογα µε την εντολή µπορεί να είναι το δεύτερο byte του opcode, ή το πρώτο byte των παραµέτρων ή , αν δεν υπάρχουν παράµετροι, το opcode της επόµενης εντολής. 3 Wait Αναµονή για να απαντήσει η µνήµη.
Ο χρόνος αυτός ταυτίζεται ή είναι µεγαλύτερος από τον χρόνο απόκρισης της µνήµης. 4 MDR Å DB Η λέξη (1 byte) που εµφανίζεται στον δίαυλο δεδοµένων (Data Bus) αντιγράφεται στον MDR 5 IR Å MDR Το περιεχόµενο του MDR αντιγράφεται στον IR (Instruction Register) καθώς το byte που διαβάστηκε αποτελεί ένα opcode που πρέπει να προωθηθεί στην µονάδα ελέγχου για αναγνώριση και
Αποκωδικοποίηση της εντολής ¾ Βήµα 2 : αποκωδικοποίηση της εντολής (opcode decoding).
Η µονάδα ελέγχου αποκωδικοποιεί την εντολή, είτε µε συνδυαστικά ψηφιακά κυκλώµατα (hard-wired control unit) είτε µε µικροπρόγραµµα (microprogrammed control unit), αναγνωρίζει για ποια εντολή πρόκειται, και αποφασίζει ποιά τµήµατα του Μ/Ε θα ενεργοποιηθούν και µε ποια σειρά.
Σε αυτό το στάδιο η µονάδα ελέγχου καταλαβαίνει εάν στην εντολή περιλαµβάνεται και δεύτερο opcode ή όχι, εάν υπάρχουν παράµετροι ή όχι, από πόσα byte αποτελούνται οι παράµετροι και ποιος είναι ο ρόλος της κάθε παραµέτρου που
Αν κατά την αποκωδικοποίηση της εντολής (δηλαδή από το πρώτο opcode) διαπιστωθεί ότι υπάρχει και δεύτερο, τότε ακολουθεί η ανάγνωση του και η αποθήκευσή του στο καταχωρητή IR.
Αυτό θα γίνει µε επανάληψη των εντολών που αναφέρονται στο βήµα 1, µε την διαφορά ότι το δεύτερο opcode πηγαίνει στον IRH , δηλαδή στο υψηλής τάξης byte του IR.
Πρέπει εδώ να σηµειωθεί ότι το αν µία εντολή έχει και δεύτερο opcode ή όχι καθορίζεται απόλυτα από το πρώτο opcode.
Για παράδειγµα το opcode Α1 (MOV AX,[####]) ∆ΕΝ ακολουθείται από δεύτερο.
Ενώ το opcode 8B (MOV ##,[####]) ακολουθείται πάντα και από δεύτερο.
Έτσι αν η Μονάδα Ελέγχου διαβάσει το opcode A1, καταλαβαίνει ότι δεν υπάρχει 2o opcode αλλά ότι ακολουθεί παράµετρος διεύθυνσης των 2 bytes.
Ενώ αν διαβάσει το opcode 8B καταλαβαίνει ότι υπάρχει και 2ο opcode που προσδιορίζει επακριβώς τον καταχωρητή που συµµετέχει στην εντολή, καθώς και τον τρόπο διευθυνσιοδότησης, και ότι µετέπειτα ακολουθεί και παράµετρος διεύθυνσης των 2 bytes (σύνολο 4
¾ Βήµα 3 : Ανάγνωση παραµέτρων - Υπολογισµός και ανάγνωση τελικής διεύθυνσης ή Εάν διαπιστωθεί ότι υπάρχουν παράµετροι τότε ακολουθούν ένας ή περισσότεροι κύκλοι ανάγνωσης µνήµης, κατά τους οποίους διαβάζονται από την µνήµη και προσκοµίζονται στον επεξεργαστή όλες οι παράµετροι.
Οι παράµετροι καταχωρούνται σε Βήµα 3.1.
Αν η παράµετρος είναι αριθµός του 1 byte τότε θα παραµείνει στον MDR.
Για παράδειγµα στην εντολή MOV AL,45 που αντιστοιχεί στον κώδικα µηχανής B0 45, µετά το διάβασµα του Opcode (Β0) που θα γίνει µε τις εντολές του Βήµατος 1, θα ακολουθήσει άλλος ένας κύκλος ανάγνωσης µνήµης για το διάβασµα της παραµέτρου.
Στο παρακάτω σχήµα φαίνεται η «εικόνα» που έχει στην µνήµη η εντολή MOV AL,45, τοποθετηµένη στην διεύθυνση µνήµης 0100:0000.
Ο IP ήδη έχει την τιµή 0000 ενώ ο CS την τιµή 0100, δηλαδή «δείχνει» σε αυτή την εντολή και είναι έτοιµη να αναγνωστεί και
Εικόνα στην µνήµη της εντολής MOV AL,45 ∆ηλαδή µετά το διάβασµα του opcode (Βήµα 1) θα έχουµε τα εξής βήµατα :
Μετά από µία χρονική καθυστέρηση (χρόνος προσπέλασης µνήµης) το byte της παραµέτρου εµφανίζεται στον εξωτερικό δίαυλο δεδοµένων (Data Bus) Αναφορικά µε το συγκεκριµένο παράδειγµα έχει διαβαστεί ο αριθµός 45.
Τα παραπάνω βήµατα αναλύονται παρακάτω µε συµβολικές εντολές δεύτερο byte των παραµέτρων ή το opcode της
Βήµα 3.2.
Αν η παράµετρος είναι αριθµός των 2 bytes όπως για παράδειγµα στην εντολή SBB AX,1234, που αντιστοιχεί στον κώδικα µηχανής 1D 34 12, τότε µετά το διάβασµα του Opcode (1D) που θα γίνει µε τις εντολές του Βήµατος 1, θα ακολουθήσουν άλλοι δύο κύκλοι ανάγνωσης µνήµης για το διάβασµα της παραµέτρου, η οποία µέσω του MDR θα καταχωρηθεί στον 16 bit Καταχωρητή Προχείρου (Scratch Pad).
Στο παρακάτω σχήµα φαίνεται η «εικόνα» που έχει στην µνήµη η εντολή SBB AX,1234,
Εικόνα στην µνήµη της εντολής SBB AX,1234
Η διεύθυνση του IP αυξάνεται κατά 1 ώστε να δείχνει στο επόµενο byte (δεύτερο byte της παραµέτρου).
Η ενηµέρωση του IP γίνεται µετά από κάθε ανάγνωση µνήµης
Τα δεδοµένα του MDR αντιγράφονται στον SCRL, δηλαδή στο χαµηλής τάξης byte του καταχωρητή προχείρου ScrathPad Register.
Τα παραπάνω βήµατα θα επαναληφθούν άλλη µία φορά για να διαβαστεί και το 2ο byte
Η διεύθυνση του IP αυξάνεται κατά 1 ώστε να δείχνει στο επόµενο byte (επόµενο opcode).
Η ενηµέρωση του IP γίνεται µετά από κάθε ανάγνωση µνήµης µέσω του IP παραµέτρου εµφανίζεται στον εξωτερικό δίαυλο δεδοµένων (Data Bus).
Τα δεδοµένα του MDR αντιγράφονται στον SCRH, δηλαδή στο υψηλής τάξης byte byte που είναι το δεύτερο byte των παραµέτρων. 5 SCRL Å MDR Τα δεδοµένα του MDR αντιγράφονται στο χαµηλής τάξης byte του ScratchPad Register byte που είναι το opcode της επόµενης εντολής. 10 SCRΗ Å MDR Τα δεδοµένα του MDR αντιγράφονται στο υψηλής
Βήµα 3.3.
Αν η παράµετρος είναι διεύθυνση µνήµης (2 bytes) όπως για παράδειγµα στην εντολή ADC AX,[4567], που αντιστοιχεί στον κώδικα µηχανής 15 67 45, τότε µετά το διάβασµα του Opcode (15) που θα γίνει µε τις εντολές του Βήµατος 1, θα ακολουθήσουν άλλοι δύο κύκλοι ανάγνωσης µνήµης για το διάβασµα της παραµέτρου- διεύθυνσης (456716), η οποία µέσω του MDR θα καταχωρηθεί στον 16 bit Καταχωρητή ADR, που πάντα αποθηκεύει τις διευθύνσεις που είναι παράµετροι των εντολών.
Πρώτα θα διαβαστεί το byte χαµηλής τάξης (low byte) και θα πάει στον ADRL και στη συνέχεια το byte υψηλής τάξης (high byte) και θα τοποθετηθεί στον ADRH.
Στο παρακάτω σχήµα φαίνεται η «εικόνα» που έχει στην µνήµη η εντολή ADC AX,[4567], τοποθετηµένη στην διεύθυνση µνήµης 0100:0000.
Ο IP ήδη έχει την τιµή 0000 ενώ ο CS την τιµή 0100, δηλαδή «δείχνει» σε αυτή την εντολή και είναι έτοιµη να αναγνωστεί και να εκτελεστεί :
Εικόνα στην µνήµη της εντολής ADC AX,[4567]
Τα δεδοµένα του MDR αντιγράφονται στον ADRL, δηλαδή στο χαµηλής τάξης byte του καταχωρητή ADR.
Τα δεδοµένα του MDR αντιγράφονται στον ADRH, δηλαδή στο υψηλής τάξης byte
5 ADRL Å MDR Τα δεδοµένα του MDR αντιγράφονται στο χαµηλής τάξης byte του ADR 10 ADRΗ Å MDR Τα δεδοµένα του MDR αντιγράφονται στο υψηλής
Βήµα 3.4.
Αν απαιτείται και υπολογισµός τελικής διεύθυνσης σε περίπτωση δεικτοδοτούµενης διευθυνσιοδότησης, για παράδειγµα στην περίπτωση της εντολής MOV AX,[1234+SI], που αντιστοιχεί στον κώδικα µηχανής : 8B 84 34 12, τότε, µετά το διάβασµα των 2 Opcodes (8B 84) που θα γίνει µε τις εντολές του Βήµατος 1 (2 επαναλήψεις), θα ακολουθήσουν άλλοι δύο κύκλοι ανάγνωσης µνήµης για το διάβασµα της παραµέτρου-διεύθυνσης (123416) µε τις εντολές του Βήµατος 3.2.
Η διεύθυνση µέσω του MDR θα καταχωρηθεί στον 16 bit Καταχωρητή ADR, που πάντα αποθηκεύει τις διευθύνσεις που είναι παράµετροι των εντολών.
Πρώτα θα διαβαστεί το byte χαµηλής τάξης (low byte) και θα πάει στον ADRL και στη συνέχεια το byte υψηλής τάξης (high byte) και θα τοποθετηθεί στον ADRH.
Η διεύθυνση 123416 είναι η διεύθυνση «βάσης» του πίνακα που προσπελαύνει η εντολή.
Ο καταχωρητής SI περιέχει την µετατόπιση (σε bytes) πάνω από την «βάση», που βρίσκεται το στοιχείο που θα προσπελάσουµε.
Εποµένως στην συνέχεια θα πρέπει να υπολογιστεί η τελική διεύθυνση µνήµης, προσθέτοντας την διεύθυνση «βάσης» µε την «µετατόπιση» δηλαδή, όπως υποδηλώνει και η εντολή, θα πρέπει να γίνει η πράξη : Τελική ∆ιεύθυνση = «βάση» + «µετατόπιση» = 1234 + SI Στο παρακάτω σχήµα φαίνεται η «εικόνα» που έχει στην µνήµη η εντολή MOV AX,[1234+SI], τοποθετηµένη στην διεύθυνση µνήµης 0100:0000.
Ο IP ήδη έχει την τιµή
Εικόνα στην µνήµη της εντολής MOV AX,[1234+SI] ∆ηλαδή µετά το διάβασµα των opcode (Βήµα 1) και µετά το διάβασµα της 16 bit διεύθυνσης (Βήµα 3.3) θα έχουµε τα εξής βήµατα :
Πρόσθεση στην ALU του αριθµού που βρίσκεται στον ADR µε το περιεχόµενο του καταχωρητή δείκτη που συµµετέχει στην εντολή.
Στο συγκεκριµένο παράδειγµα θα προστεθεί ο αριθµός 123416 µε τον καταχωρητή SI.
Το αποτέλεσµα της πρόσθεσης αποθηκεύεται από την ALU στον καταχωρητή EAR (Effective Address Register), που βρίσκεται στην έξοδο της ALU και αποθηκεύει τις τελικές διευθύνσεις που προκύπτουν µετά από πράξεις.
1 ΕΑR Å ADR+SI Το περιεχόµενο του ADR προστίθεται µε το περιεχόµενο του SI.
Η πρόσθεση γίνεται στην ALU.
Το αποτέλεσµα καταχωρείται στον EAR.
Βήµα 3.5.
Αν απαιτείται και προσκόµιση τελικής διεύθυνσης σε περίπτωση έµµεσης διευθυνσιοδότησης, για παράδειγµα στην περίπτωση της εντολής CALL [1234], που αντιστοιχεί στον κώδικα µηχανής : FF 16 34 12.
Η εντολή αυτή αποτελεί κλήση υπορουτίνας.
Πρώτα θα πάει στην διεύθυνση µνήµης 1234, θα διαβάσει από εκεί 2 bytes, τα οποία θα τα εκλάβει ως διεύθυνση και σε αυτή την διεύθυνση θα µεταβεί η εκτέλεση του προγράµµατος (έµµεση απόλυτη διευθυνσιοδότηση – Indirect Absolute).
Για την εκτέλεση της εντολής, µετά το διάβασµα των 2 Opcodes (FF 16) που θα γίνει µε τις εντολές του Βήµατος 1 (2 επαναλήψεις), θα ακολουθήσουν άλλοι δύο κύκλοι ανάγνωσης µνήµης για το διάβασµα της παραµέτρου-διεύθυνσης (123416) µε τις εντολές του Βήµατος
Η διεύθυνση µέσω του MDR θα καταχωρηθεί στον 16 bit καταχωρητή ADR, που πάντα αποθηκεύει τις διευθύνσεις που είναι παράµετροι των εντολών.
Πρώτα θα διαβαστεί το byte χαµηλής τάξης (low byte) και θα πάει στον ADRL και στη συνέχεια το byte υψηλής τάξης (high byte) και θα τοποθετηθεί στον ADRH.
Εποµένως στην συνέχεια θα πρέπει να διαβαστεί η τελική διεύθυνση της υπορουτίνας, από την διεύθυνση µνήµης που περιέχει ο ADR.
Εποµένως θα πρέπει ο ADR να εξαχθεί στον MAR και να διαβαστεί το πρώτο byte ης διεύθυνσης, και ση συνέχεια ο ADR να αυξηθεί κατά 1 και να εξαχθεί και πάλι στον MAR, ώστε να διαβαστεί και το 2ο byte της διεύθυνσης.
Η διεύθυνση θα καταχωρηθεί και πάλι στον ADR.
Στο παρακάτω σχήµα φαίνεται η «εικόνα» που έχει στην µνήµη η εντολή CALL [1234],
Εικόνα στην µνήµη της εντολής CALL [1234] ∆ηλαδή µετά το διάβασµα των opcode, δηλαδή των bytes FF 16 που θα γίνει µε τις εντολές του Βήµατος 1, και µετά το διάβασµα της 16 bit διεύθυνσης, που είναι η 1234, που θα γίνει µε τις εντολές του Βήµατος 3.3, θα έχουµε τα εξής βήµατα :
Το περιεχόµενο του ADR µεταφέρεται στον καταχωρητή διεύθυνσης µνήµης (MAR) συνδυαζόµενο µε τον καταχωρητή τµήµατος DS (MAR=DS:ADR=DSx16+ADR), και από εκεί στον εξωτερικό δίαυλο διευθύνσεων (Address Bus).
Μετά από µία χρονική καθυστέρηση (χρόνος προσπέλασης µνήµης) το 1o byte της διεύθυνσης εµφανίζεται στον εξωτερικό δίαυλο δεδοµένων (Data Bus) Αναφορικά µε το συγκεκριµένο παράδειγµα έχει διαβαστεί το byte που περιέχεται στην διεύθυνση 123416, και ας υποθέσουµε ότι εκεί υπάρχει ο αριθµός 78.
Τα δεδοµένα του MDR αντιγράφονται στον ScratchPadL, δηλαδή στο χαµηλής τάξης byte του καταχωρητή προχείρου, καθώς δεν πρέπει να αλλοιωθεί ακόµα η τιµή του ADR, επειδή εκκρεµεί η ανάγνωση και του 2ου byte της διεύθυνσης, στην θέση 123416+1 = 123516.
Και ο µόνος καταχωρητής που περιέχει την διεύθυνση 1234 είναι o ADR, οπότε δεν πρέπει να αλλοιωθεί! της τελικής διεύθυνσης.
Το περιεχόµενο του ADR ∆ΕΝ θα αυξηθεί κατά 1.
Απλά θα γίνει η πράξη ADR+1 στην ALU και το αποτέλεσµα (1235) θα καταχωρηθεί στον EAR:
Το περιεχόµενο του ADR προστίθεται µε τον αριθµό 1 ώστε να προκύψει η επόµενη διεύθυνση µνήµης, και να διαβαστεί και το 2ο byte της τελικής διεύθυνσης.
Η πρόσθεση θα γίνει στην ALU.
Το αποτέλεσµα θα εξαχθεί στον καταχωρητή EAR.
Το περιεχόµενο του EAR µεταφέρεται στον καταχωρητή διεύθυνσης µνήµης (MAR) συνδυαζόµενο µε τον καταχωρητή τµήµατος DS (MAR=DS:EAR=DSx16+EAR), και από εκεί στον εξωτερικό δίαυλο διευθύνσεων (Address Bus).
Τα δεδοµένα του MDR αντιγράφονται στον ScratchPadH, δηλαδή στο υψηλής τάξης byte του καταχωρητή προχείρου,
Τέλος το περιεχόµενο του ScratchPad αντιγράφεται στον ADR που τώρα µπορεί να αλλοιωθεί, καθώς δεν µας χρειάζεται πλέον η διεύθυνση µνήµης 1234.
Τώρα ο ADR περιέχει την τελική διεύθυνση της υπορουτίνας.
Αναφορικά µε το παράδειγµά µας, ο ADR θα έχει την τιµή 567816.
1 MAR Å ADR Το περιεχόµενο του ADR αντιγράφεται στον MAR συνδυαζόµενο µε τον καταχωρητή τµήµατος DS τάξης byte του ScratchPad 5 EAR Å ADR+1 Το περιεχόµενο του ADR προστίθεται µε τη µονάδα και το αποτέλεσµα εξάγεται στον EAR 6 MAR Å EAR Το περιεχόµενο του EAR αντιγράφεται στον MAR 9 SCRH Å MDR Τα δεδοµένα του MDR αντιγράφονται στο υψηλής 10 ADR Å SCR Τα περιεχόµενα του ScratchPad (τελική διεύθυνση) αντιγράφονται στον ADR
Ανάκτηση των τελικών δεδοµένων ¾ Βήµα 4 : Ανάκτηση των τελικών δεδοµένων.
Εάν τα τελικά δεδοµένα δεν περιλαµβάνονται στην εντολή, τότε θα πρέπει να προσκοµιστούν στην CPU για να πραγµατοποιηθεί η εκτέλεση της εντολής.
Παρακάτω παρατίθενται δύο παραδείγµατα εντολών για να γίνει κατανοητή αυτή η διαφορά: Εντολή MOV AL,12 Τα τελικά δεδοµένα (ο αριθµός 12) περιλαµβάνονται στην Εντολή MOV AL,[1234] Τα τελικά δεδοµένα δεν περιλαµβάνονται στην εντολή, αλλά πρέπει να διαβαστούν από την διεύθυνση [1234].
Η διεύθυνση των δεδοµένων βρίσκεται είτε στον ADR (απόλυτη ή έµµεση διευθυνσιοδότηση) είτε στον EAR (δεικτοδοτούµενες διευθυνσοδοτήσεις) είτε στον SP (δεικτοδότηση σωρού – stack).
Παρακάτω αναφέρονται µερικά παραδείγµατα εντολών, ο τρόπος διευθυνσιοδότησής τους και ο καταχωρητής που έχει την διεύθυνση των δεδοµένων: Α/Α Εντολή ∆ιευθυνσιοδότηση Καταχωρητής που έχει την διεύθυνση 1 SBB DX,[1234] Απόλυτη (Absolute) ADR
3 PUSH AX Σωρού (Stack) SP 4 CALL [0500] Έµµεση Απόλυτη (Indirect
Η διεύθυνση του κατάλληλου καταχωρητή µεταφέρεται στον MAR συνδυαζόµενη µε τον καταχωρητή τµήµατος DS (MAR = DS : <καταχωρητής> = DS x 16 + <καταχωρητής>) για τις περιπτώσεις των ADR και EAR, ενώ συνδυάζεται µε τον SS (MAR = SS : <καταχωρητής> = SS x 16 + <καταχωρητής>) αν πρόκειται για τον SP.
Μετά από µία χρονική καθυστέρηση (χρόνος προσπέλασης µνήµης) το byte των δεδοµένων εµφανίζεται στον εξωτερικό δίαυλο δεδοµένων (Data Bus).
Αν η εντολή είναι των 16 bit τότε θα πρέπει να διαβαστεί και 2ο byte δεδοµένων από την επόµενη διεύθυνση.
Για τον λόγο αυτό και επειδή θα ξαναχρησιµοποιηθεί µοιραία ο MDR, θα πρέπει αυτός να αποθηκευθεί στον ScratchPad.
Αν η εντολή είναι των 8 bit τότε ο ScratchPad ∆ΕΝ χρησιµοποιείται, και τα δεδοµένα απλά παραµένουν Παρακάτω αναφέρονται παραδείγµατα εντολών των 8 και 16 bit: Εντολή ADD DH,23 8 bit (λόγω του DH, DH=8bit) Εντολή ADC DX,23 16bit (λόγω του DX, DX=16bit) Εντολή SBB BY[1234],FF 8bit (λόγω του ΒΥ=ΒΥΤΕ) Εντολή SUB WO[1234],FF 16bit (λόγω του WO=WORD)
Για 16 bit εντολές λοιπόν τα παραπάνω βήµατα θα επαναληφθούν άλλη µία φορά για να διαβαστεί και το 2ο byte των δεδοµένων.
Για να σχηµατιστεί η επόµενη διεύθυνση µνήµης, θα γίνει η πράξη <καταχωρητής> + 1 στην ALU και το αποτέλεσµα θα καταχωρηθεί στον EAR.
Όπου <καταχωρητής> εννοείται ο καταχωρητής διεύθυνσης που έχει την διεύθυνση των τελικών δεδοµένων και που κατά περίπτωση µπορεί να είναι ο Στην περίπτωση προσπέλασης της στοίβας, η επαυξηµένη διεύθυνση που βρίσκεται στον EAR αντιγράφεται πάλι στον SP ώστε ο SP να είναι πάντα ενηµερωµένος για την κορυφή
Το περιεχόµενο του <καταχωρητή> (ADR ή EAR ή SP) προστίθεται µε τον αριθµό 1 ώστε να προκύψει η επόµενη διεύθυνση µνήµης, και να διαβαστεί και το 2ο byte των τελικών δεδοµενών.
Η πρόσθεση θα γίνει στην ALU.
Το αποτέλεσµα θα εξαχθεί στον καταχωρητή EAR.
Αν πρόκειται για προσπέλαση στοίβας ο EAR αντιγράφεται στον από εκεί στον εξωτερικό δίαυλο διευθύνσεων (Address Bus).
Στην περίπτωση προσπέλασης στοίβας µεταφέρεται στον καταχωρητή διεύθυνσης µνήµης (MAR) το περιεχόµενο του SP, συνδυαζόµενο µε τον καταχωρητή τµήµατος SS
Έτσι µε την ολοκλήρωση αυτού του βήµατος τα τελικά δεδοµένα βρίσκονται είτε στον MDR, αν πρόκειται για εντολή 8bit, είτε στον ScratchPad, αν πρόκειται για εντολή 16bit.
Α/Α Συµβολική Μικρο-εντολή Σηµασία 1 MAR Å <καταχωρητής> Το περιεχόµενο του <καταχωρητή> (ADR ή EAR ή SP) αντιγράφεται στον MAR συνδυαζόµενο µε τον καταχωρητή τµήµατος DS (MAR = για τις περιπτώσεις των ADR και EAR, ενώ συνδυάζεται µε τον SS (MAR = SS : πρόκειται για τον SP. 2 Wait Αναµονή για να απαντήσει η µνήµη.
Ο χρόνος αυτός ταυτίζεται ή είναι µεγαλύτερος από τον χρόνο απόκρισης της µνήµης. δεδοµένων (Data Bus) αντιγράφεται στον MDR.
Αν η εντολή είναι των 8 bit τότε τελειώνει εδώ 4 SCRL Å MDR Τα δεδοµένα του MDR αντιγράφονται στο χαµηλής τάξης byte του ScratchPad (Επιπρόσθετα SPÅEAR για Το περιεχόµενο του <καταχωρητή> προστίθεται µε τη µονάδα και το αποτέλεσµα εξάγεται στον EAR.
Σε περίπτωση προσπέλασης στοίβας, ο EAR αντιγράφεται στον SP
Το περιεχόµενο του EAR αντιγράφεται στον MAR συνδυαζόµενο µε τον καταχωρητή τµήµατος DS.
Σε περίπτωση προσπέλασης στοίβας, ο SP αντιγράφεται στον MAR 9 SCRH Å MDR Τα δεδοµένα του MDR αντιγράφονται στο υψηλής τάξης byte του ScratchPad
Εκτέλεση της εντολής ¾ Βήµα 5 : εκτέλεση της εντολής.
Ανάλογα µε το είδος της εντολής, σε αυτό το στάδιο απαιτείται µία ακόµα σειρά βηµάτων για την ολοκλήρωση της εντολής και την αποθήκευση των αποτελεσµάτων σε καταχωρητές ή στη µνήµη.
Α/Α Εντολή Καταχωρητής που
1 MOV AL,12 MDR ALÅMDR Αντέγραψε τον 2 ADD AL,[1234] MDR, AL ALÅAL+MDR Πρόσθεσε στον
SCR BXÅSCR Αντέγραψε τον τον CX τον SCR και το Carry bit 6 POP AX SCR AXÅSCR Αντέγραψε τον 7 INC SI SI SIÅSI+1 Αύξησε τον SI 8 CMP DX,ABCD SCR, DX DX~SCR Σύγκρινε τον DX και τον SCR 9 MUL BL AX,BL AXÅAL*BL Πολλαπλασίασε τον AL και τον bit αριθµό που 11 AND DL,FF MDR,DL DLÅDL & MDR Κάνε την λογική και MDR και 12 JMP 0300 ADR IPÅADR Άντέγραψε στον που έχει ο ADR
Αποθήκευση των αποτελεσµάτων ¾ Βήµα 6 : Αποθήκευση των αποτελεσµάτων.
Αν απαιτείται τα τελικά αποτελέσµατα να αποθηκευθούν στην µνήµη, για παράδειγµα στην περίπτωση της εντολής MOV [1234],AL που αντιστοιχεί στον κώδικα µηχανής : A2
34 12, τότε θα απαιτηθούν ένα ή δύο επιπλέον προσπελάσεις στην µνήµη για αποθήκευση των δεδοµένων που µπορεί να είναι των 8 ή των 16 bit.
Σε αυτές τις εντολές η πρώτη παράµετρος είναι πάντα διεύθυνση µνήµης.
H διεύθυνση αποθήκευσης των τελικών δεδοµένων θα βρίσκεται είτε στον ADR, σε περιπτώσεις απόλυτης διευθυνσιοδότησης, είτε στον EAR, σε περιπτώσεις δεικτοδοτούµενων διευθυνσιοδοτήσεων, είτε στον SP σε περιπτώσεις προσπέλασης της στοίβας (εντολές PUSH).
Οπότε ο κατάλληλος κάθε φορά καταχωρητής διεύθυνσης θα πρέπει να εξαχθεί στον MAR συνδυαζόµενος µε τον κατάλληλο καταχωρητή τµήµατος, ώστε να προσπελαστεί η διεύθυνση µνήµης στην οποία θα αποθηκευτεί το αποτέλεσµα.
Αυτή τη φορά όµως θα γίνει ΕΓΓΡΑΦΗ στην µνήµη (write) και όχι ανάγνωση (read).
Αν τα δεδοµένα προς αποθήκευση είναι 16 bit τότε τα παραπάνω θα πρέπει να επαναληφθούν άλλη µία φορά αλλά για την επόµενη διεύθυνση µνήµης, ώστε να αποθηκευθεί και το 2ο byte των αποτελεσµάτων.
Παρακάτω αναφέρονται µερικά παραδείγµατα εντολών, ο τρόπος διευθυνσιοδότησής τους και ο καταχωρητής που έχει την διεύθυνση αποθήκευσης των τελικών αποτελεσµάτων: 1 MOV [1234],AL 8bit Απόλυτη (Absolute) ADR 3 PUSH DX 16bit Σωρού (Stack) SP 8bit Απόλυτη (Absolute) ADR ∆ηλαδή για την αποθήκευση του αποτελέσµατος θα έχουµε τα εξής βήµατα :
Τα δεδοµένα προς εγγραφή αντιγράφονται στον MDR και από εκεί εξάγονται στον εξωτερικό δίαυλο δεδοµένων, µε κατεύθυνση την µνήµη RAM.
Ανάλογα µε την εντολή τα δεδοµένα προς εγγραφή µπορεί να βρίσκονται σε διαφορετικό καταχωρητή δεδοµένων κάθε φορά.
Παρακάτω παρατίθεται µία λίστα µε παραδείγµατα εντολών και αναφορά του καταχωρητή που έχει το αποτέλεσµα προς
1 MOV [1234],AL 8bit AL Ο AL εγγράφεται στην µνήµη 2 ADD [2345+DI],ΒΧ 16bit SCR Γίνεται πρόσθεση µεταξύ του περιεχοµένου της µνήµης [2345+DI] και του BX (στην ALU) και το αποτέλεσµα καταχωρείται στον SCR, για να µην επηρεάσει άλλο 3 PUSH DX 16bit DX Ο DX εγγράφεται στην µνήµη 4 MOV BY[5678],FF 8bit MDR Εδώ τα προς εγγραφή δεδοµένα είναι των 8 bit και γι’αυτό έχουν παραµείνει στον MDR, κατά την ανάγνωση της εντολής
Μετά από µία χρονική καθυστέρηση (χρόνος εγγραφής µνήµης) το byte των δεδοµένων εγγράφεται στην µνήµη, στην διεύθυνση που είχε ήδη καθοριστεί.
Εδώ ολοκληρώνεται η διαδικασία αν τα δεδοµένα που θα αποθηκευτούν είναι των 8 bit.
Αν τα δεδοµένα που θα αποθηκευτούν είναι των 16 bit τότε θα πρέπει να εγγραφεί και το 2ο byte των δεδοµένων στην µνήµη, αλλά στην επόµενη διεύθυνση.
Εντολή ADD [5678],DH 8 bit (λόγω του DH, DH=8bit) Εντολή ADC [7890],DX 16bit (λόγω του DX, DX=16bit) εγγραφεί στην µνήµη και το 2ο byte των αποτελεσµάτων.
Για να σχηµατιστεί η επόµενη διεύθυνση µνήµης, θα γίνει η πράξη <καταχωρητής> + 1 στην ALU και το αποτέλεσµα θα καταχωρηθεί στον EAR.
Όπου <καταχωρητής> εννοείται ο καταχωρητής διεύθυνσης που έχει την διεύθυνση που θα αποθηκευτούν τα αποτελέσµατα, και που κατά περίπτωση µπορεί να είναι ο ADR, ο EAR ή o SP. ώστε να προκύψει η επόµενη διεύθυνση µνήµης, και να εγγραφεί και το 2ο byte των αποτελεσµάτων.
Η πρόσθεση θα γίνει στην ALU.
Το αποτέλεσµα θα εξαχθεί στον
Μετά από µία χρονική καθυστέρηση (χρόνος εγγραφής µνήµης) το 2ο byte του αποτελέσµατος εγγράφεται στην µνήµη.
Εδώ ολοκληρώνεται η διαδικασία αν το αποτέλεσµα είναι των 16 bit.
Τα παραπάνω βήµατα αναλύονται παρακάτω µε συµβολικές εντολές µικροπρογράµµατος 1 MAR Å <καταχωρητής> Το περιεχόµενο του <καταχωρητή> (ADR ή EAR ή SP) αντιγράφεται στον MAR <καταχωρητής>) για τις περιπτώσεις των ADR και EAR, ενώ συνδυάζεται µε τον SS (MAR = <καταχωρητής>) αν πρόκειται για τον SP.
Το περιεχόµενο του καταχωρητή που έχει το αποτέλεσµα της εντολής αντιγράφεται στον MDR.
Αν το αποτέλεσµα είναι των 2 byte τότε µόνο το 1ο byte (low byte) αντιγράφεται. 3 Wait Αναµονή για την εγγραφή στην µνήµη.
Ο χρόνος αυτός ταυτίζεται ή είναι µεγαλύτερος από τον χρόνο εγγραφής µνήµης.
Αν τα αποτελέσµατα είναι των 8 bit τότε τελειώνει
Το 2ο byte (high byte) του καταχωρητή που έχει το αποτέλεσµα της εντολής αντιγράφεται στον αποτελέσµατα είναι των 16 bit τότε η διαδικασία τελειώνει εδώ.
Παραδείγµατα εκτέλεσης εντολών Στη συνέχεια ακολουθούν µερικά ολοκληρωµένα παραδείγµατα εντολών γλώσσας µηχανής του 8088 και των αντίστοιχων µικροεντολών που εκτελούνται για την ολοκλήρωσή της.
Παράδειγµα εκτέλεσης της εντολής CLC Παράδειγµα εκτέλεσης εντολής CLC που αντιστοιχεί στον κώδικα µηχανής F8, από τη θέση Μέγεθος Εντολής : 1 bytes
Αποθήκευση : Σε bit καταχωρητή Φάση Εξωτερική Λειτουργία ΑΒ DB Εσωτερική Μικρο-λειτουργία 3 Επόµενη εντολή 0100:0001 (0001)MAR←IP;
Παράδειγµα εκτέλεσης της εντολής MOV AL,FF Παράδειγµα εκτέλεσης εντολής MOV AL,FF που αντιστοιχεί στον κώδικα µηχανής B0 FF, από τη θέση 0100:0000.
Όταν εµφανίζεται διεύθυνση µέσα σε παρένθεση, π.χ. (1234) εννοείται το byte που περιέχεται στην διεύθυνση αυτή :
Παράδειγµα εκτέλεσης της εντολής MOV AL,[1234] Παράδειγµα εκτέλεσης εντολής MOV AL,[1234] που αντιστοιχεί στον κώδικα µηχανής Α0 34 12, από τη θέση 0100:0000.
Όταν εµφανίζεται διεύθυνση µέσα σε παρένθεση, π.χ. (1234)
3 ∆ιάβασµα high byte 0100:0002 12 MAR←IP;
Παράδειγµα εκτέλεσης της εντολής MOV AX,[1234] Παράδειγµα εκτέλεσης εντολής MOV AX,[1234] που αντιστοιχεί στον κώδικα µηχανής Α1 34 12, από τη θέση 0100:0000 και είναι µία εντολή των 16 bit µε απόλυτη διευθυνσιοδότηση.
Όταν εµφανίζεται διεύθυνση µέσα σε παρένθεση, π.χ. (1234) εννοείται το byte που περιέχεται στην διεύθυνση αυτή :
3 ∆ιάβασµα high byte 0100:0002 12 MAR←IP;
MDR←DB; 6 Επόµενη εντολή 0100:0003 (0003)MAR←IP;
Παράδειγµα εκτέλεσης της εντολής ADD BX,[3456] Παράδειγµα εκτέλεσης εντολής ADD BX,[3456] που αντιστοιχεί στον κώδικα µηχανής 03 1E 56 34, από τη θέση 0100:0000 και είναι µία εντολή των 16 bit µε απόλυτη διευθυνσιοδότηση.
Όταν εµφανίζεται διεύθυνση µέσα σε παρένθεση, π.χ. (1234) εννοείται το byte που περιέχεται στην διεύθυνση αυτή :
Παράδειγµα εκτέλεσης της εντολής ADC DX,[5678+SI] Παράδειγµα εκτέλεσης εντολής ADC DX,[5678+SI] που αντιστοιχεί στον κώδικα µηχανής 13 94 78 56, από τη θέση 0100:0000 και είναι µία εντολή των 16 bit µε δεικτοδοτούµενη
ΑΒ DB Εσωτερική Μικρο-λειτουργία 8 Επόµενη εντολή 0100:0004 (0004) MAR←IP;
Παράδειγµα εκτέλεσης της εντολής JMP [6789] Παράδειγµα εκτέλεσης εντολής JMP [6789] που αντιστοιχεί στον κώδικα µηχανής FF 26 89 67, από τη θέση 0100:0000 και είναι µία εντολή των 16 bit µε έµµεση διευθυνσιοδότηση.
Στην εντολή αυτή υπάρχει εµµεσότητα, δηλαδή πρέπει να διαβαστούν 2 bytes από την διεύθυνση [6789] και αυτά τα bytes να εκληφθούν ως η τελική διεύθυνση στην οποία θα διακλαδωθεί η εκτέλεση του προγράµµατος.
Η διακλάδωση του προγράµµατος σε κάποια άλλη διεύθυνση, που γίνεται µε τις εντολές JMP, Jxx, CALL, RET, INT, IRET, γίνεται πολύ απλά µε αλλαγή της τιµής της διεύθυνσης που έχει µέσα του ο καταχωρητής IP.
Η Μονάδα Ελέγχου πάντα εκτελεί την επόµενη εντολή από την διεύθυνση που «δείχνει» ο IP.
Όταν εµφανίζεται διεύθυνση µέσα σε παρένθεση, π.χ. (1234) εννοείται το byte που περιέχεται στην Αποθήκευση : Σε καταχωρητή (αλλαγή του IP) τοποθέτηση της τελικής
Παράδειγµα εκτέλεσης της εντολής POP CX Παράδειγµα εκτέλεσης εντολής POP CX που αντιστοιχεί στον κώδικα µηχανής 59, από τη θέση 0100:0000 και είναι µία εντολή των 16 bit µε διευθυνσιοδότηση στοίβας (stack).
Η εντολή αυτή θα διαβάσει 2 bytes από την κορυφή της στοίβας στην οποία «δείχνει» ο SP, και θα ενηµερώσει τον SP αυξάνοντάς τον δύο φορές κατά 1.
Να θυµίσουµε εδώ ότι η στοίβα γεµίζει από πάνω προς τα κάτω µε δοµή LIFO (Last In First Out).
Όταν εµφανίζεται διεύθυνση µέσα σε παρένθεση, π.χ. (1234) εννοείται το byte που περιέχεται στην διεύθυνση αυτή.
Υποθέτουµε ότι ο SS έχει την τιµή 0800 και ότι ο SP έχει την τιµή 1234: Μέγεθος Εντολής : 1 byte
5 Εκτέλεση εντολής - - CX ← SCR
Παράδειγµα εκτέλεσης της εντολής MOV [1234],AL Παράδειγµα εκτέλεσης εντολής MOV [1234],AL που αντιστοιχεί στον κώδικα µηχανής Α2 34 12, από τη θέση 0100:0000.
Η εντολή είναι 8 bit αλλά η αποθήκευση των αποτελεσµάτων (AL) γίνεται στην µνήµη (διεύθυνση 1234).
Όταν εµφανίζεται διεύθυνση µέσα σε παρένθεση, π.χ. (1234) εννοείται το byte που περιέχεται στην διεύθυνση αυτή : Αποθήκευση : Στην µνήµη
0100:1234 (AL) MAR←ADR;MDR←AL; wait; (εγγραφή στην µνήµη και τέλος διαδικασίας)
Παράδειγµα εκτέλεσης της εντολής MOV [1234],AΧ Παράδειγµα εκτέλεσης εντολής MOV [2345],AΧ που αντιστοιχεί στον κώδικα µηχανής Α3 34 12, από τη θέση 0100:0000.
Η εντολή είναι 16 bit και η αποθήκευση των αποτελεσµάτων (AΧ) γίνεται στην µνήµη (διεύθυνση 2345).
Όταν εµφανίζεται διεύθυνση µέσα σε δεδοµένων στην µνήµη wait; (εγγραφή στην µνήµη και τέλος
Παράδειγµα εκτέλεσης της εντολής ADD [1234],ABCD Παράδειγµα εκτέλεσης εντολής ADD [1234],ABCD που αντιστοιχεί στον κώδικα µηχανής 81 06 34 12 CD AB, από τη θέση 0100:0000 και είναι µία εντολή των 16 bit µε απόλυτη διευθυνσιοδότηση και αποθήκευση αποτελεσµάτων στην µνήµη.
Στην εντολή αυτή που ίσως είναι από τις πλέον σύνθετες θα πρέπει: β) να διαβαστούν τα 2 bytes της διεύθυνσης 1234, γ) να διαβαστούν τα 2 bytes του αριθµού ABCD, δ) να διαβαστούν τα τελικά δεδοµένα (2 bytes) που βρίσκονται στην διεύθυνση [1234], ε) να προστεθούν αυτά µε τον αριθµό ABCD, στ) να αποθηκευτούν τα 2 bytes του αποτελέσµατος ξανά στην µνήµη.
Κατά την εκτέλεση της εντολής αυτής, και για να µην αλλοιωθεί κανένας κανονικός καταχωρητής του 8088, απαιτείται η χρησιµοποίηση και δεύτερου ScratchPad register, που αναφέρεται στις εντολές ως SCR2.
Ο 1ος ScratchPad απαιτείται για την αποθήκευση του αριθµού ABCD που είναι παράµετρος, και ο 2ος για την αποθήκευση του περιεχοµένου της διεύθυνσης [1234], το οποίο και θα προστεθεί µε τον 1ο ScrathPad, δηλαδή µε τον αριθµό Εντολή : ADD [1234],ABCD Φάση Εξωτερική ΑΒ DB Εσωτερική Μικρο-λειτουργία
6 ∆ιάβασµα high byte 0100:0005 AB MAR←IP;
MDR←DB; 9 Εκτέλεση εντολής - - SCR ← SCR+SCR2 0100:1234 (SCRL) MAR←ADR;MDR←SCRL; wait; (εγγραφή
Κύκλοι Εκτέλεσης Εντολών Σε κάθε περίοδο του ρολογιού που ταυτίζεται µε (1/συχνότητα), εκτελείται µία ή περισσότερες εντολές µικροκώδικα.
Για παράδειγµα στον 8088 που λειτουργεί στα 4,77 MHz η περίοδος του ρολογιού έχει διάρκεια Τ=1/4,77MHz = 0,20964 x10-6sec =
Η περίοδος του ρολογιού χρονισµού του επεξεργαστή Περίοδος του ρολογιού
Κάθε τέτοια περίοδος ονοµάζεται «Μικρός Κύκλος» (minor cycle) ή «Κύκλος Εσωτερικής Κατάστασης» (state cycle).
Είναι η µικρότερη χρονική µονάδα στην οποία µπορεί να εκτελεστεί µία µικρο-λειτουργία του επεξεργαστή, και αποτελεί την µονάδα χρόνου για οποιαδήποτε ενέργεια του επεξεργαστή.
Σε ορισµένες περιπτώσεις είναι δυνατόν δύο τέτοιες µικρο-λειτουργίες να εκτελεστούν παράλληλα.
Αυτό είναι δυνατόν όταν οι λειτουργίες αυτές είναι ανεξάρτητες η µία από την άλλη.
Για παράδειγµα, στην φάση προσκόµισης του Opcode, οι λειτουργίες θα µπορούσαν να υλοποιηθούν σε 3 µικρούς κύκλους :
Παρατηρούµε στον κύκλο T2 την εκτέλεση 2 λειτουργιών που είναι η αύξηση του IP κατά 1 και η αναµονή να απαντήσει η µνήµη, που επειδή είναι τελείως ανεξάρτητες, µπορούν να εκτελεστούν και παράλληλα.
Επίσης στον κύκλο Τ3 η σύνδεση του DB µε τον MDR και η σύνδεση του MDR µε τον IR µπορούν να γίνουν επίσης ταυτόχρονα, ώστε η λέξη που θα «έρθει» από τον δίαυλο δεδοµένων, δια µέσω του MDR να αποθηκευτεί κατ’ ευθείαν στον Επίσης στο παραπάνω παράδειγµα ενδέχεται η φάση της «αναµονής» να διαρκέσει περισσότερους από 1 «µικρούς κύκλους» δηλαδή περιόδους του ρολογιού.
Γνωρίζοντας το πόσους «µικρούς κύκλους» απαιτεί µία διαδικασία, και τν συχνότητα του ρολογιού, µπορούµε να υπολογίσουµε ακριβώς πόσος χρόνος απαιτείται για την περάτωση αυτής της διαδικασίας στην CPU.
Στο παραπάνω παράδειγµα που το opcode απαιτεί 3 κύκλους και η συχνότητα είναι 4,77 MHz (T=0,20964 x10-6sec), η διάρκεια της διαδικασίας ∆ιάρκεια Ανάγνωσης Opcode = 3 x T = 3 x 0,20964x10-6 = 0,62893 x10-6 sec.
Κύκλος Μηχανής (machine cycle) ή Μεγάλος Κύκλος (major cycle) είναι ο χρόνος που απαιτείται για την προσπέλαση µίας θέσης µνήµης και απαιτεί έναν αριθµό από µικρούς κύκλους.
Στο παραπάνω παράδειγµα ανάγνωσης του opcode πραγµατοποιείται µία ανάγνωση µνήµης, για το διάβασµα του Opcode.
Εποµένως η διάρκεια ολόκληρης της διαδικασίας ταυτίζεται µε ένα Κύκλο Μηχανής.
Η έννοια του κύκλου µηχανής είναι πολύ σηµαντική στην εκτέλεση των εντολών.
Κάθε κύκλος µηχανής αντιστοιχεί σε µία προσπέλαση µνήµης.
Η µνήµη όµως είναι πολύ πιο αργή στην απόκρισή της απ’ ότι οι καταχωρητές του επεξεργαστή.
Για τον λόγο αυτό το πλήθος των κύκλων µηχανής που απαιτεί µία εντολή για να ολοκληρωθεί, είναι χαρακτηιστικό του πόσο αργή ή γρήγορη είναι η εντολή αυτή στην εκτέλεση της.
Όσο περισσότερους κύκλους µηχανής χρειάζεται µία εντολή για να εκτελεστεί, τόσο πιο χρονοβόρα είναι η εντολή στην Κύκλος Εντολής (instruction cycle) είναι ο χρόνος ολοκλήρωσης µία εντολής και διαρκεί έναν ή περισσότερους κύκλους µηχανής.
Ο Κύκλος Εντολής είναι διαφορετικός για κάθε εντολή του επεξεργαστή.
Στη συνέχεια δίνεται ένα παράδειγµα εκτέλεσης εντολής και ο χωρισµός της σε κύκλους µηχανής και µικρούς κύκλους Παράδειγµα 1: Κύκλοι Εκτέλεσης της εντολής CLC
Ο κύκλος Τ4 στον οποίο γίνεται µηδενισµός του Carry είναι τόσο µικρός που είναι αµελητέος σε σχέση µε τον κύκλο µηχανής που απαιτεί η προσκόµιση του opcode.
Παράδειγµα 2: Κύκλοι Εκτέλεσης της εντολής MOV AX,1234
Κύκλος Μηχανής 1 Κύκλος Μηχανής 2 Κύκλος Μηχανής 3
Στον κύκλο µηχανής 3 ο χρόνος T4 κατά τον οποίο αντιγράφεται ο SCR στον AX είναι αµελητέος σε σχέση µε την προσπέλαση µνήµης.
Γι’ αυτό και ο κύκλος Τ4 δεν θεωρείται ξεχωριστός Κύκλος Μηχανής.
Γενικά είναι εύκολο να υπολογίσουµε πόσους κύκλους µηχανής απαιτεί µία εντολή για την εκτέλεσή της, µετρώντας το πόσες φορές χρειάζεται να προσπελάσει την µνήµη, είτε για ανάγνωση είτε για εγγραφή σε αυτήν.
Για παράδειγµα η εντολή MOV [1234],AΧ στο παράδειγµα του κεφαλαίου 5.3.10 απαιτεί 5 κύκλους µηχανής, ενώ η εντολή ADD [1234],ABCD στο παράδειγµα του κεφαλαίου 5.3.11 απαιτεί 10 κύκλους µηχανής.
Εντολές, δεδοµένα και διευθύνσεις Σύµφωνα µε την δοµή Von Neumann, που επικρατεί πλέον σε όλες τις αρχιτεκτονικές υπολογιστών, η αναπαράσταση στην µνήµη των εντολών και των δεδοµένων γίνεται µε τον ίδιο τρόπο δηλαδή µε αριθµούς.
Έτσι οι εντολές γλώσσας µηχανής αντιστοιχούν σε αριθµούς όπως και τα δεδοµένα ενός προγράµµατος.
Επόµενο είναι αν δοθεί µία διεύθυνση στην µνήµη, ο επεξεργαστής να µην µπορεί να καταλάβει αν πρόκειται για δεδοµένα ή για εντολή.
Βέβαια ούτε και ο άνθρωπος µπορεί να το καταλάβει αυτό, εκτός και αν ίδιος έχει βάλει το νούµερο εκεί, οπότε και θα ξέρει τι Έτσι όταν η CPU ξεκινά την εκτέλεση ενός προγράµµατος από κάποια διεύθυνση, µε εντολή βέβαια του χειριστή του Η/Υ, τότε ΕΚΛΑΜΒΑΝΕΙ τα bytes που βρίσκει εκεί ως ΕΝΤΟΛΕΣ γλώσσας µηχανής.
Αν τα bytes αυτά δεν αποτελούν εντολές αλλά δεδοµένα, ο επεξεργαστής δεν µπορεί να το καταλάβει.
Έτσι θα τα εκλάβει ως εντολές του κώδικα µηχανής και θα τις εκτελέσει, µε απρόβλεπτες βέβαια συνέπειες, για την έκβαση του προγράµµατος.
Για παράδειγµα, αν στην θέση 0100:0000 έχει τοποθετηθεί η εντολή MOV AX,[59F8+SI], µε αντίστοιχο κώδικα µηχανής 8B 84 F8 59 τότε η εικόνα της στην µνήµη θα πρέπει να είναι αυτή του παρακάτω σχήµατος :
Εικόνα στην µνήµη της εντολής MOV AX,[59F8+SI]
Αν λοιπόν η εκτέλεση του προγράµµατος ξεκινήσει από την διεύθυνση 0100:0000 τότε «όλα θα πάνε καλά» και θα διαβαστούν πρώτα τα δύο opcodes 8Β και 84 και στη συνέχεια τα 2 bytes της διεύθυνσης [59F8], και µετά την προσκόµιση η εντολή θα εκτελεστεί κανονικά.
Στη συνέχει αθα διαβαστεί η επόµενη εντολή κ.ο.κ.
Αν όµως κατά λάθος ξεκινήσει η εκτέλεση του προγράµµατος από την διεύθυνση 0100:0002, τότε η CPU ∆ΕΝ ΘΑ ΚΑΤΑΛΑΒΕΙ ότι το byte που υπάρχει εκεί (F8) αποτελεί το πρώτο byte της διεύθυνσης ΜΙΑΣ ΕΝΤΟΛΗΣ ΠΟΥ ΞΕΚΙΝΑΕΙ 2 BYTES ΝΩΡΙΤΕΡΑ.
Η ενέργεια που θα κάνει η CPU είναι να εκλάβει το byte αυτό (F8) ως TO OPCODE ΜΙΑΣ ΕΝΤΟΛΗΣ ΓΛΩΣΣΑΣ ΜΗΧΑΝΗΣ και να το εκτελέσει.
Συγκεκριµένα το Opcode F8 αντιστοιχεί στην εντολή CLC, και εποµένως η CPU θα εκτελέσει τα κατάλληλα βήµατα για να µηδενίσει το Carry bit του καταχωρητή σηµαιών (FG Στη συνέχεια και εφόσον η πρώτη εντολή δεν είχε παραµέτρους θα διαβάσει το επόµενο byte (59) και θα το εκλάβει ως το opcode ΤΗΣ ΕΠΟΜΕΝΗΣ ΕΝΤΟΛΗΣ.
Συγκεκριµένα το Opcode 59 αντιστοιχεί στην εντολή POP CX, και εποµένως η CPU θα εκτελέσει τα κατάλληλα βήµατα για να ανακαλέσει από την στοίβα την τιµή του καταχωρητή CX, ενηµερώνοντας και τον SP.
Όπως γίνεται κατανοητό, λόγω της εκκίνησης του προγράµµατος από λάθος διεύθυνση, τα byte που αποτελούν παραµέτρους εντολών, εκλαµβάνονται ως opcodes και εκτελούνται, µε απρόβλεπτες βέβαια συνέπειες, καθώς οι αντίστοιχες εντολές γλώσσας µηχανής είναι Εποµένως γίνεται κατανοητό ότι ο προγραµµατιστής και χειριστής του Η/Υ είναι ο µόνος υπεύθυνος για την σωστή εκτέλεση των προγραµµάτων και την εκκίνησή τους από τις
Οι εντολές ενός µικρο-επεξεργαστή χωρίζονται σε αρκετές κατηγορίες που συνήθως είναι :
Εντολές µεταφοράς δεδοµένων µεταξύ καταχωρητών και µνήµης (MOV, PUSH, POP,
Εντολές αριθµητικών πράξεων (ADD, ADC, INC, SUB, SBB, DEC, NEG, MUL,
Εντολές λογικών πράξεων (AND, OR, XOR, TEST, NOT).
Εντολές σύγκρισης καταχωρητών και µνήµης (CMP)
Εντολές ολίσθησης και περιστροφής (SHL, SHR, SAR, ROL, ROR, RCL, RCR)
Εντολές χειρισµού αλφαριθµητικών (REP, MOVS, CMPS, SCAS, LODS, STOS)
Εντολές διακλάδωσης υπό συνθήκη ή άνευ συνθήκης (CALL, JMP, LOOP, INT, JE/NZ,
Ειδικές εντολές που δεν υπάγονται στις παραπάνω κατηγορίες (NOP, CLC, STC, CMC,
Τρόποι διευθυνσιοδότησης µνήµης διαφορετικές παραµέτρους, αλλά δεν συντάσσονται όλες οι εντολές µε όλους τους τρόπους.
Οι διαφορετικοί αυτοί τρόποι σύνταξης ονοµάζονται και τρόποι διευθυνσιοδότησης µνήµης : Στη συνέχεια επεξηγούνται µε παραδείγµατα και µπλόκ διαγράµµατα οι διάφοροι τρόποι διευθυνσιοδότησης µνήµης που χρησιµοποιούνται στην σύνταξη των εντολών γλώσσας
Υπονοούµενος (Implied Addressing Mode) : Η σύνταξη της εντολής δεν περιέχει παράµετρο ή συντάσσεται µε συγκεκριµένο τρόπο ο οποίος υπονοεί το ποιες είναι οι Υπονοούµενος (Implied).
Παράδειγµα : CMC
Σε αυτό τον τρόπο διευθυνσιοδότησης µετά το διάβασµα του opcode (F5) που καταλήγει στον καταχωρητή IR, ακολουθεί αµέσως η εκτέλεση της εντολής
Άµεση προσπέλαση (Immediate/Direct Addressing Mode): σε αυτό τον τρόπο διευθυνσιοδότησης η παράµετρος της εντολής είναι σταθερός αριθµός.
Άµεση Προσπέλαση (Immediate).
Παράδειγµα : SUB AX, 1234
Στην µέθοδο αυτή µετά το διάβασµα του opcode που καταλήγει στον IR , διαβάζεται και ο σταθερός αριθµός που πηγαίνει στον SCR (16bit) ή MDR (8bit).
Στη συνέχεια ακολουθεί η εκτέλεση της εντολής.
Απόλυτη Προσπέλαση (Absolute Addressing Mode) : σε αυτό τον τρόπο διευθυνσιοδότησης η παράµετρος της εντολής είναι σταθερή διεύθυνση.
Παράδειγµα : MOV AX,[2345] (AXÅ (DS:2345))
Απόλυτη Προσπέλαση (Absolute).
Π.χ. : MOV AX,[0300] και η διεύθυνση που είναι παράµετρος της εντολής και καταλήγει στον ADR.
Στη συνέχεια η διεύθυνση αυτή εξάγεται στον MAR για προσκόµιση των τελικών δεδοµένων.
Σε εντολές 16bit θα απαιτηθούν 2 προσπελάσεις στη µνήµη.
Τα τελικά δεδοµένα διαβάζονται και καταλήγουν είτε στον SCR (16bit) είτε παραµένουν στον MDR (8bit).
Στη συνέχεια ακολουθεί η εκτέλεση της εντολής.
Έµµεση Προσπέλαση (Indirect Addressing Mode) : Η εντολή δέχεται ως παράµετρο µία διεύθυνση µνήµης από την οποία διαβάζει κάποια bytes (2 ή 4) τα οποία σχηµατίζουν την τελική διεύθυνση στην οποία θα επενεργήσει η εντολή.
Στην µέθοδο αυτή µετά το διάβασµα του opcode που καταλήγει στον IR , διαβάζεται και η διεύθυνση που είναι παράµετρος της εντολής και καταλήγει στον ADR (0500).
Στη συνέχεια η διεύθυνση αυτή εξάγεται στον MAR για προσκόµιση της διεύθυνσης που υπάρχει εκεί.
Η προσπέλαση µνήµης θα γίνει 2 φορές (0500, 0501) για να διαβαστούν τα 2 bytes της διεύθυνσης.
Αυτά θα αποθηκευτούν στον ADR και θα αντιγραφούν στον IP για αλλαγή της ροής του προγράµµατος.
Ο IP θα προωθηθεί στον MAR και µέσω του MDR θα διαβαστεί το opcode που υπάρχει εκεί.
Απόλυτος ∆εικτοδοτούµενος (Absolute Indexed Addressing Mode).
Η εντολή δέχεται ως παράµετρο µία διεύθυνση µνήµης που αποτελεί την «βάση» ενός πίνακα.
Στην εντολή συµµετέχει και ένας καταχωρητής δείκτη (index) ο οποίος θα προστεθεί στην διεύθυνση βάσης για να δώσει την τελική διεύθυνση των δεδοµένων.
Έµµεσος απόλυτος (Indirect Absolute).
Π.χ. : CALL [0500],
Aπόλυτος ∆εικτοδοτούµενος (Absolute Indexed).
Π.χ. :
Στη συνέχεια στη διεύθυνση αυτή προστίθεται ο καταχωρητής δείκτη που στο παράδειγµα είναι ο SI.
Το αποτέλεσµα αποθηκεύεται στον EAR που εξάγεται στον MAR για να προσπελαστεί η διεύθυνση.
Τα τελικά δεδοµένα διαβάζονται και
Αρχιτεκτονικές CISC - RISC
Μέχρι τα τέλη της δεκαετίας του '70 κυρίαρχη τάση στον σχεδιασµό CPU ήταν η δηµιουργία σύνθετων εντολών µηχανής, οι οποίες διερµηνεύονταν µέσω των κατάλληλων µικροπρογραµµάτων µέσα στις CPU.
Σκοπός της τάσης αυτής ήταν η γεφύρωση του χάσµατος ανάµεσα στις εντολές της γλώσσας µηχανής και αυτές των γλωσσών προγραµµατισµού υψηλού επιπέδου.
Οι εντολές αυτές απαιτούν αρκετούς κύκλους µηχανής, καθώς κάθε εντολή γλώσσας µηχανής αναλύεται σε έναν αριθµό από µικρο-εντολές.
Οι υπολογιστές που βασίζονται σε αυτή την αρχή ονοµάζονται CISC (Complex Instruction Set Computer).
Η µεγάλη πλειοψηφία των µικροεπεξεργαστών που έχουν κατασκευαστεί ποτέ και κατασκευάζονται, ακολουθεί αυτή την τεχνολογία.
Στους επεξεργαστές CISC που διαθέτουν πλούσιο σετ εντολών, µία εντολή υψηλού επιπέδου µίας γλώσσας όπως η C (π.χ.
A=B/2+C*D), υλοποιείται µε λίγες εντολές γλώσσας µηχανής.
Στο συγκεκριµένο παράδειγµα η πράξη θα αναλυθεί σε µία διαίρεση, ένα πολλαπλασιασµό και µία πρόσθεση, καθώς µία CISC CPU συνήθως διαθέτει έτοιµες εντολές γλώσσας µηχανής για πολλαπλασιασµό και διαίρεση.
Στις αρχές της δεκαετίας του '80 παρουσιάστηκε στο Berkeley και στο Stanford µια διαφορετική αντίληψη στον σχεδιασµό των Συνόλων Εντολών, η οποία ονοµάστηκε RISC (Reduced Instruction Set Computers).
Οι πρώτες CPU που σχεδιάστηκαν µε βάση την νέα αντίληψη ήταν ο RISC I και ο MIPS που εξελίχθηκαν στις µηχανές SPARC και MIPS Στην αρχιτεκτονική RISC η έµφαση δόθηκε, αρχικά, στην δηµιουργία Συνόλου Εντολών που θα περιείχαν απλές µόνο εντολές, οι οποίες θα εκτελούνταν ταχύτατα.
Αργότερα, διαπιστώθηκε ότι το κλειδί για την καλή απόδοση ήταν οι εντολές να µπορούν να υποβάλλονται, δηλαδή να ξεκινούν, γρήγορα.
Ο χρόνος που χρειαζόταν η εντολή για να εκτελεστεί είχε µικρότερη σηµασία από το πόσες εντολές µπορούσαν να ξεκινήσουν ανά δευτερόλεπτο.
Συνοψίζοντας, σήµερα υπάρχει ένα σύνολο αρχών σχεδιασµού, οι Αρχές Σχεδιασµού RISC, τις οποίες προσπαθούν να ακολουθήσουν όλοι οι κατασκευαστές CPU γενικής χρήσης.
Οι Αρχές αυτές προβλέπουν τα ακόλουθα :
Εκτέλεση εντολών απευθείας από το υλικό.
Στις RISC CPU δεν υπάρχει µικροπρόγραµµα και διερµηνεία των εντολών.
Αντίθετα, κάθε εντολή εκτελείται άµεσα από κάποιο τµήµα υλικού µέσα στη CPU.
Έτσι οι RISC επεξεργαστές χρησιµοποιούν Μονάδες Ελέγχου κατασκευασµένες αποκλειστικά µε ψηφιακά κυκλώµατα (Hard-Wired
Μέγιστος ρυθµός υποβολής εντολών.
Όπως είδαµε κρίσιµος παράγοντας για την µεγιστοποίηση της απόδοσης µιας CPU είναι να υποβάλλονται ταυτόχρονα όσο το δυνατόν περισσότερες εντολές.
Αυτό µπορεί να επιτευχθεί χρησιµοποιώντας παραλληλία και άλλους τρόπους.
Εύκολη αποκωδικοποίηση των εντολών.
Ένα κρίσιµο όριο για τον ρυθµό υποβολής των εντολών οφείλεται στην ανάγκη να αποκωδικοποιούνται οι µεµονωµένες εντολές για να προσδιοριστεί τι πόρους χρειάζονται.
Για εύκολη αποκωδικοποίηση οι εντολές θα πρέπει να έχουν κανονική µορφή (opcode+operands), σταθερό µήκος και µικρό αριθµό τελεστέων.
Όσο δε λιγότερες µορφές των εντολών υπάρχουν τόσο το καλύτερο.
Περιορισµός εντολών που προσπελαύνουν την µνήµη.
Λόγω του ότι η προσπέλαση στη µνήµη είναι µια αργή και απρόβλεπτη, χρονικά, διαδικασία, θα πρέπει όλες οι εντολές, εκτός αυτών της µορφής LOAD και STORE (MOV), να χρησιµοποιούν τους καταχωρητές και όχι τη µνήµη.
Αφθονία καταχωρητών γενικής χρήσης.
Για να ικανοποιηθεί η προηγούµενη αρχή θα πρέπει να υπάρχουν πολλοί καταχωρητές στη CPU, ώστε να µπορούν να αποθηκευτούν πολλά δεδοµένα σε κάθε στιγµή.
Η εξάντληση των καταχωρητών και η ανάγκη µεταφοράς των δεδοµένων τους στη µνήµη και αργότερα πάλι στη CPU είναι ανεπιθύµητη κατάσταση και µπορεί να αποφευχθεί µόνο µε την αφθονία καταχωρητών
Παραδείγµατα RISC επεξεγαστών : SPARC (SUN), MIPS (MIPS Technologies Inc.), Alpha (DEC), POWER4 (IBM).
Χρησιµοποιούνται σε Workstations υψηλών δυνατοτήτων.
Παρόλα τα πλεονεκτήµατα της αρχιτεκτονικής RISC, οι SPARC, MIPS, Alpha και οι άλλες RISC CPU, δεν κατόρθωσαν να υποσκελίσουν τους CISC µ/ε της Intel.
Ενας λόγος γι' αυτό ήταν η συµβατότητα προς τα πίσω που προσέφερε η Intel.
Ένας άλλος λόγος ήταν ότι η Intel ενσωµάτωσε στοιχεία RISC στους CISC µ/ε της, δηµιουργώντας υβριδικές CPU που συνδύαζαν τα πλεονεκτήµατα και των δύο αρχιτεκτονικών.
Έτσι, από τον 80486 και µετά, όλες οι CPU της Intel έχουν έναν πυρήνα RISC, ο οποίος εκτελεί τις απλούστερες εντολές, που είναι και οι πιο συνηθισµένες, ενώ οι σύνθετες εντολές εκτελούνται µέσω µικροπρογραµµάτων και διερµηνείας, όπως σε κάθε CISC µ/ε.
Το τελικό αποτέλεσµα είναι οι πιο συνηθισµένες εντολές να είναι γρήγορες και οι λιγότερο συνηθισµένες πιο αργές.
Έτσι, η υβριδική αυτή αρχιτεκτονική προσφέρει ανταγωνιστική απόδοση, σε σχέση µε µια καθαρά RISC CPU, και ταυτόχρονα επιτρέπει την εκτέλεση παλαιότερου λογισµικού χωρίς καµιά
Κεφάλαια του Μαθήματος Κεφάλαιο 1.
Εισαγωγή στον Η/Υ BGC-8088 και τον M/E Intel 808
Καταχωρητές γενικής και ειδικής χρήσης
Η προσπέλαση μνήμης στον 8088
Τμήματα προγράμματος και καταχωρητές
Λειτουργικό Διάγραμμα Καταχωρητών
Η μνήμη του BGC-8088
Η μνήμη ROM του BGC-8088
Ο χάρτης μνήμης του BGC-8088
Οι Εντολές Γλώσσας Μηχανής του 8088
Εντολές Μεταφοράς Δεδομένων
Εντολές Αριθμητικών Πράξεων
Εντολές Λογικών Πράξεων
Εντολές Χειρισμού Αλφαριθμητικών
Εντολές Ελέγχου Ροής Προγράμματος
Εντολές Ελέγχου του Επεξεργαστή
Οι κωδικοί των εντολών
Τρόποι Σύνταξης των Εντολών
Συνδυασμοί Σύνταξης των Εντολών
Τρόποι Διευθυνσιοδότησης Μνήμης
Οι drivers και ο τρόπος χειρισμού του hardware Κεφάλαιο 2: Ιστορία και Εξέλιξη των Υπολογιστών
Πρώτη Γενιά Υπολογιστών - Λυχνίες Κενού (1945-1955)
Δεύτερη Γενιά - Τρανζίστορ (1955-1965)
Τρίτη Γενιά - Ολοκληρωμένα Κυκλώματα (1965-1980)
Τέταρη Γενιά-Ολοκλήρωση μεγάλης κλίμακας (1980-σήμερα)
Εξέλιξη και Κατηγορίες Υπολογιστών
Κατηγορίες Υπολογιστών και κλίμακα κόστους Κεφάλαιο 3.
Βασικά και σύνθετα ψηφιακά κυκλώματα
Υλοποίηση Συναρτήσεων Boole
Προγραμματιζόμενοι Λογικοί Πίνακες (Programmable Logi
Αριθμητικές και Λογικές Μονάδες (Arithmetic and Logic
Κυκλώματα Ρολογιού (Clocks)
Κυκλώματα Μνήμης (Memory Circuits)
Κυκλώματα Μανδάλωσης (Latch Circuits)
Δισταθή Κυκλώματα (FLIP-FLOP)
Γενικά για τους Μικροεπεξεργαστές
Εσωτερική δομή μικροεπεξεργαστων
Τα βασικά μέρη ενός μικροεπεξεργαστή
Οι εσωτερικοί καταχωρητές του μικροεπεξεργαστή
Η Αριθμητική και Λογική Μονάδα
Μονάδα Κινητής Υποδιαστολής (Floating Point Unit – FP
Η κωδικοποίηση των δεκαδικών αριθμών
Κριτήρια Επιλογής Μκροεπεξεργαστή
Μέτρηση της απόδοσης ενός Μικροεπεξεργαστή Κεφάλαιο 5.
Η δομή των εντολών
Οι εντολές γλώσσας μηχανής
Η εκτέλεση των εντολών γλώσσας μηχανής
Προσκόμιση της εντολής
Αποκωδικοποίηση της εντολής
Ανάγνωση παραμέτρων - υπολογισμός και ανάγνωση τελική
Ανάκτηση των τελικών δεδομένων
Εκτέλεση της εντολής
Αποθήκευση των αποτελεσμάτων
Παραδείγματα εκτέλεσης εντολών
Παράδειγμα εκτέλεσης της εντολής CLC
Παράδειγμα εκτέλεσης της εντολής MOV AL,FF
Παράδειγμα εκτέλεσης της εντολής MOV AL,[1234]
Παράδειγμα εκτέλεσης της εντολής MOV AX,[1234]
Παράδειγμα εκτέλεσης της εντολής ADD BX,[3456]
Παράδειγμα εκτέλεσης της εντολής ADC DX,[5678+SI]
Παράδειγμα εκτέλεσης της εντολής JMP [6789]
Παράδειγμα εκτέλεσης της εντολής POP CX
Παράδειγμα εκτέλεσης της εντολής MOV [1234],AL
Παράδειγμα εκτέλεσης της εντολής MOV [1234],AΧ
Παράδειγμα εκτέλεσης της εντολής ADD [1234],ABCD
Κύκλοι Εκτέλεσης Εντολών
Εντολές, δεδομένα και διευθύνσεις
Τρόποι διευθυνσιοδότησης μνήμης
