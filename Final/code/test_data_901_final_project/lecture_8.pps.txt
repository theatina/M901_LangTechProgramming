Προγραμματισμός II
Δείκτες σε δείκτες
Τα μεγέθη των πινάκων ρυθμίζονται με δυναμική διαχείριση μνήμης:
Αποτέλεσμα: Zero,One,Two,Z,O,T!
Χώρος για 3 (pointers-to-char)
Χώρος για 40 χαρακτήρες
Χρησιμοποιεί το δείκτη του πίνακα για να επιλέξει αλφαριθμητικό
Ο δεύτερος δείκτης επιλέγει χαρακτήρες στο αλφαριθμητικό
Απελευθερώνει τη μνήμη στο τέλος
(το name δείχνει σε δεσμευμένη μνήμη
κι όχι το **name !!)
“Δέσμευσε ένα μπλοκ μνήμης,
επαρκές για 3 δείκτες χαρακτήρα.
Στη συνέχεια να επιστρέψεις ένα δείκτη σ’ αυτό”.
Τι συμβαίνει:
(Κάθε στοιχείο είναι ένας δείκτης χαρακτήρα.
Ο μηδενικός δείκτης είναι το ‘name[0]’,
ο πρώτος δείκτης είναι το ‘name[1]’, κ.λ.π.)
(δείκτης σε λίστα δεικτών χαρακτήρα)
“Kάθε δείκτης της λίστας πρέπει να δείχνει σε αλφαριθμητική σταθερά που είναι αποθηκευμένη στη μνήμη”
“Απελευθέρωσε το μπλοκ μνήμης που είχε δεσμευτεί με το δείκτη ‘name’”
Παράδειγμα:
Διαφορετικές θέσεις μνήμης.
Το name στη στοίβα και τα υπόλοιπα στο σωρό.
Εάν δηλωθεί πίνακας με τον κλασσικό τρόπο θα αποθηκευθεί στην στοίβα.
Παράδειγμα με μεγάλο πίνακα και stack overflow (1 τραγούδι 3΄ με ποιότητα cd – 44.1 KHz).
Πολυδιάστατοι πίνακες float:
Δήλωσε δείκτη σε λίστα δεικτών
Δημιουργεί ένα μπλοκ rmax pointers-to-float
Δημιουργεί ένα μπλοκ από cmax floats για κάθε pointer-to-float
Τέλος; Να αντιστραφεί η διαδικασία: αρχικά να απελευθερωθεί κάθε μπλοκ από floats και στη συνέχεια κάθε μπλοκ από pointers-to-float
“Δέσμευσε μπλοκ μνήμης για
(δείκτης σε λίστα δεικτών float)
“Για κάθε δείκτη δέσμευσε ένα μπλοκ μνήμης για cmax floats”
(μπλοκ από cmax floats==>)
“Προσπέλασε τον x-στό δείκτη
και πάρε την y-στή float τιμή του”
