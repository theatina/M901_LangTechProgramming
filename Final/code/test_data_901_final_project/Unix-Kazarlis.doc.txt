Λειτουργικά Συστήματα ΙΙ Εργαστήριο (Unix) Σπυρίδων Α.
Καζαρλής (Dipl.-Eng., PhD) Μιχάλης Σαββόπουλος (BSc,PhD)
Τομέας Αρχιτεκτονικής Η/Υ & Βιομηχανικών Εφαρμογών
Εισαγωγή και βασικές εντολές 11.1 Εισαγωγή, πυρήνας, κέλυφος, βασικά αρχεία και βασικές εντολές.
Ανακατεύθυνση Εισόδου-Εξόδου και Διοχετεύσεις
Σύστημα Αρχείων (filesystem)
Εντολές καταλόγων(pwd, cd, mkdir, rmdir)
Εντολές ελεύθερου και χρησιμοποιημένου χώρου (df, du)
Βασικές Εντολές – Δικαιώματα Αρχείων
Προσκήνιο και παρασκήνιο
Τα δικαιώματα χρήσης αρχείων και καταλόγων στο UNIX.
Ο κειμενογράφος vi και οι κανονικές εκφράσεις
Αποκοπή, αντιγραφή και επικόλληση
Κανονικές Εκφράσεις (Regular expressions)
Αντικατάσταση στο vi και Περισσότερες Κανονικές Εκφράσεις
Προγράμματα Σεναρίου Κελύφους (shell scripts)
Προγράμματα Σεναρίου κελύφους (Shell Scripts), Μεταβλητές, Παράμετροι, και εντολές echo και for.
Προγράμματα Κελύφους (Shell Scripts)
Βρόχος for (for loop)
Δομές συνθηκών και βρόχων υπό συνθήκη σε προγράμματα κελύφους
Συνθήκες, if, test, while, until, expr
Εντολές case και eval και κατασκευή ολοκληρωμένου προγ/τος κελύφους.6-
Κενή εντολή (null command)
Φίλτρα στο Unix
Φίλτρα 1: grep, fgrep, egrep, sort, uniq, cmp, comm, tr, diff
Ο κειμενογράφος ed και το φίλτρο sed
Άσκηση shell_users
Εντολή set και εφαρμογή Μενού
Άλλες σημαντικές εντολές
Εντολές true και false, Ατέρμονες κύκλοι
Η εντολή set, ο διαχωριστής (IFS) και η εντολή export
Περισσότερα για την εντολή echo
Ανακατευθύνσεις και η εντολή exec
Πρώτο μάθημα awk
Εντολές μπορούν να είναι οι ακόλουθες :
Προηγμένες δυνατότητες της AWK
Πίνακες απλοί και προσεταιριστικοί
Συμπληρωματικές Ασκήσεις AWK
Συμπλήρωμα με Λυμένες και Άλυτες Ασκήσεις
Άσκηση del_char
Άσκηση user_space
Άσκηση lexicon_script
Άσκηση repeat_string
Άσκηση rev_vowels
Άσκηση del_lines
Άσκηση groups_aetos
Άσκηση users_time_it
Άσκηση Φορολογική Δήλωση
Άσκηση same_words
Άσκηση vi_users_space
Άσκηση hard_links_space
Άσκηση group_space
Άσκηση Διαχείριση Αρχείων 3712.2.2 Άσκηση rev_lines
Άσκηση add_params
Άσκηση user_data
Άσκηση Διπλασιασμός Κενών
Άσκηση Διαχείριση Χρηστών
Άσκηση Σύγκριση καταλόγων
2Σχήμα 1-1.
Επίπεδα λειτουργίας των τμημάτων του UNIX 1Πίνακας 1-1.
Σύγκριση MS-DOS και Unix Πίνακας 1-2.
Σύγκριση των shells του Unix Πίνακας 1-3.
Χρήσιμοι συνδυασμοί πλήκτρων στο Unix Πίνακας 2-1.
Δικαιώματα αρχειων στο Unix Πίνακας 2-2.
Η σημασία των παραμέτρων της chmod Πίνακας 2-3.
Σχηματισμός οκταδικού αριθμού δικαιωμάτων.
Πίνακας 2-4.
Παραδείγματα δικαιωμάτων αρχείων και καταλόγων Πίνακας 3-1.
Εντολές εισαγωγής κειμένου Πίνακας 3-2.
Εντολές μετακίνησης στο vi Πίνακας 3-3.
Εντολές σβησίματος στο vi Πίνακας 3-4.
Εντολές αναζήτησης κειμένου στο vi Πίνακας 3-5.
Μεταχαρακτήρες κανονικών εκφράσεων Πίνακας 3-6.
Παραδείγματα εντολών ατικατάστασης στο vi Πίνακας 5-1.
Παράμετροι της test που σχετίζονται με αρχεία Πίνακας 5-2.
Παράμετροι της test που σχετίζονται με strings Πίνακας 5-3.
Παράμετροι της test που σχετίζονται με ακεραίους Πίνακας 5-4.
Παράμετροι της test που σχετίζονται με σύνθετες συνθήκες Πίνακας 5-5.
Παραδείγματα με την if και την test Πίνακας 5-6.
Παραδείγματα υπολογισμών με την expr Πίνακας 10-1.
Εντολές της AWK
To σύγγραμμα αυτό αποτελεί το βασικό διδακτικό βοήθημα για το μάθημα «Λειτουργικά Συστήματα ΙΙ – Εργαστήριο (Unix)» που διδάσκεται στο Τμήμα Πληροφορικής & Επικοινωνιών του ΤΕΙ Σερών στο 3ο εξάμηνο σπουδών.
Το αντικείμενο του συγγράμματος είναι το Λειτουργικο Σύστημα Unix/Linux.
Σκοπός του είναι η εξοικείωση των φοιτητών με την δομή, την λειτουργία, τις εντολές, και τον τρόπο χειρισμού του Unix/Linux.
Εκτός όμως από την περιγραφή της δομής του Unix, τον τρόπο λειτουργίας του κελύφους (shell), τις βασικές εντολές για διαχείριση του συστήματος, και την περιγραφή του συστήματος αρχείων του Unix, και της ασφάλειας που παρέχει μέσω των δικαιωμάτων αρχείων, προχωρά σε πιο προηγμένα θέματα.
Τέτοια θέματα είναι τα φίλτρα στο Unix (more, grep, sort, sed, tr, κ.λ.π.), η χρήση κανονικών εκφράσεων (regular expressions), και ο προγραμματισμός στο κέλυφος, δηλαδή η ανάπτυξη αρχείων σεναρίου κελύφους (shell scripts), για την εκτέλεση σύνθετων διαδικασιών, που έχουν χρησιμότητα τόσο στους απλούς χρήστες όσο και στους διαχειριστές των συστημάτων.
Η μελέτη αυτή γίνεται για συγκεκριμένο κέλυφος που είναι το Bourne Shell.
Ειδικότερα για τον προγραμματισμό του κελύφους γίνεται εκτενής ανάλυση των δομών εντολών που αυτό επιτρέπει μέσα στα shell scripts (if, for, while, until, case, κλ.π.), αναφέρονται επιπλέον εντολές όπως η «test» η «expr» και η «set», και δίνονται εκτενή παραδείγματα προγραμμάτων σεναρίου κελύφους για την εξοικείωση του φοιτητή.
Τέλος αναλύεται και η γλώσσα «AWK» που είναι ιδιαίτερα αποτελεσματική στα προγράμματα κελύφους για την διαχείριση αρχείων με εγγραφές και πεδία αλλά και την υλοποίηση σύνθετων διαδικασιών, όπως οι πράξεις με δεκαδικούς αριθμούς και η χρήση πινάκων.
Σε κάθε κεφάλαιο του συγγράμματος υπάρχουν ασκήσεις για τους φοιτητές με τις λύσεις τους, ώστε να αναδεικνύεται η πρακτική χρησιμότητα της θεωρίας αλλά και ο σωστός τρόπος εφαρμογής της, ενώ στο τελευταίο κεφάλαιο (12ο) παρατίθεται μία σειρά από λυμένες και άλυτες ασκήσεις για τους φοιτητές.
Το UNIX είναι ένα λειτουργικό Σύστημα για πολλούς χρήστες ο καθένας από τους οποίους μπορεί να εκτελεί ταυτόχρονα πολλές εργασίες στο σύστημα. (Multiuser-πολλοί χρήστες, Multitasking-Πολλές Διεργασίες) Αυτό γίνεται με το κατάλληλο μοίρασμα του χρόνου του επεξεργαστή έτσι ώστε να εκτελούνται χωρίς πρόβλημα όλες αυτές οι διεργασίες που ο κάθε χρήστης βάζει στο σύστημα.
Τι είναι το λειτουργικό σύστημα;
Είναι οργάνωση του hardware σε ένα αποτελεσματικό, ασφαλές και οργανωμένο σύστημα επεξεργασίας πληροφοριών (hardware manager).
Το UNIX δημιουργήθηκε το 1966 στα Bell laboratories από τον Ken Thomson σε ένα υπολογιστή DEC PDP-7 σε γλώσσα μηχανής, για εσωτερική χρήση της Bell (ομαδική εργασία χρηστών).
Ξαναγράφηκε σε C το 1973 από τον Dennis Ritchie και απέκτησε έτσι μεταφερσιμότητα (transportability).
Μετά μεταφέρθηκε στα Πανεπιστήμια και έτσι απέκτησε πολλές εκδόσεις.
Στον επόμενο πίνακα φαίνεται το Unix σε σύγκριση με το MSDOS:
Ελάχιστη ασφάλεια αρχείων Πλήρες σύστημα ασφάλειας αρχείων οργανωμένο σε πολλά επίπεδα (χρήστη, ομάδας, directory, αρχείο, αναλυτικά καθοριζόμενα δικαιώματα επεξεργασίας) Ελάχιστες δικτυακές λειτουργίες Εξαιρετικές δικτυακές υπηρεσίες (Telnet, Ftp, web) Απλό Λειτουργικό – Ελάχιστες απαιτήσεις administration Σύνθετο λειτουργικό – απαραίτητο το system administration Πολλές και προσιτές εφαρμογές Λίγες και ακριβές εφαρμογές Φθηνές πλατφόρμες MSDOS (PCs) Ακριβές πλατφόρμες UNIX (Workstations) – αναφορά στο LINUX
Πίνακας 1-1.
Σύγκριση MS-DOS και Unix Το UNIX σαν σύστημα είναι κτισμένο έτσι ώστε στην βάση του να υπάρχει ο πυρήνας του συστήματος (kernel) –κατά κάποιο τρόπο το μυαλό του συστήματος και γύρω από αυτόν υπάρχουν τα διάφορα κελύφη (shells) που είναι οι μεταφραστές που ζητάνε από τον πυρήνα να εκτελέσει τις δικές μας εντολές.
Στο σύστημα ανά πάσα στιγμή μπορούν να τρέχουν για τον ίδιο χρήστη πολλά κελύφη σε πολλά επίπεδα όπως φαίνεται και στο σχήμα.
Στο καθένα από αυτά τα κελύφη τρέχει ένας αριθμός από προγράμματα-εφαρμογές.
Το prompt είναι $ ή # για superuser Κελύφη υπάρχουν διαφόρων ειδών, και ανήκουν σε δύο κατηγορίες.
Σε αυτά που είναι Bourne Shells και σε αυτά που είναι C-shells.
Στο εργαστήριο θα δουλέψουμε σε Bourne Shell οπότε όλες οι εντολές θα δίνονται για αυτό. korn (Μοιάζει με bourne αλλά είναι άλλο κέλυφος)
Για να μπορέσουμε να μπούμε μέσα στο σύστημα χρειαζόμαστε να εισάγουμε ένα όνομα χρήστη (username-login) και έναν κωδικό (password) Μερικές πολύ χρήσιμες εντολές που πρέπει συχνά να εκτελεί κανείς μόλις μπει στο σύστημα είναι οι:
Αυτή καθορίζει τον τύπο του τερματικού σε vt100.
Και :
Αυτή καθορίζει την δράση του πλήκτρου backspace να είναι το σβήσιμο των προηγούμενων χαρακτήρων, πράγμα που γίνετε από το σύστημα με το πλήκτρο <CTRL> H. (Πολλές φορές αυτό το βλέπουμε ως ^Η) Αυτές τις εντολές είναι πολλές φορές σκόπιμο να τις βάλουμε να εκτελούνται αυτόματα από το σύστημα με την είσοδο μας σε αυτό.
Αυτό γίνεται όταν τις βάλουμε μέσα στο αρχείο .profile κατά προτίμηση μετά από τις εντολές που έχει ήδη μέσα αυτό το αρχείο.
Αν το πληκτρολόγιο μας παρουσιάζει περίεργη συμπεριφορά καλά είναι να δοκιμάσουμε να εκτελέσουμε τις εντολές:
Στο UNIX τα πάντα είναι αρχεία, ακόμα και οι συσκευές.
Γενικά στα αρχεία μπορούμε να δώσουμε ονόματα που να περιέχουν οποιουσδήποτε χαρακτήρες, ακόμα και κενό, όμως από την χρήση θα καταλάβουμε ότι είναι καλύτερα να περιοριστούμε σε γράμματα, αριθμούς και “_” (underscore).
Παράδειγμα για να καταλάβουμε το γιατί θα δώσουμε στο δεύτερο μάθημα.
Στο UNIX επίσης υπάρχει διαχωρισμός κεφαλαίων και μικρών γραμμάτων (Οι εντολές του UNIX είναι με μικρά και οι παράμετροι του συστήματος με κεφαλαία).
Στο κέλυφος υπάρχουν χαρακτήρες μπαλαντέρ ή αλλιώς wild characters: ‘*’, ‘?’, ‘[]’.
Το αστεράκι ‘*’ αντιπροσωπεύει έναν ή περισσότερους χαρακτήρες, το Αγγλικό ερωτηματικό ‘?’ έναν χαρακτήρα και οι παρενθέσεις ‘[]’ έναν από τους χαρακτήρες που περιέχουν.
Παράδειγμα η εντολή ls pay[1-3] σημαίνει pay1, pay2, pay3.
Η εντολή ls pay[1,3] σημαίνει pay1, pay3.
Διαχωριστής παραμέτρων στο UNIX είναι το κενό και το tab.
Η καθιερωμένη είσοδος στο UNIX είναι το πληκτρολόγιο, ενώ η καθιερωμένη έξοδος και η καθιερωμένη έξοδος λαθών είναι η οθόνη.
Αυτά όμως μπορούν να αλλάξουν και να γίνει είσοδος και έξοδος από κάποιο αρχείο ή συσκευή (Όπως είπαμε και οι συσκευές είναι αρχεία) Η είσοδος αλλάζει με τον χαρακτήρα ‘<’ και η έξοδος με τον χαρακτήρα ‘>’.
Αυτό λέγεται ανακατεύθυνση (redirection) ενώ υπάρχει και η δυνατότητα διοχέτευσης (Piping) που στέλνει την έξοδο μιας εντολής σαν είσοδο σε μια άλλη εντολή.
Αυτό γίνεται με το σύμβολο ‘|’ ή με την εντολή ‘tee’.
Παραδείγματα είναι τα ακόλουθα:
Στην πρώτη περίπτωση η έξοδος της εντολής cat στέλνεται μέσα στο αρχείο file2, στην δεύτερη η εντολή ps στέλνει την έξοδο της στην grep η οποία την λαμβάνει σαν είσοδο.
Τέλος η εντολή mail παίρνει είσοδο από το αρχείο file1.
Μερικοί χρήσιμοι συνδυασμοί πλήκτρων που πρέπει να γνωρίζουμε είναι: Σβήσιμο προηγούμενου χαρακτήρα
Τέλος εισαγωγής δεδομένων από πληκτρολόγιο Σταματάει την εκτέλεση της τρέχουσας εντολής.
Τα κυριότερα αρχεία στο σύστημα είναι τα αρχεία /etc/passwd και /etc/group.
Στην συνέχεια θα δούμε με αρκετές λεπτομέρειες τι περιέχουν αυτά τα αρχεία.
Το αρχείο /etc/passwd περιέχει τις πληροφορίες για τους χρήστες και τους δαίμονες του συστήματος.
Η κάθε του σειρά χωρίζεται σε 7 πεδία με την άνω και κάτω τελεία (:).
Σχηματικά είναι ως εξής: Το login είναι το όνομα του κάθε χρήστη.
Το passwd είναι ο κωδικός του.
Το UID είναι ένας αριθμός, μοναδικός για κάθε χρήστη από τον οποίο αναγνωρίζει το σύστημα τον συγκεκριμένο χρήστη.
Το GID είναι ένας αριθμός μοναδικός για κάθε ομάδα χρηστών με τον οποίο καταλαβαίνει το σύστημα την συγκεκριμένη ομάδα χρηστών.
Εδώ πρέπει να πούμε ότι οι χρήστες ανήκουν σε ομάδες ανάλογα με τις εργασίες που κάνουν και τα δικαιώματα που τους χρειάζονται για αυτές τις εργασίες.
Το Gecos είναι ένα πεδίο όπου γράφονται πληροφορίες για τον χρήστη όπως πραγματικό όνομα, διεύθυνση κλπ που θέλει ο χρήστης να μπορούν να βλέπουν οι υπόλοιποι χρήστες.
Το home είναι ο αρχικός κατάλογος στον οποίο μπαίνει ο χρήστης με την είσοδό του στο σύστημα.
Τέλος το shell είναι το αρχικό κέλυφος που χρησιμοποιεί ο χρήστης με την είσοδό του στο σύστημα.
Σε μας αυτό το κέλυφος πρέπει να είναι το /bin/sh.
Στο πεδίο του passwd θα δει κανείς ότι είτε έχει ένα αστεράκι είτε κάποιους χαρακτήρες διαφορετικούς από τον κωδικό που βάζει ο χρήστης.
Αυτό γίνεται γιατί στην μία περίπτωση οι κωδικοί βρίσκονται σε άλλο αρχείο για ασφάλεια ενώ στην άλλη βρίσκονται μεν εδώ αλλά κωδικοποιημένοι με έναν μηχανισμό έτσι ώστε να μην μπορεί να τους βρει κάποιος άλλος από τον κάθε χρήστη.
Παρακάτω φαίνεται μια τυπική καταχώρηση στο αρχείο /etc/passwd για τον χρήστη kazarlis
Τα μοναδικά πεδία που μπορεί να αλλάξει κάποιος είναι το passwd με την εντολή passwd (/bin/passwd) το Gecos με την εντολή chfn και το shell με την εντολή chsh.
Το αρχείο /etc/group περιέχει 4 πεδία που χωρίζονται από την άνω και κάτω τελεία.
Το πρώτο πεδίο περιέχει το όνομα της ομάδας χρηστών.
Το δεύτερο περιέχει ένα αστεράκι που παραμένει μόνο για συμβατότητα με παλαιότερα συστήματα, το τρίτο τον αριθμό της ομάδας χρηστών GID και το τελευταίο τους επιπλέον χρήστες της κάθε ομάδας.
Εδώ πρέπει να πούμε ότι ένας χρήστης μπορεί να ανήκει σε πολλές ομάδες, και η κύρια ομάδα του φαίνεται ήδη από το /etc/passwd.
Επιπλέον χρήστης λοιπόν είναι κάποιος που ανήκει σε μια δεύτερη και τρίτη ομάδα εκτός από αυτήν που φαίνεται στο /etc/passwd.
Έτσι αν κάποιος χρήστης ανήκει πρωταρχικά στην ομάδα students και συμβαίνει να βοηθάει στην διαχείριση του συστήματος μπορεί να είναι ένας επιπλέον χρήστης στην ομάδα root.
Αφού είδαμε όλα αυτά ας δούμε και ορισμένες ακόμα εντολές.
Μια πολύ χρήσιμη εντολή είναι η εντολή ps.
Με αυτήν φαίνονται όλα τα προγράμματα-διεργασίες που τρέχει ο συγκεκριμένος χρήστης στο σύστημα.
Γράφοντας ps –ef βλέπουμε όλες τις διεργασίες που τρέχουν στο σύστημα.
Στην οθόνη που βλέπουμε εκτελώντας την εντολή ps –ef στην πρώτη στήλη έχουμε τον χρήστη που εκτελεί την κάθε μια από τις εντολές.
Στην δεύτερη στήλη βλέπουμε τον αριθμό της συγκεκριμένης διεργασίας (PID).
Με αυτόν τον αριθμό αναγνωρίζει την διεργασία το σύστημα.
Στην επόμενη στήλη είναι ο αριθμός της γονικής διεργασίας (PPID) δηλαδή της διεργασίας που άρχισε την εκτέλεση της συγκεκριμένης διεργασίας που αναφέρεται η στήλη.
Η τέταρτη στήλη δίνει τον χρόνο που ξεκίνησε η συγκεκριμένη διεργασία.
Ακολουθεί η στήλη που φαίνεται από πού (τερματικό κλπ) δόθηκε η εντολή της εκτέλεσης της διεργασίας.
Στην επόμενη στήλη φαίνεται ο συνολικός χρόνος που εκτελείται η διεργασία μέχρι την στιγμή που βλέπουμε την εντολή ps –ef.
Στην τελευταία στήλη φαίνεται το όνομα της κάθε διεργασίας.
Όταν θέλουμε να σταματήσουμε μια από αυτές τις διεργασίες που βλέπουμε στην ps –ef απλά γράφουμε την εντολή kill ακολουθούμενη από τον αριθμό της συγκεκριμένης διεργασίας : kill <PID>.
Αν η εντολή για κάποιο λόγο δεν σταματήσει να εκτελείται τότε δίνουμε την εντολή kill με την παράμετρο –9.
Δηλαδή γράφουμε kill –9 <PID>.
Αν και σε αυτή την περίπτωση δεν σταματήσει η διεργασία τότε ο μόνος τρόπος για να σταματήσει είναι το κλείσιμο και η επανεκκίνηση του συστήματος. (shutdown –r now ή reboot –n).
Εφόσον η εντολή τρέχει στο τερματικό μας και δεν μας έχει επιστραφεί το prompt του συστήματος (τρέχει δηλαδή στο προσκήνιο όπως λέμε- forground) τότε μπορούμε να σταματήσουμε την εκτέλεσή της πατώντας ctrl c (^C).
Η εντολή με την οποία φαίνονται τα περιεχόμενα του καταλόγου είναι η εντολή ls.
Αν δώσουμε με την ls την παράμετρο –a τότε μπορούμε να δούμε και τα κρυφά αρχεία.
Αυτά είναι όσα τα ονόματά τους αρχίζουν από τελεία όπως πχ το .profile για το κέλυφος bourne.
Άμα με την ls δώσουμε την παράμετρο –l τότε μας εμφανίζονται λεπτομέρειες για τα αρχεία του καταλόγου.
Φυσικά μπορούμε να δώσουμε και τις δύο παραμέτρους και να γράψουμε ls –al οπότε θα έχουμε και λεπτομέρειες και την εμφάνιση των κρυφών αρχείων.
Με αυτήν την ευκαιρία μπορούμε να εξηγήσουμε με λεπτομέρεια τι βλέπουμε στην οθόνη όταν εκτελέσουμε την εντολή ls –al.
Η πρώτη στήλη αφορά το είδος των αρχείων και τα δικαιώματα που έχουν οι χρήστες σε αυτά.
Στην δεύτερη στήλη φαίνονται οι σκληροί σύνδεσμοι (hard links) του κάθε αρχείου ή αλλιώς με πόσα ονόματα παρουσιάζεται αυτό το αρχείο στο σύστημα αρχείων (filesystem).
Στην τρίτη στήλη είναι ο χρήστης που είναι ο ιδιοκτήτης του αρχείου, ενώ στην τέταρτη είναι η ομάδα χρηστών στην οποία ανήκει το συγκεκριμένο αρχείο.
Η πέμπτη στήλη έχει το μέγεθος του αρχείου σε blocks.
Οι επόμενες τρεις στήλες έχουν με την σειρά τον μήνα, την ημερομηνία και την ώρα δημιουργίας του αρχείου, ενώ η τελευταία στήλη έχει το όνομα του αρχείου.
Οι εντολές οι οποίες δείχνουν τα περιεχόμενα ενός αρχείου είναι οι cat, more, less.
Η cat δείχνει τα περιεχόμενα όλα μαζί.
Αυτό σημαίνει ότι όταν το αρχείο είναι αρκετά μεγάλο και δεν φτάνει μια οθόνη για να δούμε τα περιεχόμενα του με την cat τα περιεχόμενα θα «τρέξουν» από μπροστά μας και δεν θα προλάβουμε να δούμε τίποτα.
Σε τέτοια περίπτωση θα πρέπει να χρησιμοποιήσουμε την more ή την less.
Αυτές έχουν το πλεονέχτημα ότι δείχνουν τα περιεχόμενα οθόνη-οθόνη οπότε έχουμε την ευχέρεια να τα μελετήσουμε με την ησυχία μας.
Για να πάμε στην επόμενη οθόνη πατάμε το πλήκτρο <space> ενώ το πλήκτρο <enter> μας πάει στην επόμενη σειρά.
Επίσης είναι δυνατή η δημιουργία αρχείου κειμένου με την εντολή cat.
Γράφοντας cat > filename η εντολή περιμένει είσοδο από το πληκτρολόγιο και δίνει έξοδο στο αρχείο filename.
Ο τερματισμός εισόδου δεδομένων γίνεται με Ctrl D (^D) όπως έχουμε πει και στα προηγούμενα.
Όπως είπαμε πιο πριν ένας χρήστης μπορεί να έχει πολλά κελύφη τα οποία να τρέχουν το ένα πάνω στο άλλο και όλα αυτά να τρέχουν και εφαρμογές.
Για να κλείσουμε ένα κέλυφος και να βρεθούμε στο προηγούμενο εκτελούμε την εντολή exit.
Αν εκτελέσουμε αυτήν την εντολή ενώ βρισκόμαστε στο κατώτατο-πρώτο κέλυφος τότε θα βγούμε από το σύστημα.
Άλλη εντολή που μας βγάζει από το σύστημα είναι η εντολή logout.
Αυτή η εντολή στα περισσότερα συστήματα μπορεί να εκτελεστεί μόνον εφόσον βρισκόμαστε στο κατώτατο κέλυφος.
Τώρα μπορούμε να πούμε και μερικά για το σύστημα αρχείων.
Είναι γνωστό ότι όλα τα συστήματα αρχείων που ξέρουμε ακολουθούν μια δομή ανάποδου δέντρου που μας είναι όλους γνωστό ήδη από το DOS.
Στο UNIX όμως ο πρώτος κατάλογος συμβολίζεται με / και όλοι οι υποκατάλογοι καταλόγων χωρίζουν τα ονόματά τους στο μονοπάτι πάλι με το /.
Παράδειγμα ο κατάλογος /usr/local που είναι ο κατάλογος local μέσα στον κατάλογο usr ο οποίος με την σειρά του είναι υποκατάλογος του κύριου καταλόγου του συστήματος που συμβολίζεται όπως είπαμε με / και λέγεται root directory. (κατάλογος root).
Στο Unix δεν υπάρχουν συσκευές αποθήκευσης που να χαρακτηρίζονται από ένα “γράμμα οδηγού” (drive letter) π.χ.
Α:, C:, D: κ.λ.π. όπως στο MS-DOS και στα Windows.
Όλες οι συσκευές αποθήκευσης συνδέονται σε κάποιον υποκατάλογο του βασικού δένδρου καταλόγων που ξεκινά από τον κατάλογο ρίζα “/” (root).
Η εντολή σύνδεσης μίας συσκευής αποθήκευσης στο δένρο των καταλόγων είναι η : όπου το <αρχείο συσκευής> είναι ένα ειδικό αρχείο χαρακτήρων (character special file) ή ειδικό αρχείο μπλόκ (block special file) που αντιστοιχεί στη συγκεκριμένη συσκευή και βρίσκεται στον κατάλογο /dev.
Παράδειγμα :
Σημαντικοί κατάλογοι στο σύστημα είναι ο κατάλογος /bin όπου βρίσκονται τα εκτελέσιμα προγράμματα του συστήματος, ο κατάλογος /etc όπου βρίσκονται κρίσιμα αρχεία ρυθμίσεων του συστήματος όπως πχ τα /etc/passwd. /etc/group που ήδη είδαμε ή πχ το /etc/printcap που είναι το αρχείο ρύθμισης για τους εκτυπωτές.
Άλλος κατάλογος που πρέπει να ξέρουμε είναι ο /dev όπου υπάρχουν όλα τα αρχεία συσκευών.
Στον κατάλογο /usr από την άλλη μεριά έχει αρχεία που χρησιμοποιούν οι χρήστες.
Εκεί βρίσκονται και οι υποκατάλογοι /usr/bin όπου έχει προγράμματα, /usr/lib όπου έχει βιβλιοθήκες κλπ.
Οι κυριότερες βιβλιοθήκες του συστήματος πάντως βρίσκονται στον κατάλογο /lib.
Οι κατάλογοι των χρηστών βρίσκονται στον κατάλογο /home ενώ τα επιπλέον προγράμματα που συνηθίζουν να βάζουν στο σύστημα οι διαχειριστές συνήθως μπαίνουν στον κατάλογο /opt.
Ακόμα υπάρχει και ο κοινόχρηστος κατάλογος /tmp και ο κατάλογος /var όπου έχει συνήθως αρχεία με πληροφορίες για το σύστημα, ουρές εκτύπωσης κλπ.
Οι εγγραφές στους καταλόγους αρχείων (directories) ονομάζονται Ι-κόμβοι (I-Nodes).
Ένας ι-κόμβος (I-Node) είναι στην ουσία μία δομή που περιέχει για κάποιο αρχείο τα παρακάτω πεδία: · Ημερομηνία τελευταίας πρόσβασης · Ημερομηνία τελευταίας μεταβολής · Δικαιώματα πρόσβασης αρχείου · Δείκτες σε μπλόκ δεδομένων (απευθείας, απλά έμμεσοι, διπλά έμμεσοι, τριπλά έμμεσοι) Κάθε αρχείο του δίσκου έχει τουλάχιστον έναν ι-κόμβο (I-Node) που αντιστοιχεί σε μία εγγραφή σε κάποιο κατάλογο.
Ο πρώτος ι-κόμβος δημιουργείται από το σύστημα με την δημιουργία του αρχείου.
Είναι δυνατό να υπάρχουν δύο ή περισσότεροι ι-κόμβοι (I-Nodes) για το ίδιο αρχείο στο δίσκο.
Οι πολλαπλοί ι-κόμβοι (I-Nodes) ενός αρχείου ονομάζονται σύνδεσμοι (links).
Οι σύνδεσμοι χρησιμεύουν στο να μπορεί ένα αρχείο να είναι παρόν σε περισσότερους του ενός καταλόγους χωρίς να πρέπει να αντιγράφεται πολλές φορές στο δίσκο (οικονομία χώρου).
Υπάρχουν δύο είδη συνδέσμων: Σκληροί Σύνδεσμοι (Hard Links) και Συμβολικοί Σύνδεσμοι (Soft ή Symbolic Links).
Οι Σκληροί Σύνδεσμοι δημιουργούνται με την εντολή :
Χαρακτηριστικά Σκληρών Συνδέσμων (Hard Links):
Αν σβήσει ένας Σκληρός Σύνδεσμος (Hard Link) το αρχείο δεν σβήνεται, σβήνεται μόνο ο Σκληρός Σύνδεσμος.
Για να σβήσει ένα αρχείο από το δίσκο πρέπει να σβήσουν όλοι οι Σκληροί Σύνδεσμοι (Hard Links) που δείχνουν σε αυτό.
Όλοι οι Σκληροί Σύνδεσμοι είναι ισοδύναμοι με τον αρχικό και δεν έχουν από την στιγμή της δημιουργίας τους καμία διαφορά με αυτόν.
Οι Σκληροί σύνδεσμοι δεν μπορούν να δείχνουν δεδομένα σε άλλο σύστημα αρχείων. (Σε άλλο partition του δίσκου) Οι Συμβολικοί Σύνδεσμοι (Soft ή Symbolic Links) δημιουργούνται με την εντολή :
Χαρακτηριστικά Συμβολικών Συνδέσμων (Soft Links):
Αν σβήσει ένας Συμβολικός Σύνδεσμος (Soft Link) το αρχείο δεν σβήνεται, σβήνεται μόνο ο Συμβολικός Σύνδεσμος.
Αν σβηστεί ο Σκληρός Σύνδεσμος (Hard Link , I-node) στον οποίο δείχνει ο Συμβολικός Σύνδεσμος (Soft Link) τότε το αρχείο σβήνεται, παρά την ύπαρξη του Συμβολικού Συνδέσμου (Soft Link) και ο Συμβολικός Σύνδεσμος (Soft Link) δεν δείχνει πλέον πουθενά.
Αν σβηστεί ο Σκληρός Σύνδεσμος (Hard Link , I-node) στον οποίο δείχνει ο Συμβολικός Σύνδεσμος (Soft Link) ενώ υπάρχουν και άλλοι σκληροί σύνδεσμοι στο αρχείο τότε ενώ το αρχείο υπάρχει, ο Συμβολικός Σύνδεσμος (Soft Link) δεν δείχνει πλέον πουθενά
Αν σβηστεί ο Σκληρός Σύνδεσμος (Hard Link , I-node) στον οποίο δείχνει ο Συμβολικός Σύνδεσμος (Soft Link) και δημιουργηθεί άλλος σκληρός σύνδεσμος με το ίδιο όνομα τότε ο Συμβολικός Σύνδεσμος δείχνει στο νέο Σκληρό Σύνδεσμο και κατά συνέπεια στο νέο αρχείο
Οι συμβολικοί Σύνδεσμοι μπορούν να δείχνουν αρχεία σε άλλα συστήματα αρχείων. (Άλλα partition στο δίσκο για παράδειγμα)
Εντολές καταλόγων (pwd, cd, mkdir, rmdir) Για να δούμε σε ποιόν κατάλογο βρισκόμαστε πρέπει να εκτελέσουμε την εντολή:
Για να δημιουργήσουμε κάποιον κατάλογο εκτελούμε την εντολή: ενώ για να πάμε μέσα σε κάποιον κατάλογο αρκεί να γράψουμε:
Στην θέση του ονόματος του καταλόγου μπορεί να είναι το πλήρες όνομα ή μονοπάτι όπως λέγεται.
Τέλος για να σβήσουμε ένα κατάλογο εκτελούμε την εντολή:
Ο κατάλογος σβήνει μόνον αν είναι άδειος.
Το ακόλουθο παράδειγμα δείχνει την δημιουργία και το σβήσιμο ενός καταλόγου μέσα στον κατάλογο /tmp.
Για να δούμε το συνολικό ελεύθερο χώρο σε όλο το filesystem (όλες τις κατατμήσεις-partitions) εκτελούμε την εντολή df. (disk free) Για να δούμε πόσο χώρο χρησιμοποιούμε σε ένα κατάλογο μαζί με τους υποκαταλόγους του σε blocks εκτελούμε την εντολή du (disk usage).
Η εντολή δίνει σύνολα περιεχομένων του τρέχοντος καταλόγου (μαζί με τους υποκαταλόγους του) και των υποκαταλόγων (μαζί με τους υποκαταλόγους τους).
Δηλαδή σύνολο μεγέθους των περιεχομένων για κάθε δομή δέντρου του συστήματος αρχείων κάτω από των κατάλογο που του λέμε.
Η εκτέλεση της εντολής du –s δίνει το μέγεθος του συνόλου των περιεχομένων του τρέχοντος καταλόγου και των υποκαταλόγων σε blocks χωρίς να δίνει σύνολο περιεχομένων για κάθε υποκατάλογο ξεχωριστά.
Η εκτέλεση της εντολής du –k δίνει το μέγεθος των περιεχομένων του τρέχοντος καταλόγου και των υποκαταλόγων σε Mb.
Η εκτέλεση της εντολής du –sk δίνει το μέγεθος των περιεχομένων του τρέχοντος καταλόγου (μαζί με τους υποκαταλόγους του) χωρίς να δίνει σύνολα για κάθε υποκατάλογο ξεχωριστά, σε Mb.
Μια ομάδα βασικών εντολών είναι οι εντολές αντιγραφής σβησίματος και μεταφοράς αρχείων.
Η εντολή για την αντιγραφή είναι η εντολή cp και η σύνταξή της είναι:
Στην θέση των ονομάτων των αρχείων για την πηγή και το στόχο μπορεί να μπει το πλήρες όνομα ή αλλιώς μονοπάτι.
Σπουδαίοι παράμετροι (options) για την εντολή είναι: που άμα βρει ότι υπάρχει ο στόχος ρωτάει πριν κάνει την αντιγραφή (Επικάλυψη-overwrite), που κάνει την αντιγραφή και των υποκαταλόγων (Τμήματα του δέντρου του συστήματος Αρχείων –recursive) και που αντιγράφει τα αρχεία παρακάμπτοντας τα δικαιώματα εγγραφής τους (force).
Η αντιγραφή δημιουργεί δύο διαφορετικά αρχεία (ι-κόμβους) με τα ίδια περιεχόμενα.
Έτσι άμα μετά αλλάξουμε το ένα από αυτά τότε το άλλο δεν αλλάζει σε αντίθεση με τους Σκληρούς κόμβους που είναι το ίδιο αρχείο και συνεπώς άμα αλλάξουμε τον ένα όλοι οι υπόλοιποι κόμβοι, μια και δείχνουν το ίδιο αρχείο, δείχνουν τις ίδιες αλλαγές.
Ο στόχος στην αντιγραφή μπορεί να είναι και κατάλογος.
Σε αυτήν την περίπτωση το αρχείο κατά την αντιγραφή μπορεί να αντιγραφτεί, με το ίδιο όνομα που είχε πριν, στον νέο κατάλογο ή να αλλάξει και όνομα.
Η εντολή αντιγραφής μπορεί ακόμα να αντιγράψει πολλά αρχεία σε ένα στόχο κατάλογο.
Τότε τα ονόματα των αρχείων παραμένουν τα ίδια.
Η εντολή για την μεταφορά αρχείων είναι η mv.
Η σύνταξη της είναι η ίδια με την cp και έχει και τις ίδιες παραμέτρους :
Ουσιαστικά κάνει ακριβώς το ίδιο με την εντολή cp μόνο που κατά την εκτέλεσή της σβήνει τα πηγαία αρχεία. (Το αρχείο πηγή αν είναι ένα).
Παρόμοια η εντολή rm που σβήνει τα αρχεία έχει την ίδια σύνταξη και τις ίδιες παραμέτρους όμως έχει ένα όρισμα, τον στόχο και δεν έχει πηγή.
Συγκεκριμένα η σύνταξή της είναι:
Οι παράμετροι (options) της rm είναι παρόμοιες με τις παραμέτρους της cp.
Προσοχή χρειάζεται σε εντολές του τύπου rm -rf * (recurse subdirs + force).
Η παραπάνω εντολή σβήνει όλα τα αρχεία στον τρέχοντα κατάλογο καθώς και σε όλους τους υποκαταλόγους χωρίς έλεγχο δικαιωμάτων αρχείων.
Έτσι αν η εντολή αυτή εκτελεστεί στον κατάλογο root θα διαγραφεί ολόκληρο το σύστημα.
Άλλη σημαντική εντολή είναι η εντολή echo που το μόνο που κάνει είναι να αντηχεί το όρισμα της στην έξοδό της (Συνήθως οθόνη).
Έτσι η εντολή: γράφει την έκφραση “Hello World” στην οθόνη.
Η εντολή που δείχνει την ημερομηνία και την ώρα του συστήματος είναι η date.
Πολύ χρήσιμη εντολή είναι και η wc (word count) η οποία μετράει τους χαρακτήρες τις λέξεις και τις σειρές που περιέχει ένα αρχείο.
Παίρνει σαν παραμέτρους τα γράμματα –l –w –c.
Έτσι η γενική σύνταξη της εντολής είναι :
Όταν γράφεται με την παράμετρο –w δείχνει μόνο τις λέξεις.
Αντίστοιχα το –l δείχνει μόνο γραμμές ενώ το –c δείχνει μόνο χαρακτήρες.
Οι παράμετροι μπορούν να συνδυαστούν και ανά δύο ενώ όταν δεν υπάρχουν παράμετροι η εντολή βγάζει όλες τις πληροφορίες.
Προσοχή στο γεγονός ότι η εντολή στους χαρακτήρες μετράει και τον χαρακτήρα αλλαγής γραμμής.
Οι εντολές who, finger, w, whoami και who am i δίνουν πληροφορίες για τους χρήστες του συστήματος.
Συγκεκριμένα η who δείχνει ποιοι είναι οι χρήστες που είναι αυτή την στιγμή συνδεμένοι στο σύστημα, ενώ η εντολή w δείχνει και ποια εργασία κάνουν οι χρήστες στην τρέχουσα στιγμή.
Οι εντολές who am i και whoami δείχνουν ποιος χρήστης είμαστε εμείς που γράφουμε την εντολή.
Βασικές έννοιες στο UNIX είναι οι έννοιες του προσκηνίου (Foreground) και του παρασκηνίου (background).
Για να δούμε τι είναι αυτά ας προχωρήσουμε στην εκτέλεση των ακόλουθων εντολών:
Η πρώτη εντολή δεν επέστρεψε το prompt του συστήματος και ήμασταν αναγκασμένοι να περιμένουμε το τέλος της εκτέλεσης της για να μπορούμε να συνεχίσουμε την δουλειά μας.
Αντίθετα με την δεύτερη εντολή πήραμε αμέσως το prompt και μπορούσαμε έτσι να συνεχίσουμε αμέσως ότι κάναμε.
Η εντολή sleep 50 λέει απλά στο σύστημα να περιμένει 50 δευτερόλεπτα.
Τι έγινε όμως την δεύτερη φορά;
Μήπως δεν εκτελέστηκε.
Μια εκτέλεση της εντολής ps θα μας δείξει ότι η εντολή sleep 50 εκτελείτε κανονικά, όμως εμείς δεν περιμένουμε την εκτέλεσή της και μπορούμε να συνεχίσουμε την δουλειά μας.
Αυτός ο τρόπος εκτέλεσης μιας εντολής λέγεται εκτέλεση στο περιθώριο και γίνεται με την πρόσθεση του χαρακτήρα & στο τέλος της εντολής.
Για να δούμε ποιες εργασίες εκτελούμε χρήσιμη είναι η εντολή jobs.
Για να φέρουμε μια διεργασία από το περιθώριο στο προσκήνιο τρέχουμε την εντολή :
Για να πάμε μια εντολή από το προσκήνιο στο παρασκήνιο πρέπει να πατήσουμε :
Οι εντολές και του προσκηνίου και του παρασκηνίου σταματούν με την έξοδο του χρήστη από το σύστημα.
Για να παραμείνει μια εντολή στο σύστημα μετά την έξοδό μας πρέπει να δοθεί με την εντολή nohup.
Έτσι αν έχουμε κάποιο πρόγραμμα γραμμένο σε γλώσσα C που το εκτελέσιμο του είναι το a.out και χρειάζεται να τρέχει συνεχώς για δέκα μέρες, απλά το δίνουμε στο σύστημα με την εντολή:
Μετά μπορούμε να βγούμε από το σύστημα και να επιστρέψουμε σε δέκα μέρες για να πάρουμε τα αποτελέσματα.
Εδώ πρέπει να πει κανείς ότι πολλές φορές βλέπουμε το σύστημα να είναι πιο αργό από ότι συνήθως.
Αυτό συμβαίνει γιατί πολλοί χρήστες το φόρτωσαν με πολλές εργασίες και δυσκολεύεται στην εκτέλεσή τους.
Άμα λοιπόν έχουμε ένα χρονοβόρο πρόγραμμα και δεν βιαζόμαστε να πάρουμε τα αποτελέσματα του καλά είναι να το τρέξουμε με την εντολή nice οπότε παίρνει μικρότερη προτεραιότητα από το σύστημα και δεν το παραφορτώνει.
Για παράδειγμα η εντολή για το a.out θα ήταν:
Παρομοίως μπορούμε να εκτελέσουμε ένα πρόγραμμα στις 4:00 το βράδυ που ο υπολογιστής δεν έχει πολύ φόρτο με την εντολή at.
Αυτή δίνεται ως εξής:
Όπου το αρχείο εντολών περιέχει τις εντολές που πρόκειται να εκτελεστούν στις 4:00 πμ.
Η εντολή για βοήθεια στο UNIX είναι η εντολή man (manual –εγχειρίδιο) Για να πάρουμε βοήθεια στην εντολή ls γράφουμε:
Για να πάρουμε βοήθεια για την ίδια την βοήθεια γράφουμε man man, ενώ για να δούμε βοήθεια σε μια λέξη κλειδί γράφουμε:
Χαρακτηριστικά ενός αρχείου / καταλόγου στο UNIX που σχετίζονται με την ασφάλεια :
Ο ιδιοκτήτης του αρχείου αλλάζει με την εντολή :
Η παράμετρος -R σημαίνει αναδρομική (recursive) αλλαγή όλων των υποκαταλόγων και των περιεχομένων τους
Κάθε αρχείο ανήκει σε μία ομάδα χρηστών που μπορεί να είναι διαφορετική από τις ομάδες που ανήκει ο χρήστης –ιδιοκτήτης του (Συνήθως όμως είναι η κύρια ομάδα του).
Η ομάδα που ανήκει ένα αρχείο αλλάζει με την εντολή :
Με την δημιουργία του το αρχείο ανήκει σε αυτόν που το δημιούργησε.
Πρόβλημα υπάρχει με την ομάδα που ανήκει ένα αρχείο.
Στο σύστημα V (system V) η ομάδα ιδιοκτησίας είναι η κύρια ομάδα του χρήστη που δημιούργησε το αρχείο.
Στο σύστημα BSD όμως ομάδα ιδιοκτησίας είναι η ιδιοκτήτρια ομάδα του καταλόγου μέσα στον οποίο δημιουργήθηκε το αρχείο.
Στα σύγχρονα συστήματα UNIX έχουμε συμπεριφορά σαν το system V όμως αν βάλουμε το s δικαίωμα στον κατάλογο αλλάζει η συμπεριφορά και γίνεται σαν το BSD για τον συγκεκριμένο κατάλογο.
Ο διαχειριστής (root) μπορεί να δώσει την ιδιοκτησία του οποιουδήποτε αρχείου σε όποιον χρήστη θέλει και μάλιστα μπορεί να βάλει για ομάδα ιδιοκτησίας όποια θέλει ακόμα και αν δεν ανήκει ο χρήστης σε αυτήν.
Ο τυπικός χρήστης όμως μπορεί να δώσει μόνο τα δικά του αρχεία σε όποιον θέλει, οπότε χάνει την κυριότητα τους, και μπορεί να βάλει για νέα ομάδα ιδιοκτησίας μόνο τις ομάδες που αυτός ανήκει, ακόμα και αν δεν άνηκε στην αρχική ομάδα ιδιοκτησίας.
Αυτό με την προϋπόθεση ότι οι εντολές chown και chgrp είναι από το σύστημα επιτρεπτές για απλούς χρήστες.
SUID (set user ID), εκτελείται με δικαιώματα του ιδιοκτήτη (owner) Όπως π.χ. η εντολή passwd (bin/passwd)
SGID (set group ID), εκτελείται με τα δικαιώματα της ομάδας (group) του ιδιοκτήτη (owner) Τα αρχεία που δημιουργούνται στον κατάλογο παίρνουν σαν ιδιοκτήτρια ομάδα αυτήν του καταλόγου όπως και στο BSD το εκτελέσιμο Παραμένει στη μνήμη (π.χ. vi) από κοινόχρηστους καταλόγους σβήνω μόνο δικά μου αρχεία (πχ \tmp)
Τα δικαιώματα αλλάζουν με την εντολή :
Η παράμετρος -R σημαίνει recursive αλλαγή όλων των υποκαταλόγων και των περιεχομένων τους Το <mode> γενικά είναι : [ugoa] [+ - =] [rwxXst] [, ........] ή Οκταδικός Αριθμός
Ο τρόπος να αναγνωρίσουμε τα δικαιώματα από τους οκταδικούς αριθμούς είναι ως εξής: Για κάθε δικαίωμα που υπάρχει στην θέση του βάζουμε μία μονάδα ενώ για κάθε δικαίωμα που δεν υπάρχει βάζουμε το μηδέν.
Έτσι σχηματίζονται τρεις τριψήφιοι δυαδικοί αριθμοί.
Ένας από τα δικαιώματα του χρήστη ένας από τα δικαιώματα της ομάδας και ένας από τα δικαιώματα των υπολοίπων.
Για παράδειγμα για ένα αρχείο με δικαιώματα rwxrw-r-- ο αριθμός που σχηματίζεται είναι ο 111,110,100 που σε οκταδικό είναι ο αριθμός 754.
Παρομοίως το παράδειγμα 543 είναι 101,100,011 δηλαδή r-xr---wx.
Ένα καινούριο αρχείο παίρνει συνήθως όλα τα δικαιώματα.
Για να καθορίσω ποια δικαιώματα θα παίρνουν τα νέα αρχεία χρησιμοποιώ την εντολή
Ο οκταδικός αριθμός εκφράζει τα δικαιώματα που αφαιρούνται.
Π.χ. αν θέλω δικαιώματα rwxr-xr-x = 755 τότε δίνω :
Στον ακόλουθο πίνακα υπάρχουν κάποια παραδείγματα δικαιωμάτων: Ελάχιστα δικαιώματα που χρειάζονται
Στο ίδιο το αρχείο Στον κατάλογο που ανήκει το αρχείο
Για να ξεκινήσουμε τον vi γράφουμε απλά vi στην γραμμή εντολών.
Ξεκινώντας ο vi βρίσκεται σε κατάσταση εντολών (command mode).
Σε αυτήν την κατάσταση ότι δώσουμε από το πληκτρολόγιο το θεωρεί εντολή.
Για να γράψουμε κείμενο πρέπει να πατήσουμε ένα από τα επόμενα γράμματα-εντολές: i, a, o, I,A,O.
Με μια από αυτές τις εντολές ο vi γυρνάει σε κατάσταση εισαγωγής κειμένου (insert mode).
Για να ξαναγυρίσουμε σε κατάσταση εντολών πατάμε το κουμπί escape ή τον ισοδύναμο συνδυασμό ctrl [ (^[ ).
Από την κατάσταση εντολών μπορούμε να πάμε στην γραμμή εντολών πατώντας την άνω και κάτω τελεία (:).
Από την γραμμή εντολών πηγαίνουμε στην κατάσταση εντολών είτε μετά την εκτέλεση μίας εντολής είτε δίνοντας “e” και Enter.
Όλα αυτά τα βλέπουμε σχηματικά στο παρακάτω σχήμα.
Βάζει κείμενο αμέσως πριν από το δρομέα.
Βάζει κείμενο αμέσως μετά το δρομέα.
Βάζει μια νέα γραμμή κάτω από την τρέχουσα γραμμή και γράφουμε κείμενο εκεί.
Βάζει κείμενο πριν από τον πρώτο μη λευκό χαρακτήρα στην αρχή της γραμμής Βάζει κείμενο στο τέλος της γραμμής ενώ Βάζει μια νέα γραμμή πάνω από την τρέχουσα γραμμή και μπορούμε να γράψουμε εκεί.
Πίνακας 3-1.
Εντολές εισαγωγής κειμένου Τρέχουσα γραμμή είναι αυτή στην οποία βρίσκεται ο δρομέας.
Τώρα που μάθαμε τα πολύ βασικά ας γράψουμε ένα απλό κείμενο.
Μόλις τελειώσουμε το κείμενο πατάμε escape (μας γυρνάει σε κατάσταση εντολών) και μετά γράφουμε στην γραμμή εντολών, (άρα πατάμε άνω και κάτω τελεία ) Αυτή η εντολή σώζει το κείμενο με το όνομα poem.
Αν θέλουμε τώρα να βγούμε και από τον vi δίνουμε την εντολή q στην γραμμή εντολών δηλαδή γράφουμε
Αν θέλουμε να βγούμε από το vi χωρίς να σώσουμε γράφουμε πάλι στην γραμμή εντολών
Εδώ πρέπει να τονίσουμε ότι όταν ο vi είναι σε κατάσταση κειμένου ότι κουμπί και να πατήσουμε εκτός από escape το θεωρεί απλά κείμενο.
Για να μετακινηθούμε στην οθόνη να σβήσουμε κάτι να αντιγράψουμε ή οτιδήποτε άλλο πρέπει να είμαστε σε κατάσταση εντολών.
Θεωρώντας λοιπόν ότι είμαστε τώρα σε κατάσταση εντολών θα δώσουμε τις βασικές εντολές μετακίνησης.
Συνήθως στους σύγχρονους vi για απλή μετακίνηση χαρακτήρα-χαρακτήρα δουλεύουν τα βελάκια.
Αν όμως ο δικός μας vi είναι παλαιότερος τότε η μετακίνηση γίνεται με τα γράμματα hjkl τα οποία λειτουργούν έτσι κι αλλιώς.
Το γράμμα h κινεί το δρομέα αριστερά, το γράμμα j κινεί το δρομέα προς τα κάτω, το γράμμα k κινεί το δρομέα προς τα πάνω και το γράμμα l κινεί το δρομέα προς τα δεξιά.
Ο παρακάτω πίνακας δείχνει με μεγαλύτερη λεπτομέρεια όλες τις εντολές κίνησης.
Μετακινεί το δρομέα αριστερά Μετακινεί το δρομέα κάτω Μετακινεί το δρομέα πάνω Μετακινεί το δρομέα δεξιά Μετακινεί το δρομέα στην αρχή της επόμενης λέξης Μετακινεί το δρομέα στο τέλος της επόμενης λέξης Μετακινεί το δρομέα στην αρχή της προηγούμενης λέξης Μετακινεί το δρομέα στην αρχή της σειράς Μετακινεί το δρομέα στο τέλος της σειράς Μετακινεί το δρομέα στο τέλος του κειμένου Μετακινεί το δρομέα στην αρχή του κειμένου Μετακινεί το δρομέα στην νιοστή σειρά (όπου n είναι αριθμός) Εφόσον ανοίξαμε παρένθεση ή αγκύλη μας βρίσκει που είναι η παρένθεση ή η αγκύλη που κλείνει Μετακινεί το δρομέα στην πρώτη γραμμή της οθόνης Μετακινεί το δρομέα στην μέση της οθόνης Μετακινεί το δρομέα στο τέλος της οθόνης Κυλάει το κείμενο μια οθόνη προς τα κάτω Κυλάει το κείμενο μια οθόνη προς τα πάνω Κυλάει το κείμενο μισή οθόνη προς τα κάτω Κυλάει το κείμενο μισή οθόνη προς τα πάνω
Στα επόμενα έχουμε ένα πίνακα όπου φαίνονται οι εντολές σβησίματος.
Το n είναι ένας αριθμός που σημαίνει τόσες επαναλήψεις της εντολής.
Για παράδειγμα το x σβήνει ένα χαρακτήρα ενώ το 5x σβήνει τους επόμενους 5 χαρακτήρες αρχίζοντας από αυτόν που βρίσκεται κάτω από το δρομέα (πάντα).
Η εντολή dd σβήνει την σειρά κάτω από το δρομέα αλλά η εντολή 10dd σβήνει 10 σειρές, αρχίζοντας από αυτήν που βρίσκεται κάτω από το δρομέα και συνεχίζοντας προς τα κάτω. (πάντα).
Σβήνει από το δρομέα μέχρι το τέλος της σειράς Σβήνει από το δρομέα μέχρι το τέλος του αρχείου Σβήνει από το δρομέα μέχρι την αρχή του αρχείου
Μερικές φορές δίνουμε κάποια λάθος εντολή.
Σε τέτοια περίπτωση μπορούμε να πατήσουμε το u το οποίο μας επαναφέρει στην κατάσταση πριν την εκτέλεση της εντολής (undo).
Η εντολή αυτή άμα επαναληφθεί ακυρώνει τον εαυτό της, δηλαδή έχει βήμα 1.
Εφόσον κάναμε πολλές αλλαγές σε μια σειρά και θέλουμε να την επαναφέρουμε στην κατάσταση που ήταν πριν από όλες τις αλλαγές μπορούμε να πατήσουμε την εντολή U με την προϋπόθεση ότι παραμείναμε στην σειρά αυτή και δεν κάναμε κάτι άλλο.
Σε περίπτωση που έχει καταστραφεί το αρχείο από κάποιες κακές εντολές που δώσαμε μπορούμε να το επαναφέρουμε από κει που το είχαμε σώσει την τελευταία φορά με την εντολή
Αποκοπή, αντιγραφή και επικόλληση Εδώ πρέπει να πούμε ότι όλες οι εντολές σβησίματος στην πραγματικότητα κάνουν αποκοπή και όχι σβήσιμο.
Αν θέλουμε να επαναφέρουμε αυτά που «σβήσαμε» μπορούμε να πάμε το δρομέα στην θέση που θέλουμε να τα επαναφέρουμε και να πατήσουμε την εντολή p.
Αυτό γίνεται γιατί τα «σβησμένα» μπαίνουν σε ένα χώρο μνήμης μέχρι να σβήσουμε κάτι άλλο οπότε θα πάρει αυτό την θέση τους.
Επομένως μπορούμε να κάνουμε αποκοπή και επικόλληση με τις εντολές «σβησίματος» και τις εντολές p που κάνει επικόλληση από το δρομέα προς τα κάτω ή P που κάνει επικόλληση από το δρομέα προς τα πάνω.
Για να κάνουμε αντιγραφή οι εντολές είναι η nyy για n σειρές και η nwy για n λέξεις.
Η επικόλληση γίνεται πάλι με τις εντολές p και P.
Οι εντολές αποκοπής και επικόλλησης όμως μπορούν και να καθορίσουν το χώρο της μνήμης όπου βάζουν το κείμενο που αντιγράψαμε ή αποκόψαμε.
Αυτοί οι χώροι μνήμης λέγονται “named buffers”.
Ο τρόπος για να βάλουμε κείμενο σε ένα τέτοιο καθορισμένο χώρο είναι να γράψουμε:
Το οποίο αποκόβει κατά τα γνωστά 10 σειρές και τις βάζει στο χώρο μνήμης a.
Στην γενική περίπτωση και για τον buffer e για παράδειγμα γράφουμε: όπου n αριθμός για αποκοπή και
Η επικόλληση γίνεται γράφοντας “ep ή “eP.
Ο vi έχει 26 ονομασμένους χώρους μνήμης (named buffers) όσα και τα γράμματα του λατινικού αλφαβήτου.
Ο επόμενος πίνακας έχει της εντολές εύρεσης κειμένου.
Κάνει την έρευνα για την κανονική έκφραση re προς τα δεξιά και κάτω Κάνει την έρευνα για την κανονική έκφραση re προς τα αριστερά και πάνω Επαναλαμβάνει την τελευταία / ή ? εντολή Επαναλαμβάνει την τελευταία / ή ? εντολή προς την αντίστροφη κατεύθυνση
Πίνακας 3-4.
Εντολές αναζήτησης κειμένου στο vi Είναι σχηματισμοί που μπορεί να ταιριάζουν με κάποια λέξη ή με περισσότερες ή ακόμα και με τμήμα από πρόταση.
Ως τώρα από αυτά που μάθαμε μπορούμε να τις χρησιμοποιήσουμε στις εντολές εύρεσης και αντικατάστασης του ed, όμως όπως θα δούμε σε άλλα μαθήματα έχουν πολύ γενικότερη χρήση στο UNIX.
Στον ακόλουθο πίνακα έχουμε την σημασία των ειδικών συμβόλων που λέγονται μεταχαρακτήρες.
Ταιριάζει έναν οποιονδήποτε χαρακτήρα εκτός από το χαρακτήρα αλλαγής γραμμής Σημαίνει μηδέν ή περισσότερες επαναλήψεις του προηγούμενου χαρακτήρα Ταιριάζουν ακριβώς ένα από τους χαρακτήρες που περικλείουν Ο επόμενος χαρακτήρας είναι ο πρώτος στην γραμμή (αρχή γραμμής) Δεν έχει ειδικό νόημα αν δεν είναι στην αρχή της κανονικής έκφρασης Ο προηγούμενος χαρακτήρας είναι ο τελευταίος στην γραμμή (τέλος γραμμής) Δεν έχει ειδικό νόημα αν δεν είναι στο τέλος της κανονικής έκφρασης Ταιριάζει έναν οποιονδήποτε χαρακτήρα εκτός από αυτούς που περικλείονται στην αγκύλη μετά το ^ Ταιριάζει ένα βεληνεκές από χαρακτήρες.
Ταιριάζει με την προηγούμενη κανονική έκφραση που χρησιμοποιήθηκε στην εντολή Μετατρέπει τον μεταχαρακτήρα που το ακολουθεί σε απλό χαρακτήρα : είναι οτιδήποτε εκτός από ψηφίο : παραδείγματα λέξεων που ταιριάζουν είναι cope, cape, caper κλπ : Παραδείγματα λέξεων που ταιριάζουν είναι c.pe c.pet c.per κλπ : Ταιριάζουν stp, stop, stoop, stooop κλπ : Ταιριάζει με το xyz ακολουθούμενο από οτιδήποτε μέχρι το τέλος της γραμμής. : Ταιριάζει με τα carn car.n car..n carn car.n κλπ που με την σειρά τους ταιριάζουν πχ το car.n με το caren ενώ το car..n με το carmen ή το carton και το carn με το cartoon, με το cartoon cartoonist κλπ : ταιριάζει με το κάθε γραμμή που αρχίζει με The : Ταιριάζει με κάθε γραμμή που τελειώνει με την λέξη τέλος. : Ταιριάζει με κάθε γραμμή που έχει το Only σαν μοναδική λέξη στην γραμμή b[aou]rn : Ταιριάζει με τις λέξεις barn, born, burn.
Ver[D-F] : Ταιριάζει με τις λέξεις VerD, VerE, VerF ακολουθούμενες πιθανά και από άλλους χαρακτήρες μια που δεν τελειώνει εδώ η γραμμή.
Ver[^0-9] : Ταιριάζει με το Ver ακολουθούμενο από ένα οποιονδήποτε χαρακτήρα εκτός από ψηφίο.
Μετά από αυτόν τον χαρακτήρα δύνανται να υπάρχουν και άλλοι εφόσον δεν τελειώνει εδώ η γραμμή.
The[ir][re] : ταιριάζει με their, therr, there, theie ακολουθούμενα ίσως και από άλλους χαρακτήρες μια που δεν τελειώνει εδώ η γραμμή.
[A-Za-z][A-Za-z]* : Ταιριάζει κάθε λέξη και έχει το όνομα «γλώσσα».
Η εντολή της αντικατάστασης είναι η: Τα g και c δεν είναι απαραίτητα και μπορεί να υπάρχει το ένα από αυτά ή και κανένα.
Το g σημαίνει κάνε αντικατάσταση της λέξης όσες φορές και αν την βρεις στην γραμμή, ενώ το c κάνει επιβεβαίωση της επικείμενης αντικατάστασης.
Όταν υπάρχει το c στην εντολή τότε για κάθε αντικατάσταση πριν την εκτελέσει μας ρωτάει και αν πούμε ναι την εκτελεί, αλλιώς πάει στην επόμενη.
Το 1,$ είναι το βεληνεκές (range) και δείχνει σε ποιες γραμμές θα γίνει η αντικατάσταση. (Στην περίπτωση αυτή σε όλο το κείμενο μια που το $ σημαίνει την τελευταία γραμμή) Για παράδειγμα δίνουμε και τις επόμενες εντολές αντικατάστασης: Αυτή η εντολή σβήνει τα περιεχόμενα των σειρών από την τρέχουσα σειρά μέχρι την πέμπτη σειρά.
Αντικατάστησε τα the με το The όσες φορές και αν το βρεις στην ίδια σειρά από την αρχή του κειμένου ως το τέλος όμως ρώτα για κάθε αντικατάσταση Σβήσε τους τέσσερις πρώτους χαρακτήρες κάθε γραμμής Αντικατάστησε το help με το helping στις πρώτες πέντε γραμμές, όσες φορές και αν το βρεις σε κάθε γραμμή.
Διπλασίασε τα κενά στο κείμενο.
Σβήσε την άνω και κάτω τελεία μαζί με ότι ακολουθεί Ότι υπάρχει πριν από την άνω και κάτω τελεία βάλε το μετά και αντιστρόφως
Τα δύο τελευταία προφανώς θέλουν εξήγηση.
Χρησιμοποιούμε τις \( και \) για να ομαδοποιούμε κανονικές εκφράσεις.
Εφόσον έχουμε 5 ζευγάρια παρενθέσεων η κανονική παράσταση μέσα στο πρώτο ζευγάρι είναι το \1, στο δεύτερο το \2 και λοιπά.
Έτσι στην τελευταία εντολή βλέπουμε ότι στην αντικατάσταση μπαίνει πρώτα η δεύτερη ομάδα που βρίσκετε αρχικά πριν την άνω και κάτω τελεία και μετά η πρώτη ομάδα.
Έτσι το αποτέλεσμα είναι να έχουμε μια αντιστροφή του κειμένου και πριν την άνω και κάτω τελεία να βρίσκεται πλέον το κείμενο που αρχικά βρισκόταν μετά και αντίστοιχα το κείμενο που βρισκόταν πριν από αυτήν τελικά να βρίσκεται μετά.
Τέλος πρέπει να συμπληρώσουμε ότι για να βάλουμε control χαρακτήρες σε ένα έγγραφο με τον vi πατάμε πρώτα τα πλήκτρα ctrl V και μετά τον control χαρακτήρα που θέλουμε.
Για παράδειγμα η εισαγωγή ενός χαρακτήρα enter στο κείμενο γίνετε πατώντας ctrl v ctrlm και γράφει ^M που είναι το ctrl M.
Προγράμματα Σεναρίου κελύφους (Shell Scripts), Μεταβλητές, Παράμετροι, και εντολές echo και for.
Πολλές διαδικασίες στο UNIX απαιτούν περισσότερες από μία εντολές για να ολοκληρωθούν ή απαιτούν σύνθεση εντολών και φίλτρων με διοχετεύσεις, ανακατευθύνσεις κ.λ.π.
Γι’ αυτό το λόγο το κέλυφος του UNIX επιτρέπει στον χρήστη να ομαδοποιεί τέτοιες ακολουθίες εντολών σε αρχεία προγραμμάτων κελύφους ή shell scripts, ώστε κάθε φορά που χρειάζεται να εκτελέσει τις αντίστοιχες λειτουργίες να μην είναι αναγκασμένος να τις πληκτρολογεί ξανά και ξανά.
Τα αρχεία αυτά προφανώς είναι αρχεία κειμένου και μπορούν να δημιουργηθούν με οποιοδήποτε επεξεργαστή κειμένου (π.χ. vi).
Για να μπορούν όμως να εκτελεστούν θα πρέπει ο χρήστης να κάνει ένα από τα παρακάτω :
Να εκτελέσει το πρόγραμμα κελύφους δίνοντας :
Να μετατρέψει το αρχείο σε εκτελέσιμο δίνοντας :
και στη συνέχεια να το εκτελέσει μόνο με το όνομά του δίνοντας
Για παράδειγμα θα μπορούσαμε να φτιάξουμε ένα πρόγραμμα κελύφους με όνομα “init” το οποίο να περιέχει τις ακόλουθες εντολές:
Το παραπάνω πρόγραμμα θέτει τον τύπο του τερματικού σε vt100 και καθορίζει ότι το πλήκτρο διαγραφής θα είναι το Backspace.
Έτσι ο χρήστης αντί να δίνει αναλυτικά τις δύο εντολές θα μπορεί να εκτελεί το πρόγραμμα κελύφους “init” ως εξής:
αφού έχει μετατρέψει το “init” σε εκτελέσιμο δίνοντας στη συνέχεια το εκτελεί όποτε χρειαστεί δίνοντας απλά : init ή καλύτερα ./init γιατί ο τρέχων κατάλογος μπορεί να μην είναι στο path Αν θέλουμε να ορίσουμε συγκεκριμένα με ποιο κέλυφος θα εκτελείται ένα πρόγραμμα κελύφους πρέπει να δώσουμε ως πρώτη εντολή μέσα στο πρόγραμμα του κελύφους την ακόλουθη : ή όποιο άλλο κέλυφος θέλουμε.
Στα προγράμματα κελύφους γράφουμε μία εντολή σε κάθε γραμμή και οι εντολές εκτελούνται με την σειρά από την πρώτη έως και την τελευταία.
Αν θέλουμε να συμπεριλάβουμε δύο εντολές σε μία γραμμή τότε θα πρέπει αυτές να διαχωρίζονται με τον χαρακτήρα “;” (ελληνικό ερωτηματικό).
Οποιαδήποτε γραμμή ξεκινά με ένα “#” θεωρείται ως σχόλιο και δεν εκτελείται.
Στα προγράμματα κελύφους μπορούμε να συμπεριλάβουμε οποιαδήποτε αποδεκτή εντολή ή πρόγραμμα κελύφους με ή χωρίς παραμέτρους.
Μία πολύ χρήσιμη εντολή στα προγράμματα κελύφους είναι η εντολή :
Η εντολή αυτή αντηχεί στην καθιερωμένη έξοδο (οθόνη) το όρισμά της.
Με άλλα λόγια χρησιμοποιείται ως γενική εντολή εμφάνισης μηνυμάτων και αποτελεσμάτων.
Παραδείγματα με την echo:
Επιπλέον όμως μας παρέχονται κάποιες έξτρα δυνατότητες για την ανάπτυξη αποτελεσματικότερων προγραμμάτων κελύφους.
Μία τέτοια δυνατότητα είναι η χρήση μεταβλητών.
Στα προγράμματα κελύφους ο χρήστης μπορεί να χρησιμοποιήσει μεταβλητές για να επιτελέσει διάφορες εργασίες (π.χ. προσωρινή αποθήκευση δεδομένων κ.λ.π.).
Οι μεταβλητές δεν είναι απαραίτητο να δηλωθούν με κάποιο τρόπο παρά μόνο όταν θα χρησιμοποιηθούν για πρώτη φορά.
Ως ονόματα μεταβλητών ο χρήστης μπορεί να θέσει οποιονδήποτε συνδυασμό γραμμάτων και αριθμών (αρχίζοντας από γράμμα), ενώ από τους ειδικούς χαρακτήρες ο μόνος που μπορεί να χρησιμοποιείται με ασφάλεια είναι η υπογράμμιση “_”.
Δεν επιτρέπονται κενά και άλλοι ειδικοί χαρακτήρες που μπορεί να έχουν κάποια ειδική σημασία για το κέλυφος (π.χ. $ \ # ; κ.ο.κ.).
Παραδείγματα ονομάτων μεταβλητών είναι : A, a, a1, b2, temp, prwto_arxeio , dos_2_unix κ.λ.π.
Η αρχικοποίηση των μεταβλητών γίνεται με ανάθεση μίας τιμής σε αυτές:
ΠΡΟΣΟΧΗ : Στις αναθέσεις τιμών σε μεταβλητές δεν βάζουμε κενό ούτε πριν ούτε και μετά το “=”.
Αν κατά λάθος βάλετε κάποιο κενό τότε η μεταβλητή δεν παίρνει την τιμή που θα έπρεπε και μας δίνει λάθος στην εκτέλεση της εντολής το σύστημα.
Για την εξαγωγή τιμής από μεταβλητή χρησιμοποιούμε το πρόθεμα “$” πριν από το όνομα της μεταβλητής.
Έτσι γράφουμε : αλλά για να πάρουμε την τιμή γράφουμε :
Επίσης για καταχώρηση σε άλλη μεταβλητή θα είναι : Πρέπει εδώ να επισημάνουμε ότι οι τιμές των μεταβλητών στα προγράμματα κελύφους θεωρούνται ως αλφαριθμητικά (strings) και ποτέ ως αριθμοί.
Όταν λοιπόν δίνουμε : είναι το ίδιο με το να δώσουμε :
Και στις δύο περιπτώσεις θεωρείται ότι η μεταβλητή Α περιέχει τον χαρακτήρα “1” και όχι τον αριθμό 1.
Η αποτελεσματικότητα και η ευελιξία των προγραμμάτων είναι γενικά περιορισμένη όταν αυτά δεν είναι παραμετρικά, όταν δηλαδή δεν δέχονται παραμέτρους οι οποίες να καθορίζουν την λειτουργία τους.
Τα προγράμματα χωρίς παραμέτρους εκτελούν μία μόνο συγκεκριμένη λειτουργία και δεν επιτρέπουν στον χρήστη να καθορίσει τον τρόπο εκτέλεσης του προγράμματος σύμφωνα με τις εκάστοτε ανάγκες του χρήστη.
Γι’ αυτό το λόγο και τα προγράμματα κελύφους έχουν την δυνατότητα να δεχτούν παραμέτρους.
Οι παράμετροι δίνονται δίπλα από το όνομα του προγράμματος χωριζόμενες με κενά.
Για παράδειγμα ένα πρόγραμμα κελύφους “joinfiles” που συνενώνει δύο αρχεία σε ένα τρίτο θα μπορούσε να εκτελείται ως εξής :
Οι παράμετροι που δίνονται κατά την εκτέλεση, μπορούν να προσπελαύνονται μέσα στο πρόγραμμα κελύφους με τα εξής αναγνωριστικά : $1 $2 $3 $9 : οι τιμές των παραμέτρων (όπου $1 είναι η πρώτη παράμετρος, $2 η δεύτερη κ.ο.κ.). : περιέχει το όνομα του προγράμματος κελύφους όπως δόθηκε κατά την εκτέλεσή του. : περιέχει τον αριθμό των παραμέτρων που δόθηκαν. : περιέχει όλες τις παραμέτρους χωριζόμενες με κενό
Πρέπει εδώ να επισημάνουμε ότι μόνο οι πρώτες εννέα παράμετροι είναι άμεσα προσπελάσιμες μέσα στο πρόγραμμα.
Αυτό όμως δεν σημαίνει ότι οι παράμετροι μπορεί να είναι το πολύ μέχρι εννέα, αλλά μπορεί ναι είναι και δέκα και έντεκα αλλά και περισσότερες.
Ο τρόπος που χρησιμοποιείται για την προσπέλαση των παραμέτρων μετά την ένατη είναι μέσω της εντολής shift : (μετατοπίζει τις παραμέτρους 1 θέση προς τα αριστερά ) ή shift <n> (μετατοπίζει τις παραμέτρους n θέσεις προς τα αριστερά ) Η μετατόπιση γίνεται όπως στο παρακάτω σχήμα : Έτσι με ένα shift ή πρώτη παράμετρος χάνεται, η δεύτερη παράμετρος γίνεται πρώτη, η τρίτη γίνεται δεύτερη, κ.λ.π., η δέκατη γίνεται ένατη, κ.ο.κ.
Έτσι πλέον με το $9 παίρνουμε την δέκατη παράμετρο.
Με διαδοχικά shift μπορούμε να διαβάσουμε και τις υπόλοιπες παραμέτρους αν υπάρχουν πέραν της δέκατης.
Για να μην χάνουμε όμως τις πρώτες παραμέτρους μπορούμε αρχικά να τις καταχωρήσουμε σε αντίστοιχες μεταβλητές :
Σε πολλά προγράμματα υπάρχει η αναγκαιότητα επαναληπτικής εκτέλεσης κάποιων εντολών μέχρι να επιτευχθεί το επιθυμητό αποτέλεσμα.
Στα προγράμματα κελύφους μία από τις δομές επαναλήψεων που προσφέρονται είναι ο βρόχος for που συντάσσεται ως εξής :
Η <μεταβλητή> μπορεί να είναι οποιαδήποτε σύμφωνα με τους κανόνες ονοματολογίας που δώσαμε νωρίτερα.
Η <λίστα τιμών> πρέπει να είναι μία λίστα με τις διακριτές τιμές που θέλουμε να πάρει η <μεταβλητή> κατά την εκτέλεση του βρόχου, χωριζόμενες με κενό.
Όσες τιμές έχει μέσα η <λίστα τιμών> τόσες φορές θα εκτελεστεί και ο βρόχος for.
Παράδειγμα :
Ο παραπάνω βρόχος εμφανίζει στην οθόνη τους αριθμούς από 1 έως 10, έναν σε κάθε γραμμή.
Τα απλά εισαγωγικά (‘single quotes’) άρουν την μεταχαρακτηρική ιδιότητα όλων των συμβόλων εκτός από τον εαυτό τους.
Τα διπλά εισαγωγικά (“double quotes”) άρουν την μεταχαρακτηρική ιδιότητα όλων των συμβόλων εκτός από τον εαυτό τους, την ανάποδη κάθετο (backslash \ ) και το δολάριο ($).
Τα ανάποδα εισαγωγικά (`back quotes`) προκαλούν την εκτέλεση της εντολής που περικλείουν.
Τι θα εμφανιστεί στην οθόνη με την εκτέλεση του παρακάτω προγράμματος κελύφους : με την γραμμή εντολής α) με την γραμμή εντολής : β) με την γραμμή εντολής :
Στο Unix δεν υπάρχει ξεχωριστή έννοια συνθήκης όπως σε άλλες γλώσσες.
Οποιαδήποτε εντολή μπορεί να χρησιμοποιηθεί σαν συνθήκη.
Για παράδειγμα μια εντολή read μπορεί να είναι συνθήκη για κάποιον βρόχο.
Εφόσον η εντολή εκτελείται σωστά επιστρέφει κωδικό σωστής εκτέλεσης και η «συνθήκη» επαληθεύεται.
Εφόσον εκτελεστεί λάθος επιστρέφει κωδικό λάθους και η συνθήκη είναι ψευδής.
Ο κωδικός αυτός στο UNIX επιστρέφεται στην παράμετρο $? και για σωστή εκτέλεση είναι ο αριθμός 0 ενώ για λάθος εκτέλεση είναι ο αριθμός 1.
Ορισμένες εντολές επιστρέφουν περισσότερους κώδικες για λάθος εκτέλεση όπως πχ η εντολή expr που θα δούμε παρακάτω.
Η εντολή if χρησιμοποιείται για εκτέλεση εντολών κάτω από συνθήκες.
Η σύνταξή της είναι η ακόλουθη.
Τα τμήματα elif και else είναι προαιρετικά, ενώ μπορούμε να έχουμε οσαδήποτε elif θέλουμε.
Στην εκτέλεση της if εκτελούνται ΜΟΝΟ οι εντολές ενός κλάδου της if, εκείνου που πληρεί την συνθήκη.
Μπορούμε να έχουμε πολλές if την μια μέσα στην άλλη.
Η κάθε if πρέπει να βρίσκεται εξ ολοκλήρου μέσα σε ένα και μόνο κλάδο της αμέσως προηγούμενης if.
Δεν μπορούμε να έχουμε επικάλυψη δηλαδή να αρχίζει μια if μέσα σε ένα κλάδο και να τελειώνει σε άλλον.
Αυτό είναι γενικό και ισχύει για όλες τις δομές εντολών που έχουν αρχή και τέλος.
Η πιο συνηθισμένη εντολή-συνθήκη είναι η εντολή test.
Η εντολή test παίρνει εσωτερικά συνθήκες με την έννοια που τις έχουμε γνωρίσει σε άλλες γλώσσες.
Μπορεί να συγκρίνει αριθμούς (μόνο ακέραιους) να συγκρίνει strings, να δεχτεί λογικούς τελεστές και να κάνει πολλά ακόμα ενδιαφέροντα πράγματα.
Άμα η εσωτερική συνθήκη της test ισχύει η test σαν εντολή επιστρέφει 0 στο $?, όπως κάθε εντολή που εκτελείται σωστά, ενώ άμα δεν ισχύει επιστρέφει 1.
Η αριστερή αγκύλη ( [ ) είναι ένας δεσμός (link) στην test και έτσι η εντολή μπορεί να γραφτεί και με την χρήση αγκύλων.
Σε αυτήν την περίπτωση χρειάζεται να κλείσει η εντολή με την δεξιά αγκύλη ( ] ).
Προσοχή στην σύνταξη όταν χρησιμοποιούμε αγκύλες γιατί πρέπει να βάλουμε κενά μετά την αριστερή ( [ ) και πριν την δεξιά αγκύλη ( ] ).
Συνήθως η εντολή test γράφεται με αγκύλες γιατί είναι πιο ευκολοδιάβαστη και σπάνια την βλέπουμε γραμμένη αλλιώς.
Θα δείξουμε παραδείγματα και με τους δυο τρόπους γραφής:
Ο παρακάτω πίνακας περιέχει της χρήσεις των παραμέτρων που δέχεται η test (options)
Το αρχείο δεν είναι άδειο Το αρχείο είναι readable.
Έχουμε δικαίωμα να το διαβάσουμε.
Το αρχείο είναι writeable.
Έχουμε δικαίωμα να γράψουμε σε αυτό Το αρχείο είναι executable.
Έχουμε δικαίωμα να το εκτελέσουμε Το αρχείο υπάρχει και είναι απλό αρχείο Το αρχείο υπάρχει και είναι κατάλογος (directory) Το αρχείο υπάρχει και είναι ειδικό αρχείο χαρακτήρων.
Συνήθως συσκευή χαρακτήρων όπως ένα modem.
Το αρχείο υπάρχει και είναι ειδικό αρχείο τύπου block.
Συνήθως συσκευή block όπως ένας σκληρός δίσκος Το αρχείο υπάρχει και είναι ονομασμένη διοχέτευση (named pipe) Το αρχείο έχει το δικαίωμα SUID. (Set User ID) Το αρχείο έχει το δικαίωμα SGID. (Set Group ID) Το αρχείο έχει το δικαίωμα t (Sticky bit)
Πίνακας 5-1.
Παράμετροι της test που σχετίζονται με αρχεία Προσοχή στα κενά στις δυο πλευρές του = και των άλλων συμβόλων.
Το μήκος του string είναι μηδενικό. (0 χαρακτήρες) Το μήκος του string είναι μη μηδενικό (έχει χαρακτήρες) Τα δυο strings είναι ίδια Τα δυο strings είναι διαφορετικά Το string δεν είναι null
Πίνακας 5-2.
Παράμετροι της test που σχετίζονται με strings
Προσοχή και εδώ στα κενά Οι δυο ακέραιοι είναι ίσοι Οι δυο ακέραιοι είναι άνισοι Ο πρώτος ακέραιος είναι μεγαλύτερος ή ίσος με τον δεύτερο Ο πρώτος ακέραιος είναι μεγαλύτερος από τον δεύτερο Ο πρώτος ακέραιος είναι μικρότερος ή ίσος με τον δεύτερο Ο πρώτος ακέραιος είναι μικρότερος από τον δεύτερο.
Πίνακας 5-3.
Παράμετροι της test που σχετίζονται με ακεραίους
Άρνηση συνθήκης.
Λογικός Τελεστής NOT Λογικός τελεστής ΚΑΙ (AND).
Επιστρέφεται αληθής τιμή όταν ΚΑΙ οι δυο συνθήκες είναι αληθείς.
Λογικός τελεστής Ή (OR).
Επιστρέφεται αληθής τιμή όταν τουλάχιστον μια συνθήκη είναι αληθής.
Ειδικές παρενθέσεις που χρησιμοποιούνται για ομαδοποίηση συνθηκών. (escaped parentheses)
Εξετάζει αν η τρίτη παράμετρος είναι το string “Monday”.
Αν αυτό συμβαίνει είναι αληθής Εξετάζει αν το αρχείο /etc/passwd έχει κάτι μέσα γραμμένο και δεν είναι άδειο.
Αν συμβαίνει αυτό τότε η συνθήκη είναι αληθής.
Η εκτέλεση της εντολής δείχνει ταυτόχρονα ότι το αρχείο υπάρχει αλλά δεν μας λέει τι είναι.
Θα μπορούσε πχ να είναι κατάλογος Εξετάζει αν το αρχείο /etc/group είναι κατάλογος.
Με την άρνηση της συνθήκης η test είναι αληθής όταν το αρχείο ΔΕΝ είναι κατάλογος. (Πράγμα που συμβαίνει γιατί το αρχείο /etc/group είναι κανονικό αρχείο) Εξετάζει αν το αρχείο /bin/passwd έχει δικαίωμα SUID πράγμα που συμβαίνει οπότε η συνθήκη είναι αληθής και η test επιστρέφει 0. (κωδικός σωστής εκτέλεσης) Εξετάζει αν εκτελέστηκε σωστά η προηγούμενη εντολή.
Αν όντως εκτελέστηκε σωστά η συνθήκη είναι αληθής.
Εξετάζει αν εκτελέστηκε λάθος η τελευταία εντολή.
Για να είναι αληθής αυτή η συνθήκη πρέπει ταυτόχρονα η τελευταία εντολή να εκτελέστηκε ΚΑΙ σωστά ΚΑΙ λάθος, πράγμα αδύνατον οπότε η συνθήκη είναι ΠΑΝΤΑ ψευδής Για να είναι αληθής αυτή η συνθήκη πρέπει η τελευταία εντολή να έδωσε κωδικό σωστής εκτέλεσης 0 ή λάθος εκτέλεσης 1.
Αληθής ΠΑΝΤΑ σχεδόν για όλες τις εντολές.
Εξαιρούνται μόνο ορισμένες που επιστρέφουν και άλλους κωδικούς σφάλματος όπως πχ η expr Εξετάζει αν ο αριθμός παραμέτρων είναι μεγαλύτερος του 5 Εξετάζει αν το αρχείο /etc/printcap είναι κανονικό αρχείο και υπάρχει.
Η εντολή while χρησιμοποιείτε όπως σε όλες τις γλώσσες για την εκτέλεση ενός κύκλου εντολών κάτω από κάποια συνθήκη. (Conditional loop) Η σύνταξή της είναι ως εξής:
Θυμίζουμε ότι στην θέση της συνθήκης μπαίνει κάποια εντολή. (Συνήθως η εντολή test) Ο βρόχος while εκτελείται όσο η συνθήκη είναι αληθής.
Όσο δηλαδή η εντολή που παίζει το ρόλο της συνθήκης επιστρέφει κωδικό σωστής εκτέλεσης (κωδικός 0) Παρόμοια με τον βρόχο while.
Η until όμως εκτελείται όσο η συνθήκη είναι ψευδής.
Μόλις η συνθήκη γίνει αληθής σταματάει η εκτέλεση του βρόχου.
Η σύνταξή της είναι:
Η εντολή expr χρησιμοποιείτε για να υπολογίζει αριθμητικές εκφράσεις ακεραίων.
Ως γνωστό το κέλυφος του UNIX δεν αναγνωρίζει αριθμούς, οπότε τον ρόλο αυτό τον αναλαμβάνει η expr.
Προσθέτει το 1 στο i και βάζει το αποτέλεσμα ξανά στο i.
Αφαιρεί το 5 από το var και βάζει το αποτέλεσμα ξανά στο var Πολλαπλασιάζει το var με το 3 και βάζει το αποτέλεσμα στο var1 Διαιρεί το var με το 4 και βάζει το αποτέλεσμα στο var2
Προσοχή όλη η έκφραση περικλείεται σε ανάποδα εισαγωγικά (`) που σημαίνουν ότι η εντολή εκτελείται.
Η χρήση του \ πριν από το * και το / είναι αναγκαία γιατί αυτά τα σύμβολα για το κέλυφος είναι μεταχαρακτήρες.
Παράδειγμα expr σε while loop.
Η χρήση του i είναι για μετρητής εκτελέσεων του βρόχου.
H expr επιστρέφει κωδικό εκτέλεσης μεγαλύτερο ή ίσο του 2 όταν προσπαθούμε να κάνουμε πράξεις με μεταβλητές που ΔΕΝ είναι αριθμοί.
Φτιάξτε ένα πρόγραμμα σεναρίου κελύφους (script) που να δημιουργεί 100 αρχεία “i”file, δηλαδή 1file 2file 3file. 100file
Κάντε ένα πρόγραμμα σεναρίου κελύφους (script) με μια παράμετρο που να δημιουργεί ένα αρχείο με όνομα την παράμετρο.
Αν δοθεί χωρίς παράμετρο να δημιουργεί το myfile.txt.
Για περισσότερες από μια παραμέτρους να βγαίνει μήνυμα λάθους.
Αν το αρχείο με όνομα την παράμετρο υπάρχει να κάνει έλεγχο επικάλυψης (overwrite) να μας ρωτάει τι να κάνουμε και να κάνει ότι του πούμε.
Εντολές case και eval και κατασκευή ολοκληρωμένου προγράμματος κελύφους Στην συνέχεια θα μας χρειαστεί η εντολή case αν και ο κώδικας μπορεί να γραφτεί και με την χρήση των κατάλληλων if εντολών.
Η σύνταξη της εντολής case είναι:
Αν δοθεί το 1 ή το a τότε θα εκτελεστούν οι εντολές στην πρώτη περίπτωση.
Αν δοθούν το 2 ή το b τότε θα εκτελεστούν οι εντολές στην δεύτερη περίπτωση κλπ.
Αν το όρισμα που θα δοθεί δεν προβλέπεται τότε θα εκτελεστούν οι εντολές στην τελευταία περίπτωση που είναι πάντα το αστεράκι (*).
Αν το αστεράκι (*) δοθεί πριν από άλλες περιπτώσεις τότε όλες οι περιπτώσεις που ακολουθούν το αστεράκι (*) αγνοούνται και εκτελούνται οι εντολές στο αστεράκι (*).
Προσοχή ότι κάθε εντολή χωρίζεται από την άλλη με αλλαγή γραμμής ή με Ελληνικό ερωτηματικό (;) ενώ οι περιπτώσεις της εντολής case μεταξύ τους χωρίζονται από δύο Ελληνικά ερωτηματικά (;;).
Οι παρενθέσεις που δεν κλείνουν είναι απαραίτητες στην σύνταξη της εντολής, όπως και η λέξη “in”.
Η εντολή κλείνει με την λέξη “esac” που όπως παρατηρείτε είναι η case ανάποδα.
Η κάθετη γραμμή ( | ) σημαίνει διάζευξη (ή) ώστε να προβλέπονται διάφορες απαντήσεις για την ίδια περίπτωση.
Στην θέση των περιπτώσεων πχ στη θέση του a ή του 1 ή του b ή του 2 κλπ μπορούν να μπουν και κανονικές εκφράσεις.
Εδώ πρέπει να δώσουμε κάποια στοιχεία που χρειάζονται για την δημιουργία αυτής της έκδοσης του προγράμματος κελύφους.
Συγκεκριμένα το πρόβλημα είναι η αναγνώριση του τελευταίου ορίσματος.
Τεχνικές όπως var=\$$# δεν λειτουργούν.
Σας προτείνουμε λοιπόν δύο διαφορετικές μεθόδους λύσης του προβλήματος.
Μια είναι η χρήση ενός βρόγχου εντολής for ως ακολούθως:
Η άνω και κάτω τελεία είναι η κενή εντολή δηλαδή μια εντολή που δεν κάνει τίποτα.
Η όλη ιδέα είναι να τρέξει ο βρόγχος έτσι ώστε το i να πάρει την τιμή του τελευταίου ορίσματος.
Τότε δίνουμε αυτήν την τιμή στην μεταβλητή var.
Άλλος τρόπος είναι η χρήση της εντολής eval ως εξής:
Για να καταλάβουμε τι συμβαίνει εδώ ας θεωρήσουμε ότι έχουμε 5 ορίσματα.
Τότε $# = 5 και \$”$#” =$5.
Η εντολή echo αντηχεί το $5 και η εντολή eval υπολογίζει την τιμή του $5 που είναι για παράδειγμα η τιμή “mydirectory”.
Πρόβλημα υπάρχει ακόμα στην αντιγραφή των αρχείων.
Αυτό θα συμβεί γιατί πρέπει να αντιγραφούν όλα τα ορίσματα εκτός από το τελευταίο που είναι ο κατάλογος.
Έτσι θα πρέπει να έχουμε κάποιον τρόπο ώστε ο βρόχος να μην εκτελέσει αντιγραφή και του τελευταίου ορίσματος.
Αυτό μπορεί να γίνει με την χρήση μιας εντολής for όπως ακολούθως:
Φυσικά η τιμή της var είναι από πριν ο κατάλογος “mydirectory”.
Άλλος τρόπος είναι η χρήση μιας εντολής while ως ακολούθως:
Αυτή η εντολή εκτελείται μέχρι ο δείκτης να πάρει την τιμή του τελευταίου αρχείου που είναι το προτελευταίο όρισμα.
Επειδή η αντιγραφή γίνεται με την τιμή του ορίσματος και όχι με τον αριθμό του χρειάζεται να χρησιμοποιήσουμε την εντολή eval.
Δημιουργήστε ένα πρόγραμμα σεναρίου κελύφους με όνομα mycopy το οποίο χρησιμοποιεί παραμέτρους που αντιστοιχούν σε ονόματα αρχείων (λίστα από ορίσματα.) Να ελέγχει αν το τελευταίο είναι κατάλογος.
Αν δεν είναι τότε τα ορίσματα πρέπει να είναι ακριβώς δύο και να αντιγράφει το πρώτο στο δεύτερο κάνοντας και έλεγχο επικάλυψης (overwrite) και τον έλεγχο αν το αρχείο πηγή υπάρχει.
Αν είναι κατάλογος τότε η λίστα των προηγούμενων ορισμάτων αντιγράφεται στον κατάλογο ελέγχοντας αν αυτά τα ορίσματα είναι αρχεία και υπάρχουν και ελέγχοντας και την περίπτωση επικάλυψης. (overwrite).
Σύνταξη : grep [-n] [-v] [-y] [-i] [-w] [-f αρχείο] <πρότυπο> <αρχείο>
Ψάχνει την ύπαρξη του "πρότυπο" μέσα στο "αρχείο" και εμφανίζει τις γραμμές στις οποίες εντοπίστηκε. : οποιαδήποτε συμβολοσειρά (string) ή κανονική έκφραση. : το αρχείο στο οποίο γίνεται η αναζήτηση του "πρότυπο" : εμφανίζει πριν από κάθε γραμμή τον αριθμό της. : αντιστρέφει το ψάξιμο (εμφανίζει τις γραμμές που δεν περιέχουν το "πρότυπο") :Τα πεζά αντιστοιχούν και με πεζά και με κεφαλαία όμως τα κεφαλαία μόνο με κεφαλαία : κεφαλαία – πεζά το ίδιο. : μόνο ολόκληρες λέξεις : παίρνει το πρότυπο από αρχείο (Σε μερικά συστήματα δεν ισχύει για την grep.
Ισχύει όμως πάντα για egrep και fgrep) fgrep (fast grep) : το "πρότυπο" μπορεί να είναι μόνο συμβολοσειρά και όχι κανονική έκφραση, αλλά είναι γρήγορη.
Όλα τα άλλα ισχύουν όπως στην grep. egrep (expression grep): ψάχνει για κανονικές εκφράσεις με όλες τις συντάξεις και επιπλέον : : Μια ή περισσότερες επαναλήψεις της re : Για ομαδοποίηση (grouping) Στις παραπάνω συντάξεις η έκφραση ‘re’ θα πρέπει να αποτελείται είτε από ένα χαρακτήρα (π.χ. a+ , b? ) είτε από μία κανονική έκφραση που να υποδηλώνει ένα χαρακτήρα (π.χ. .+ , [yn]? ).
Σύνταξη : sort [-f] [-d] [-n] [-r] [+n] [-o αρχείο] [-t separator] <αρχείο> Ενέργεια : ταξινομεί τις γραμμές του αρχείου με αύξουσα σειρά και τις εμφανίζει στην προκαθορισμένη έξοδο (stdout). : το αρχείο στο οποίο γίνεται η ταξινόμηση : Αλφαβητική σειρά και τα πεζά ισοδυναμούν με τα κεφαλαία : Αλφαριθμητική ταξινόμηση, αγνοεί όλους τους χαρακτήρες εκτός από γράμματα, νούμερα και κενά. : ταξινομεί με φθίνουσα σειρά : αγνοεί τα πρώτα m πεδία : παράγει την έξοδο στο αρχείο (όχι στην οθόνη) : καθορίζει το διαχωριστικό των πεδίων : uniq [-u] [-d] [-c] [-w chars] [-number] [+number] <αρχείο εισόδου> <αρχείο εξόδου> : αφαιρεί τις διπλές γραμμές από ένα ταξινομημένο αρχείο. : τυπώνει μόνο τις μοναδικές γραμμές : τυπώνει μόνο τις διπλές γραμμές : τυπώνει πόσες φορές εμφανίζεται η κάθε γραμμή : χαρακτήρες που θα συγκρίνονται σε κάθε γραμμή : Παράβλεψε τόσα πεδία πριν την εξέταση (skip number fields before testing) : Παράβλεψε τόσους χαρακτήρες πριν την εξέταση (skip number chars before testing)
Ενέργεια : συγκρίνει τα δύο αρχεία και εμφανίζει τρεις στήλες : Η Πρώτη στήλη περιέχει γραμμές μοναδικές στο αρχείο1 Η Δεύτερη στήλη περιέχει γραμμές μοναδικές στο αρχείο2 Η Τρίτη στήλη περιέχει τις κοινές γραμμές. : αφαιρεί την πρώτη στήλη : αφαιρεί την δεύτερη στήλη : αφαιρεί την τρίτη στήλη
Ενέργεια : αντικαθιστά χαρακτήρες του set1 με αντίστοιχους από το set2 αντικαθιστά το σύνολο των ίδιων χαρακτήρων με ένα μόνο από αυτούς. π.χ. tr –s ‘ ’ βάζει μόνο ένα κενό όσα κενά και αν έχει εκεί αρχικά σβήνει το σύνολο των χαρακτήρων μέσα στα εισαγωγικά. π.χ. tr –d ‘a’ σβήνει όλα τα a από το κείμενο Η tr παίρνει είσοδο συνήθως από κάποια διοχέτευση.
Π.χ.
Μετατρέπει όλο το file1 σε κεφαλαία.
Ενέργεια : συγκρίνει τα δύο αρχεία.
Αν τα αρχεία είναι ίδια δεν εμφανίζει τίποτα.
Αν διαφέρουν εμφανίζει το byte και τον αριθμό γραμμής όπου βρέθηκε η πρώτη διαφορά. : εμφανίζει τον αριθμό του byte (δεκαδικό) και τα διαφορετικά bytes (οκταδικό). : επιστρέφει μόνο exit status : 0 = ίδια, 1=διαφορετικά, >1 error. : αριθμός bytes που παραβλέπονται στην αρχή του αρχείου 1 : αριθμός bytes που παραβλέπονται στην αρχή του αρχείου 2 Σύνταξη : diff [options] file1 file2 Ενέργεια : συγκρίνει τα δύο αρχεία.
Τα αρχεία μπορεί να είναι και κατάλογοι.
Αν τα αρχεία είναι ίδια δεν εμφανίζει τίποτα.
Αν διαφέρουν εμφανίζει τις γραμμές με τις διαφορές.
Σημασία βασικών παραμέτρων : : Αναδρομικά τους καταλόγους (recurse subdirs) : Αγνόησε διαφορές σε πεζά – κεφαλαία (ignore case) : δώσε αναφορά μόνο αν τα αρχεία διαφέρουν (report only if files differ) : παράγει ένα πρόγραμμα σεναρίου (script) για τον ed που αλλάζει το file1 στο file2.
Δημιουργήστε ένα πρόγραμμα σεναρίου κελύφους (script) με μια παράμετρο – όνομα αρχείου.
Ελέγξτε αν η παράμετρος είναι μια, ελέγξτε αν υπάρχει το αρχείο, και σβήστε από αυτό τις κενές γραμμές ή αυτές που έχουν μόνο λευκούς χαρακτήρες.
Μετατρέψτε τα ονόματα των αρχείων σε ένα υποκατάλογο του αρχικού καταλόγου σας από πεζά σε κεφαλαία.
Εμφανίστε όλα τα ονόματα των αρχείων από πεζά σε κεφαλαία.
Δίνεται ένα λεξικό που έχει αποθηκευμένες λέξεις της Αγγλικής γλώσσας μια λέξη σε κάθε γραμμή.
Να βρεθούν οι λέξεις που έχουν από μια φορά το κάθε φωνήεν και τα πέντε φωνήεντα στην αλφαβητική τους σειρά.
Τέτοιες λέξεις είναι: Abstemious acheilous affectious arterious facetious majestious abstemiously acheirous annelidous bacterious facetiously κλπ
Δίνεται ένα λεξικό που έχει αποθηκευμένες λέξεις της Αγγλικής γλώσσας μια λέξη σε κάθε γραμμή.
Βρείτε όλες τις λέξεις με έξι ή περισσότερα γράμματα διατεταγμένα σε αλφαβητική σειρά.
Τα γράμματα της αλφαβήτου μπορεί να υπάρχουν ή να μην υπάρχουν άμα υπάρχουν, υπάρχουν μια φορά και στην αλφαβητική τους σειρά.
Abdest befist chintz egilops acknow behint dehors ghosty adipsy beknow dehort agnosy bijoux deinos almost biopsy dimpsy κλπ
O ed μπορεί να επεξεργάζεται μόνο ένα αρχείο κάθε φορά.
Η επεξεργασία στον ed γίνεται γραμμή-γραμμή.
Η μόνη εντολή που επεξεργάζεται λέξεις σε γραμμές όπως θα δούμε είναι η εντολή της αντικατάστασης (substitude).
Στα επόμενα δημιουργούμε το αρχείο arnaki χρησιμοποιώντας το γνωστό παιδικό ποίημα. cat arnaki (βλέπουμε τα περιεχόμενα του αρχείου που μόλις δημιουργήσαμε.) Όταν ξεκινάμε ένα αρχείο αυτό είναι άδειο.
Ο ed ξεκινάει σε κατάσταση εντολών (command mode) και περιμένει από μας εντολές.
Η γενική σύνταξη των εντολών του ed είναι ως εξής :
Οι διευθύνσεις (1 και 2) αντιστοιχούν είτε σε αριθμούς γραμμών είτε σε σύμβολα που αντιπροσωπεύουν συγκεκριμένες γραμμές είτε κανονικές εκφράσεις που ταιριάζουν με κάποιες γραμμές του αρχείου και καθορίζουν την εμβέλεια εκτέλεσης της εντολής.
Η επεξήγηση των διευθύνσεων εμβέλειας θα γίνει παρακάτω με την βοήθεια της εντολής p (print) που τυπώνει γραμμές του αρχείου.
Αν δοθεί μία διεύθυνση τότε η εντολή θα εκτελεστεί για μία μόνο γραμμή π.χ. εκτυπώνει την 5η γραμμή του αρχείου Αν δοθούν δύο διευθύνσεις τότε η εντολή θα εκτελεστεί για την περιοχή γραμμών που καθορίζεται από αυτές τις διευθύνσεις π.χ. εκτυπώνει τις γραμές 2..6 Αντί για πραγματικό αριθμό γραμμής μπορούν να χρησιμοποιηθούν επίσης τα σύμβολα: υποδηλώνει την τελευταία γραμμή του αρχείου υποδηλώνει την τρέχουσα γραμμή του αρχείου αντιστοιχεί με την εμβέλεια 1,$ τυπώνει όλο το αρχείο τυπώνει από την τρέχουσα γραμμή έως και την 8η.
Πρέπει εδώ να σημειωθεί ότι ως γραμμή 0 θεωρείται το σημείο πριν από την πρώτη γραμμή του αρχείου (η αρχή του αρχείου).
Ακόμα στη θέση των διευθύνσεων εμβέλειας μπορούν να μπούν και κανονικές εκφράσεις (αναλύονται στο επόμενο κεφάλαιο) που υποδηλώνουν τις γραμμές με τις οποίες ταιριάζουν π.χ. θα εμφανίσει όλες τις γραμμές που έχουν τη λέξη “kai”. θα εμφανίσει όλες τις γραμμές που ξεκινούν από την πρώτη γραμή που έχει μέσα της τη λέξη “aspro” και τελειώνουν με την τελευταία γραμμή που έχει μέσα της τη λέξη “kamari”.
Εαν δεν δοθεί εμβέλεια εντολής τότε η εντολή εκτελείται μόνο για την τρέχουσα γραμμή του αρχείου.
Η τρέχουσα γραμμή του αρχείου αρχικά είναι η 1η και μετά από εκτέλεση εντολών τρέχουσα γραμμή είναι η γραμμή για την οποία εκτελέστηκε η τελευταία εντολή.
Η εντολή για να γράψουμε κείμενο είναι η εντολή a η οποία γυρνάει τον ed σε κατάσταση εισαγωγής κειμένου.
Έτσι λοιπόν γράφουμε το κείμενο μας και όταν τελειώσουμε πρέπει να πούμε στον ed να ξαναγυρίσει σε κατάσταση εντολών.
Αυτό γίνεται όταν δώσουμε μια τελεία σκέτη στην πρώτη στήλη του κειμένου όπως στο παράδειγμα.
Μόλις ο ed γυρίσει σε κατάσταση εντολών τότε μπορούμε να σώσουμε το κείμενο με την εντολή w ακολουθούμενη από το όνομα του αρχείου.
Αν δεν δώσουμε όνομα τότε εφόσον είχαμε δώσει όνομα στην αρχή χρησιμοποιεί αυτό (Αν είχαμε γράψει ed arnaki τότε με ένα σκέτο w σώζει στο αρχείο arnaki) και εκτελέσουμε πάλι την εντολή cat θα δούμε πως η νέα γραμμή βρέθηκε δεύτερη.
Αυτό συμβαίνει γιατί η εντολή a βάζει νέες γραμμές μετά την τρέχουσα γραμμή που στην αρχή είναι η πρώτη.
Αν θέλαμε η γραμμή να πάει στην αρχή έπρεπε να γράψουμε την εντολή i αντί την εντολή a.
Το a είναι το append ενώ το i είναι το insert.
Για να δούμε το κείμενο ενώ είμαστε μέσα στον ed πρέπει να του δώσουμε την εντολή της εκτύπωσης p (print).
Έτσι η εντολή 3p τυπώνει την τρίτη γραμμή ενώ η εντολή .p την τρέχουσα γραμμή.
Κάθε γραμμή συμβολίζεται με τον αριθμό της, η τρέχουσα γραμμή είναι αυτή που επηρεάστηκε από εντολή τελευταία και η τελευταία γραμμή συμβολίζεται με το δολάριο ($).
Άμα θέλουμε να τυπώσουμε μια σειρά γραμμών πχ από την πρώτη ως την τρίτη γράφουμε 1,3p ενώ από την τρέχουσα μέχρι την τελευταία γράφουμε .,$p.
Για να σβήσουμε τις γραμμές 2 και 3 γράφουμε 2,3d.
Η εντολή d (delete) είναι η εντολή σβησίματος (σειρών πάντα).
Για να βρούμε μια λέξη ή έκφραση στο κείμενο γράφουμε ?arnaki? (για την λέξη arnaki και έρευνα προς τα πάνω) ή /arnaki/ (για την λέξη arnaki και έρευνα προς τα κάτω).
Η εντολή Η κάνει τον ed να εξηγεί όλα τα λάθη που θα κάνουμε. (βοήθεια κατά κάποιον τρόπο) ενώ η εντολή h δίνει εξήγηση μόνο για το τελευταίο μας λάθος.
Η εντολή n,n+1j ενώνει της γραμμές n και n+1.
Η εντολή Q βγαίνει από τον ed χωρίς πρώτα να σώσουμε το κείμενο.
Η εντολή 2,3n τυπώνει τις γραμμές 2 και 3 μαζί με τον αριθμό τους.
Η εντολή 1,2t4 αντιγράφει τις γραμμές 1 και 2 μετά την γραμμή 4.
Η εντολή 1,$g/arnaki/command list εκτελεί όλες τις εντολές της λίστας εντολών σε όποιες σειρές, από την πρώτη μέχρι την τελευταία έχουν γραμμένη την λέξη arnaki.
Όλες οι εντολές στην λίστα εκτός από την τελευταία πρέπει να λήγουν με backslash (\).
Τα g και n δεν είναι απαραίτητα και μπορεί να υπάρχει το ένα από αυτά ή και κανένα.
Το g σημαίνει κάνε αντικατάσταση της λέξης όσες φορές και αν την βρεις στην γραμμή, ενώ το n είναι ένας αριθμός πχ το 5 που σημαίνει από όλες τις φορές που θα βρεις την λέξη στην γραμμή κάνε αντικατάσταση μόνο την πέμπτη φορά.
Το 1,$ είναι το βεληνεκές (range) και δείχνει σε ποιες γραμμές θα γίνει η αντικατάσταση. (Στην περίπτωση αυτή σε όλο το κείμενο μια που το $ σημαίνει την τελευταία γραμμή) sed [-n] [-e] [-f <αρχείο εντολών ed>] <λίστα εντολών ed> αρχείο Εκτελεί τις εντολές του ed στο αρχείο. : το αρχείο στο οποίο εκτελούνται οι εντολές του ed. : παίρνει τη λίστα εντολών του ed από αυτό το αρχείο : Σταματά την έξοδο όταν υπάρχουν εντολές εκτύπωσης έτσι ώστε να εκτυπωθούν ΜΟΝΟ όσα τυπώνουν αυτές οι εντολές και όχι όλο το κείμενο.
Τέτοιες εντολές είναι η p και η w. : Ενώνει εντολές του ed στην ίδια γραμμή.
Οι εντολές του ed που δέχεται ο sed έχουν την ακόλουθη γενική μορφή: [Διεύθυνση [ , Διεύθυνση]] εντολή [παράμετροι] Από τις εντολές του ed που δέχεται ο sed οι σημαντικότερες είναι: : σβήνει τις γραμμές που περιγράφουν οι διευθύνσεις. : τυπώνει τις γραμμές που περιγράφουν οι διευθύνσεις.
[Διεύθ.
[ , Διεύθ.]] s/κανον.έκφραση/αντικατάσταση/[g] : αντικαθιστά την πρώτη «κανονική έκφραση» που θα βρει σε κάθε γραμμή με την «αντικατάσταση».
Αν προστεθεί η παράμετρος g τότε αντικαθίστανται όλες οι «κανονικές εκφράσεις» στην ίδια γραμμή και όχι μόνο η πρώτη.
[Διεύθ.
[ ,Διεύθ.]] w αρχείο :γράφει τις γραμμές που περιγράφουν οι διευθύνσεις στο «αρχείο».
[Διεύθ.
[ , Διεύθ.]] !εντολή : εκτελεί την “εντολή” για όλες τις γραμμές εκτός από αυτές που περιγράφουν οι διευθύνσεις.
Ισοδυναμεί με grep ‘kai’ arnaki Ισοδυναμεί με grep –v ‘kai’ arnaki Σβήνει τις γραμμές που περιέχουν την λέξη ‘kai’ Τυπώνει τις γραμμές 20 μέχρι 30 Σβήνει τις γραμμές 1 ως 10 Διαγράφει από την πρώτη γραμμή μέχρι την πρώτη κενή γραμμή που θα βρει.
Τυπώνει όλες τις ομάδες γραμμών που ξεκινάνε από μια κενή γραμμή μέχρι μια που αρχίζει από ‘kai’ Σβήνει την τελευταία γραμμή.
Βάζει τις γραμμές που περιέχουν το ‘kai’ στο αρχείο file1
Βάζει τις γραμμές που ΔΕΝ περιέχουν το ‘kai’ στο αρχείο file2.
Κάνει τα προηγούμενα δύο μαζί σε μια γραμμή
Στην αρχή κάθε γραμμής του αρχείου arnaki προσθέστε ένα tab
Στην αρχή κάθε γραμμής που δεν είναι κενή του αρχείου arnaki προσθέστε ένα tab sed ‘s/^..*$/<tab>&/’ arnaki κλπ
Άσκηση shell_users Να εμφανιστούν τα login όλων των χρηστών που χρησιμοποιούν tcsh.
Να αναπτυχθεί πρόγραμμα σεναρίου κελύφους που να παίρνει σαν παράμετρο το όνομα ενός group και να εμφανίζει τα login όλων των χρηστών που ανήκουν σε αυτό το group.
Να ελέγχει αν η παράμετρος είναι μία και αν το group υπάρχει.
Να αναπτυχθεί πρόγραμμα σεναρίου κελύφους που να παίρνει σαν παράμετρο το όνομα ενός group και να εμφανίζει τα πραγματικά ονόματα (geccos) όλων των χρηστών που ανήκουν σε αυτό το group.
Να ελέγχει αν η παράμετρος είναι μία και αν το group υπάρχει.
Η τελευταία λύση είναι πιο κομψή και ταχύτερη να εκτελεστεί γιατί δεν γράφει καθόλου σε προσωρινό αρχείο.
Φυσικά η ίδια λύση μπορεί να χρησιμοποιηθεί και για το πρόβλημα list_group1 μια που το μόνο που αλλάζει είναι το γεγονός ότι αντί το login θέλουμε το gecos, οπότε η τελευταία κανονική παράσταση είναι στην list_group2 πιο πολύπλοκη από ότι στην list_group1.
Στην πράξη λοιπόν και οι τέσσερις λύσεις μπορούν να χρησιμοποιηθούν και για τις δυο ασκήσεις αλλάζοντας απλά την γραμμή που επιλέγει στο τέλος το login ή το gecos.
Άλλες σημαντικές εντολές
Οι εντολή true δίνει έξοδο πάντα αληθή (0) ενώ η εντολή false δίνει έξοδο πάντα ψευδή (1).
Έτσι εντολές όπως η ακόλουθη:
Είναι ατέρμονες κύκλοι και εκτελούνται μέχρι κάποια εντολή από το σώμα των εντολών να μας βγάλει από αυτόν τον κύκλο (loop), όπως η εντολή break.
Η εντολή set όταν δοθεί με όρισμα μια μεταβλητή «σπάει» την μεταβλητή σε πεδία.
Προκαθορισμένος διαχωριστής στο κέλυφος του UNIX είναι λευκός χαρακτήρας δηλαδή κενό ή tab.
Ο διαχωριστής μπορεί να αλλάξει στο κέλυφος αν χρησιμοποιηθεί η εντολή:
Στο παράδειγμα κάναμε διαχωριστή την άνω και κάτω τελεία όπως συμβαίνει στις γραμμές του αρχείου /etc/passwd όμως αντί για άνω και κάτω τελεία μπορούμε να βάλουμε όποιον διαχωριστή θέλουμε ανάλογα με την περίπτωση.
Αν τώρα δοθεί η set στις γραμμές του /etc/passwd θα τις σπάσει σε 7 πεδία όπως είναι και η πραγματικότητα για αυτό το αρχείο.
Μόλις γίνει αυτό το κέλυφος θα «πετάξει» όσες παραμέτρους κρατούσε στις θέσεις $1 $2 κλπ και στην θέση τους θα βάλει τα πεδία που δέχτηκε από την εντολή set.
Στο $1 θα μπει το πρώτο πεδίο που είναι το login στο $2 θα μπει το δεύτερο πεδίο που είναι το password κλπ.
Σε αυτήν την περίπτωση πρέπει να προνοήσουμε ώστε πριν χαθούν οι αρχικές παράμετροι που είχαν οι $1 $2 $3 κλπ να τις βάλουμε σε μεταβλητές.
H set θα δοθεί με την μορφή:
Όπου var θα είναι μια σειρά του αρχείου /etc/passwd Εφόσον θέλουμε ο διαχωριστής να γίνει το νέο σύμβολο που θέσαμε με την IFS σε όλα τα κελύφη τότε πρέπει να δώσουμε και την εντολή export.
Για να επαναφέρουμε την IFS στην προκαθορισμένη τιμή της που είναι κενό ή tab εκτελούμε ξανά την απόδοση τιμής στην IFS και της δίνουμε τις προκαθορισμένες τιμές:
Η εντολή echo:Η εντολή την οποία θα χρησιμοποιήσουμε σε αυτήν την άσκηση θα ενώνει τις τιμές των μεταβλητών onoma diefthinsi και tilefono με διαχωριστή το «^» και θα προσθέτει τις νέες εγγραφές στο τέλος του αρχείου phonebook.
Συγκεκριμένα το σύμβολο «>>» προσθέτει εγγραφές στο τέλος ενός αρχείου. (append) Για να δώσει η echo τον δρομέα στην ίδια γραμμή και όχι σε νέα γραμμή όπως κάνει, πρέπει να δώσουμε το κλειδί \c στο τέλος της εντολής ως εξής: echo “doste stoixeia pros anazitisi:\c” που αντιστοιχεί και στην Το κλειδί \r επαναφέρει την echo να γράψει από την αρχή της σειράς: πρώτα βάζει τρία tab μετά βάζει «|» μετά γυρνάει στην αρχή της σειράς και βάζει «|Hello» πάνω σε ότι είχε γράψει προηγουμένως.
Έτσι το αποτέλεσμα θα είναι:
Συνήθως αυτό το κλειδί το χρησιμοποιούμε για στοίχιση.
Προσοχή στην χρήση της echo.
Σε συστήματα Linux για να δουλέψουν οι χαρακτήρες κλειδιά όπως \c ή \r και λοιπά πρέπει να δοθούν με το διακόπτη –e.
Πχ: Αν θέλουμε να μεταβάλουμε την προκαθορισμένη είσοδο γενικά στο τρέχον κέλυφος και όχι σε μια εντολή χρησιμοποιούμε την εντολή exec.
Μετά την εκτέλεση αυτής της εντολής όλες οι εντολές στο τρέχον κέλυφος δέχονται είσοδο από το αρχείο /temp/text.txt Για να επαναφέρουμε την προκαθορισμένη είσοδο στο πληκτρολόγιο πρέπει να ξαναεκτελέσουμε την ίδια εντολή.
Φυσικά για κάθε εντολή ξεχωριστά μπορούμε να παίρνουμε είσοδο από όπου θέλουμε με μια απλή ανακατεύθυνση εισόδου (<).
Οι εντολές όπως οι while, case, if, for κλπ είναι και αυτές εντολές κελύφους και τις αντιμετωπίζουμε σαν τέτοιες.
Αυτό σημαίνει ότι παίρνουν ανακατεύθυνση εισόδου στο τέλος τους.
Ακολουθεί ένα παράδειγμα με μια εντολή while
Η εντολή όπως βλέπουμε εισάγει δεδομένα από το αρχείο /tmp/data.
Αυτό σημαίνει ότι ΟΛΕΣ οι εντολές που διαβάζουν δεδομένα όπως πχ η read παίρνουν δεδομένα από αυτό το αρχείο.
Η πρώτη read διαβάζει την πρώτη γραμμή των δεδομένων η δεύτερη την δεύτερη γραμμή κλπ.
Όταν τελειώσει ο πρώτος κύκλος της while η εισαγωγή δεδομένων συνεχίζετε από τις read με την σειρά χωρίς να κλείσει το αρχείο /tmp/data το οποίο κλείνει ΜΟΝΟ όταν εκτελεστεί και τελειώσει η while.
Επομένως οι read διαβάζουν τις επόμενες σειρές δεδομένων.
Τι θα γινόταν όμως αν η ανακατεύθυνση εισόδου έμπαινε στην εντολή-συνθήκη read;
Σε αυτήν την περίπτωση κάθε φορά που εκτελείται η while, η read εκτελείται και αυτή μια ακόμα φορά.
Αυτό σημαίνει ότι στην πρώτη εκτέλεση η read ανοίγει το αρχείο και διαβάζει την πρώτη γραμμή.
Μετά κλείνει το αρχείο.
Στην επόμενη εκτέλεση του κύκλου της while η read ξαναεκτελείται, ανοίγει ξανά το αρχείο και διαβάζει ξανά την πρώτη γραμμή.
Έτσι λοιπόν η read διαβάζει ΠΑΝΤΑ την πρώτη γραμμή των δεδομένων και δεν προχωράει ποτέ.
Οπότε ο σχηματισμός αυτός παρόλο που στέκει συντακτικά μας είναι άχρηστος (συνήθως) Κλείνοντας πρέπει να τονίσουμε ότι αν υπάρχει ανακατεύθυνση εισόδου ΠΑΝΩ σε μια εντολή αυτή διαβάζει δεδομένα από την δικιά της ανακατεύθυνση και όχι από κει που λέει για παράδειγμα μια εντολή exec που εκτελέστηκε νωρίτερα ή μία εντολή όπως η while αν η συγκεκριμένη read ανήκει στο σώμα (block) εντολών της while.
Δημιουργήστε ένα πρόγραμμα σεναρίου κελύφους (script) το οποίο να εμφανίζει τα ακόλουθα:
doste epilogi:_ (όπου _ είναι η θέση του δρομέα)
Να διαβάζει την επιλογή και να καλεί το αντίστοιχο υπο-πρόγραμμα σεναρίου κελύφους ανάλογα με την επιλογή.
Επίσης να ελέγχεται αν η επιλογή είναι σωστή.
Το πρόγραμμα τελειώνει ΜΟΝΟ με 6 ή με Τ ή με t.
Τα υπο-προγράμματα που καλούνται αρχικά απλά τυπώνουν το όνομά τους και στην συνέχεια τα γράφουμε και αυτά (στην συνέχεια της άσκησης) ώστε να κάνουν τις σωστές ενέργειες.
Διαβάζει ονοματεπώνυμο διεύθυνση και τηλέφωνο σε τρεις μεταβλητές onoma diefthinsi και tilefono τα ενώνουμε και τα στέλνουμε στην βάση δεδομένων phonebook με την μορφή
Διαγράφει μια εγγραφή από την βάση δεδομένων.
Συνδυασμός της επιλογής ένα και δύο.
Δηλαδή πρώτα διαγράφουμε την εγγραφή και μετά βάζουμε τα στοιχεία ξανά.
Δίνουμε ένα κλειδί για να ψάξει και εμφανίζει αυτό που ψάχνουμε
Εμφάνιση όλων των συνδρομητών. αρχείο list_all Στην θέση της more μπορεί να μπει και μια cat αν τα περιεχόμενα του phonebook χωράνε σε μια οθόνη, όπως και φίλτρα για αντικατάσταση των διαχωριστών «^» και σωστή στοίχιση των στηλών του αρχείου.
Η AWK είναι μία γλώσσα προγραμματισμού εξειδικευμένη στον χειρισμό αρχείων κειμένου που αποτελούνται από εγγραφές (γραμμές κειμένου) χωρισμένες σε πεδία (στήλες).
Συμπεριλαμβάνει πολλές γνωστές δομές προγραμματισμού και συναρτήσεις που συναντώνται σε κατ’εξοχήν γλώσσες προγραμματισμού όπως η C.
Η γενική σύνταξη εκτέλεσης της AWK είναι : η σημασία των παραμέτρων είναι η ακόλουθη: : καθορίζει τον χαρακτήρα που χρησιμοποιείται για τον διαχωρισμό πεδίων (οι εξ’ορισμού χαρακτήρες είναι το κενό (space) και το tab. : εκχωρεί τιμή σε μεταβλητές πριν την έναρξη του προγράμματος. : το πρόγραμμα awk που θα εκτελεστεί (σε εισαγωγικά). : καθορίζει το αρχείο που περιέχει το πρόγραμμα awk που θα εκτελεστεί.
Οι εντολές ενός προγράμματος awk έχουν την ακόλουθη γενική σύνταξη:
Το Πρότυπο είναι γενικά μία λογική συνθήκη ή κανονική έκφραση.
Η Δράση είναι γενικά μία λίστα εντολών (χωριζόμενες με “;”) π.χ. {εντολή1; εντολή2; εντολή3}.
Ο εσωτερικός μηχανισμός της awk διαβάζει το αρχείο εισόδου γραμμή-γραμμή και σε όποια γραμμή ταιριάζει το «Πρότυπο» τότε εκτελείται η «Δράση».
Σε κάθε γραμμή του αρχείου εισόδου που επεξεργάζεται η awk αναθέτει τα διακεκριμένα πεδία της γραμμής (στήλες) στις μεταβλητές $1, $2, $3, .....$n.
Επίσης ολόκληρη η γραμμή που επεξεργάζεται κάθε φορά η awk ανατίθεται στη μεταβλητή $0.
Αν σε μία εντολή awk λείπει το «Πρότυπο» τότε η «Δράση» εκτελείται σε κάθε γραμμή του αρχείου εισόδου.
Αν σε μία εντολή awk λείπει η { Δράση } τότε η εξ’ορισμού εντολή που εκτελείται είναι η εκτύπωση της γραμμής.
Το ειδικό πρότυπο “BEGIN” ταιριάζει με την αρχή του αρχείου και η εντολή που ακολουθεί εκτελείται πριν από το διάβασμα της πρώτης γραμμής του αρχείου (χρησιμοποιείται για αρχικοποιήσεις).
Το ειδικό πρότυπο “END” ταιριάζει με το τέλος του αρχείου και η εντολή που ακολουθεί εκτελείται μετά από το διάβασμα και της τελευταίας γραμμής του αρχείου (χρησιμοποιείται για εκτύπωση τελικών αποτελεσμάτων).
Στα προγράμματα awk ο χρήστης μπορεί να χρησιμοποιήσει μεταβλητές.
Τα ονόματα των μεταβλητών ακολουθούν τους γνωστούς κανόνες ονοματολογίας.
Ανάθεση σε μεταβλητές γίνεται με το «=» π.χ.:
Όλες οι μεταβλητές θεωρούνται ότι έχουν αρχική τιμή 0 ή null.
Επίσης μπορούν να χρησιμοποιηθούν οι τελεστές +, -, *, /, %(υπόλοιπο διαίρεσης), ^(ύψωση σε δύναμη), π.χ.
Ακόμα μπορούν να χρησιμοποιηθούν οι ακόλουθοι τελεστές : : αύξηση κατά ένα (π.χ.
Α++ το ίδιο με Α=Α+1) : μείωση κατά ένα (π.χ.
Β-- το ίδιο με Β=Β-1) : αύξηση κατά μία ποσότητα (π.χ.
Α+=5 το ίδιο με Α=Α+5) : μείωση κατά μία ποσότητα (π.χ.
Β-=3 το ίδιο με Β=Β-3) : πολ/σμός επί μία ποσότητα (π.χ.
Α*=2 το ίδιο με Α=Α*2) : διαίρεση δια ποσότητα (π.χ.
Β/=4 το ίδιο με Β=Β/4) : αντικατάσταση με υπόλοιπο διαίρεσης (π.χ.
Α%=10 το ίδιο με Α=Α%10) : ύψωση σε δύναμη (π.χ.
Β^=2 το ίδιο με Β=Β^2)
Στα προγράμματα awk υπάρχουν και κάποιες προκαθορισμένες μεταβλητές οι βασικές από τις οποίες είναι: : ο χαρακτήρας διαχωρισμού πεδίων. : ο αριθμός πεδίων σε κάθε γραμμή που επεξεργάζεται η awk. : ο αριθμός της τρέχουσας γραμμής που επεξεργάζεται η awk. : το όνομα του αρχείου εισόδου.
Ως «Πρότυπο» μπορεί να είναι εκτός από τα BEGIN και END μία οποιαδήποτε κανονική έκφραση (/RE/) ή μία συνθήκη μεταξύ μεταβλητών.
Οι σχεσιακοί τελεστές που μπορούν να χρησιμοποιηθούν είναι : < , <=, > , >=, = = , !=.
Επίσης μπορούν να χρησιμοποιηθούν οι τελεστές ~ και !~: : ελέγχει αν η var ταιριάζει με την κανονική έκφραση /RE/. : ελέγχει αν η var δεν ταιριάζει με την κανονική έκφραση /RE/.
Επίσης μπορούν να κατασκευαστούν και σύνθετες συνθήκες με τους τελεστές !(not) , && (and) , || (or). : αληθές για κάθε γραμμή που έχει πάνω από 4 πεδία. : αληθές μόνο για τη γραμμή 5. : αληθές όταν το πρώτο πεδίο είναι μικρότερο ή ίσο με το τρίτο. : αληθές για όλες τις γραμμές που αρχίζουν από a. : αληθές όταν το πρώτο πεδίο είναι “Ann” και τα πεδία είναι λιγότερα από 6. : αληθές όταν το δεύτερο πεδίο έχει την λέξη “the”.
Ανάθεση τιμής σε μεταβλητή sum+=$1 ή p=q^3 print λίστα ορισμάτων printf(format, λίστα ορισμάτων) εκτυπώνει φορμαρισμένα τα ορίσματα παρόμοια με την printf της γλώσσας C αν ισχύει η συνθήκη εκτελείται το πρώτο block εντολών αλλιώς εκτελείται το δεύτερο βρόχος while – όσο ισχύει η συνθήκη εκτελείται το block εντολών βρόχος do while - όσο ισχύει η συνθήκη εκτελούνται οι εντολές του block έξοδος από βρόχο. επόμενη επανάληψη βρόχου.
Στις εκφράσεις μπορούν να χρησιμοποιηθούν και οι ακόλουθες συναρτήσεις: : τετραγωνική ρίζα του n : μήκος του string s : τυχαίος αριθμός στο διάστημα 0..1 : το ακέραιο μέρος του x : το κομμάτι του string s που αρχίζει στη θέση m και έχει μήκος n. : η θέση μέσα στο string s όπου υπάρχει το string t : η θέση μέσα στο string s όπου υπάρχει η κανονική έκφραση ere. sub(ere,repl,in): αντικαθιστά στο string in την κανονική έκφραση ere με το repl (μία φορά). gsub(ere,repl,in): αντικαθιστά στο string in την κανονική έκφραση ere με το repl (όλες τις φορές). sprintf(fmt,list): επιστρέφει το string που προκύπτει από το φορμάρισμα της λίστας μεταβλητών list με βάση το format fmt. : εκτελεί την εντολή cmd και επιστρέφει το αποτέλεσμα εξόδου (exit status). : μετατρέπει το string s σε κεφαλαία. : μετατρέπει το string s σε μικρά. : διαβάζει την επόμενη γραμμή από το αρχείο εισόδου και την βάζει στην μεταβλητή $0 ή προαιρετικά στην μεταβλητή x.
Σε όλες τις συναρτήσεις όταν λείπει το όρισμα εννοείται το $0 (π.χ. length==10 σημαίνει length($0)==10)\ Να κατασκευάσετε προγράμματα AWK που να τυπώνουν στην καθιερωμένη έξοδο:
τον συνολικό αριθμό γραμμών εισόδου την δέκατη γραμμή εισόδου το τελευταίο πεδίο κάθε γραμμής το τελευταίο πεδίο της τελευταίας γραμμής εισόδου κάθε γραμμή εισόδου με περισσότερα από 4 πεδία κάθε γραμμή εισόδου που το τελευταίο πεδίο είναι μεγαλύτερο του 90 τον συνολικό αριθμό πεδίων όλων των γραμμών το συνολικό αριθμό γραμμών που περιέχουν την λέξη “Asia”.
το μεγαλύτερο πρώτο πεδίο και τη γραμμή που το περιέχει.
κάθε γραμμή που έχει τουλάχιστον ένα πεδίο.
κάθε γραμμή μεγαλύτερη των 80 χαρακτήρων τον αριθμό των πεδίων κάθε γραμμής και στη συνέχεια την ίδια τη γραμμή τα δύο πρώτα πεδία κάθε γραμμής με αντιμετάθεση κάθε γραμμή με τα δύο πρώτα πεδία σε αντιμετάθεση κάθε γραμμή με το πρώτο πεδίο της να αντικαθίσταται από τον αύξοντα αριθμό της κάθε γραμμή μετά την διαγραφή του δεύτερου πεδίου της κάθε γραμμή με τα πεδία της σε ανάποδη σειρά τα αθροίσματα των πεδίων κάθε γραμμής το άθροισμα όλων των πεδίων όλων των γραμμών κάθε γραμμή με τα πεδία της να έχουν αντικατασταθεί με τις απόλυτες τιμές τους
Η AWK εκτός από τις απλές μεταβλητές μπορεί να χειριστεί και πίνακες.
Οι πίνακες μπορούν να έχουν οποιοδήποτε όνομα όπως και οι μεταβλητές.
Στους πίνακες δεν χρειάζεται να καθορίσουμε από την αρχή το μέγεθός τους.
Το μέγεθος αλλάζει δυναμικά καθώς καταχωρούνται και νέα στοιχεία στον πίνακα και περιορίζεται μόνο από την διαθέσιμη μνήμη του συστήματος.
Οι θέσεις ενός πίνακα που δεν έχουν ακόμα αρχικοποιηθεί θεωρούνται μηδέν.
Ένα στοιχείο του πίνακα προσδιορίζεται από τον δείκτη θέσης του μέσα σε τετράγωνες αγκύλες.
Για παράδειγμα το 5ο στοιχείο του πίνακα Α είναι το Α[5].
Παρακάτω υπάρχει ένα παράδειγμα προγράμματος awk που εισάγει σε ένα πίνακα P τους αριθμούς από 1 έως 100:
Το επόμενο παράδειγμα τοποθετεί σε ένα πίνακα τις γραμμές του αρχείου και τις τυπώνει μία παρά μία:
Στην AWK μπορούμε να χρησιμοποιήσουμε ως δείκτη σε ένα πίνακα όχι μόνο ένα νούμερο αλλά ένα οποιοδήποτε αλφαριθμητικό.
Έτσι μπορούμε να έχουμε εκφράσεις όπως οι παρακάτω:
Σε συνδυασμό με τους προσεταιριστικούς πίνακες διατίθεται και μία επιπλέον σύνταξη για το βρόχο for:
Ο βρόχος αυτός εκτελείται τόσες φορές όσες είναι και οι θέσεις του <πίνακα> και κάθε φορά η <μεταβλητή> παίρνει διαδοχικές τιμές δεικτών του πίνακα (είτε οι δείκτες είναι αριθμοί είτε είναι αλφαριθμητικά). αν ο πίνακας A έχει δύο θέσεις την John και την Mary τότε ο βρόχος θα τρέξει δύο φορές.
Την πρώτη φορά το i θα έχει την τιμή “John” και την δεύτερη την τιμή “Mary”.
Στην οθόνη βέβαια θα εμφανιστούν οι αριθμοί 1 και 4 (σύμφωνα με το πιο πάνω παράδειγμα).
Η δυνατότητα των προσεταιριστικών πινάκων είναι εξαιρετικά χρήσιμη σε προβλήματα όπως το επόμενο: Έστω ότι έχουμε ένα αρχείο με τους μισθούς που πήραν οι υπάλληλοι μιας εταιρίας της μορφής:
Το πρόβλημα που τίθεται είναι να προσθέσουμε τους μισθούς για κάθε υπάλληλο.
Αν δεν υπήρχαν οι προσεταιριστικοί πίνακες θα έπρεπε να γράψουμε ένα πρόγραμμα παρόμοιο με το ακόλουθο:
Όμως με την ύπαρξη των προσεταιριστικών πινάκων το πρόγραμμα απλοποιείται σημαντικά και είναι το ακόλουθο:
Σε συνδυασμό με τους πίνακες πρέπει να αναφέρουμε μία πολύ χρήσιμη συνάρτηση την split η οποία συντάσσεται ως εξής:
Η split εκείνο που κάνει είναι να διαχωρίζει το string s σε πεδία και να βάζει το κάθε πεδίο σε διαδοχικές θέσεις του πίνακα Α ( A[1], A[2],.
Ο χωρισμός του string σε πεδία γίνεται με βάσει τον διαχωριστή πεδίων που είναι η τρίτη παράμετρος της split.
Η παράμετρος αυτή μπορεί και να παραλειφθεί οπότε ως διαχωριστής πεδίων θεωρείται το κενό και το tab.
Να μετατραπεί το πρώτο γράμμα κάθε πεδίου σε κεφαλαίο
Να βρεθεί για ένα κείμενο η συχνότητα εμφάνισης των λέξεων (ποιες λέξεις εμφανίζονται και πόσες φορές εμφανίζεται η κάθε μία).
Να εκτυπωθούν ανάποδα οι γραμμές ενός αρχείου (η πρώτη τελευταία και η τελευταία πρώτη κ.ο.κ.)
Η εντολή last | grep “όνομα login” > mylog δημιουργεί ένα αρχείο mylog με το ιστορικό των login που κάνουμε.
Μετατρέψτε το αρχείο mylog ώστε να περιέχει τον ίδιο αριθμό πεδίων ανά γραμμή που να χωρίζονται από ένα κενό.
Επίσης να μην περιέχει τις γραμμές που περιέχουν την φράση “still logged in”.
Να βρεθεί πόσες φορές έχω κάνει login στο σύστημα και ο συνολικός χρόνος σύνδεσης.
Να βρεθεί για κάθε μέρα της εβδομάδας πόσες φορές συνδέθηκα.
Να βρεθεί για κάθε μήνα καθώς και για κάθε ώρα της ημέρας πόσες φορές συνδέθηκα.
Για τους χρήστες που χρησιμοποιούν αυτή τη στιγμή το σύστημα βρείτε και εμφανίστε στην οθόνη σε αύξουσα σειρά χρόνου τον συνολικό χρόνο σύνδεσης του καθενός.
Προτείνονται οι εξής βελτιώσεις : α) Να συνυπολογίζεται και ο χρόνος της τρέχουσας σύνδεσης (εντολή time) β) Να ελέγχονται για διπλό login όλες οι εγγραφές πριν προστεθούν και να εμφανίζεται ανάλογο μήνυμα για το πότε και από ποιο port συνέβη αυτό.
Να γραφτεί ένα πρόγραμμα με όνομα “del_char”, το οποίο να σβήνει τους πρώτους 5 χαρακτήρες κάθε γραμμής ενός αρχείου το οποίο δίνεται σαν παράμετρος στο πρόγραμμα.
Να ελέγχετε εάν υπάρχει το αρχείο καθώς επίσης και το πλήθος των παραμέτρων.
Γράψτε ένα πρόγραμμα (script) με όνομα user_space το οποίο να δέχεται σαν παράμετρο το UID ενός χρήστη και να εμφανίζει το χώρο που καταλαμβάνει ο χρήστης στο δίσκο.
Να γίνεται έλεγχος για τον αριθμό των παραμέτρων, και για περισσότερες ή λιγότερες από μια παράμετρο να βγαίνει μήνυμα λάθους.
Αν δεν υπάρχει το UID του χρήστη να βγαίνει μήνυμα λάθους.
Σας δίνεται ένα λεξικό-αρχείο που περιέχει όλες τις λέξεις της Αγγλικής γλώσσας, μια σε κάθε σειρά.
Έχετε επίσης κάποια αρχεία κείμενα που περιέχουν ακριβώς 9 λέξεις σε κάθε σειρά.
Κάντε ένα πρόγραμμα (script) με όνομα lexicon_script που να βρίσκει τις λέξεις στα αρχεία-κείμενα οι οποίες είναι λάθος γραμμένες και να τυπώνει τις λέξεις αυτές σε ένα αρχείο με όνομα errors.
Το πρόγραμμα να έχει την πρώτη παράμετρο το λεξικό και να ακολουθεί μια ακόμα παράμετρος που είναι αρχείο – κείμενο (Δύο παράμετροι συνολικά).
Να γίνονται έλεγχοι για την ύπαρξη των αρχείων – παραμέτρων (Λεξικό και κείμενο).
Σε περίπτωση λιγότερων ή περισσότερων από δύο παραμέτρων να βγαίνει μήνυμα λάθους.
Τα αρχεία κείμενα έχουν αδιευκρίνιστο αριθμό γραμμών.
Γράψτε ένα πρόγραμμα κελύφους (shell script) με όνομα “repeat_string” το οποίο επαναλαμβάνει n φορές μία εντολή.
Ο αριθμός n δίνεται ως πρώτη παράμετρος.
Οι υπόλοιπες παράμετροι αποτελούν την εντολή.
Εάν η πρώτη παράμετρος δεν είναι αριθμός να εμφανίζεται κατάλληλο μήνυμα λάθους.
Πχ. η γραμμή: θα εκτελέσει 15 φορές την εντολή “echo hello”.
Εάν δοθούν λιγότερες από 3 παράμετροι, τότε εμφανίζεται κατάλληλο μήνυμα λάθους.
Γράψτε ένα πρόγραμμα κελύφους (shell script) με όνομα “SubDirSize” το οποίο δέχεται σαν παράμετρο την διεύθυνση ενός υποκαταλόγου (πλήρη ή σχετική).
Το πρόγραμμα αθροίζει το μέγεθος των αρχείων μόνο των υποκαταλόγων (και όχι των αρχείων) του καταλόγου παραμέτρου.
Πχ. η γραμμή: θα εμφανίσει τον χώρο τον οποίο καταλαμβάνουν οι υποκατάλογοι του καταλόγου ”/etc”.
Εάν δεν δίνεται παράμετρος τότε υπολογίζει και εμφανίζει το μέγεθος που καταλαμβάνουν οι υποκατάλογοι του τρέχοντος καταλόγου.
Γράψτε ένα πρόγραμμα κελύφους με όνομα “rev_vowels” το ένα αρχείο με λέξεις της Αγγλικής Γλώσσας (μία λέξη ανά γραμμή).
Το πρόγραμμα εμφανίζει τις λέξεις που έχουν όλα τα φωνήεντα σε ανάποδη σειρά.
Ελέγξτε το πλήθος των παραμέτρων και την ύπαρξη του αρχείου.
Γράψτε ένα πρόγραμμα (script) με όνομα “del_lines” που να σβήνει τα περιεχόμενα της πρώτης μέχρι την 7η γραμμή ενός αρχείου το οποίο δίνετε σαν παράμετρος στο πρόγραμμα.
Να ελέγχετε αν υπάρχει το αρχείο καθώς επίσης και το πλήθος των παραμέτρων.
Να γραφτεί ένα πρόγραμμα με όνομα groups_aetos που να κάνει τα ακόλουθα: Να δίνει τα ονόματα των ομάδων (group) μέσα σε ένα αρχείο με όνομα groups, τον αριθμό (Group Identification number-GID) της ομάδας it μέσα σε ένα αρχείο με όνομα var1, και τέλος να δίνει τους χρήστες που ανήκουν στην ομάδα (group) it, μέσα σε ένα αρχείο με όνομα usersit.
Στην άσκηση αυτή τον αριθμό της ομάδας it που θα περιέχετε στο αρχείο var1, μπορείτε να τον δώσετε κατευθείαν σαν αριθμό στην επόμενη εντολή σας χωρίς να τον διαβάσετε από το αρχείο σε παράμετρο.
Δηλαδή δείτε τον αριθμό από το αρχείο var1 και βάλτε τον στην επόμενη εντολή σαν αριθμό, εκτός αν γνωρίζετε πώς να το κάνετε αλλιώς
Να γραφτεί ένα πρόγραμμα με όνομα users_time_it που να βρίσκει πόσο χρόνο ήταν μέσα στο σύστημα τους τελευταίους μήνες ο καθένας από τους χρήστες της ομάδας it και να βγάζει τα αποτελέσματα σε ένα αρχείο με όνομα time_logged. (3.5 μονάδες)
Να γίνει ένα τιμολόγιο για παραγγελίες κάποιας εταιρίας.
Πρόσθεση προϊόντων, ποσοτήτων και τιμών ανά μονάδα ποσότητας (addt1).
Μπορεί να υπάρχει παραπάνω από μια καταχώρηση για κάθε προϊόν.
Αφαίρεση προϊόντων (remove)
Εμφάνιση συγκεκριμένου προϊόντος. (lu)
Εμφάνιση όλων (listall)
Συνολική τιμή για μια σειρά αγορών (όλο το τιμολόγιο) και συνολική ποσότητα από κάθε προϊόν. (prices).
Για την συνολική τιμή προσθέτουμε τις τιμές κόστους των προϊόντων, (τιμή επί ποσότητα) , επίσης τα μεταφορικά και τον φόρο.
Τα μεταφορικά είναι 1000 δρχ μέχρι 50 κιλά, 2000 δρχ μέχρι 200 κιλά και 3000 δρχ για πάνω από 200 κιλά για την συνολική παραγγελία.
Ο φόρος είναι 8% στις πρώτες 30000 δρχ και 18% για το υπόλοιπο ποσό στο σύνολο. · Από τις περιπτώσεις του Menu ( Όνομα: menut1) θα κάνετε την περίπτωση 1 και την περίπτωση 5.
Το script1 (Όνομα: addt1) θα προσθέτει εγγραφές στο αρχείο timologio με τα πεδία όπως δίνονται στην εκφώνηση.
Το script5 (Όνομα: prices) τυπώνει την συνολική τιμή για το τιμολόγιο και την συνολική ποσότητα για κάθε προϊόν.
Η συνολική τιμή είναι: τιμή = κόστος + μεταφορικά + φόρος.
Τα άλλα script θα αντηχούν απλά το όνομά τους · Από το πρόγραμμα θα βγαίνετε μόνο με έξοδο (exit) όταν πατάτε Ε ή e ή 9.
Να γίνει Φορολογική Δήλωση για μια πολυεθνική Εταιρία που διαθέτει περιουσία σε πολλές χώρες.
Πρόσθεση χώρας, Ηπείρου που βρίσκετε η χώρα, συνολικό κέρδος στην χώρα σε δρχ, αξία περιουσίας στην χώρα σε δρχ, τοπική πρώτη φορολογική κλίμακα επί τοις εκατό, τοπικό αφορολόγητο ποσό και έξοδα στην χώρα.(addt2)
Αφαίρεση χώρας (remove)
Εμφάνιση συγκεκριμένης χώρας. (lu)
Φόρος για κάθε χώρα και για κάθε Ήπειρο (Tax).
Ο φόρος υπολογίζεται ως εξής: Από το κέρδος αφαιρούμε τα έξοδα στην χώρα και το τοπικό αφορολόγητο ποσό.
Από τα υπόλοιπα τα πρώτα 100000 δρχ φορολογούνται με την βασική φορολογική κλίμακα της χώρας.
Τα υπόλοιπα με διπλό ποσοστό.
Στο ποσό που θα προκύψει προσθέτουμε το φόρο της συνολικής περιουσίας στην χώρα που είναι 0.5% μέχρι 1000000 και 1% για το υπόλοιπο ποσό πάνω από 1000000. · Από τις περιπτώσεις του Menu (Όνομα: menut2) θα κάνετε την περίπτωση 1 και την περίπτωση 5.
Στην περίπτωση 1 να γίνει script (Όνομα: addt2) που να προσθέτει εγγραφές στο αρχείο foros.txt με τα πεδία όπως δίνονται στην εκφώνηση.
Στην περίπτωση 5 να κάνετε script (Όνομα: taxes) που να τυπώνει το φόρο για κάθε χώρα και το φόρο για κάθε Ήπειρο.
Τα άλλα script θα αντηχούν απλά το όνομά τους
Να γίνει ένα menu που να κάνει τα επόμενα:
Πρόσθεση πεδίων σε μια βάση δεδομένων (temperatures).
Τα πεδία είναι: Χώρα, Ήπειρος, Μέγιστη Θερμοκρασία ανά έτος, ελάχιστη Θερμοκρασία ανά έτος, και είδος βαθμών θερμοκρασίας, δηλαδή βαθμοί Κελσίου (celsius) και βαθμοί Φαρενάιτ (fahrenheit) . (script: add)
Εμφάνιση συγκεκριμένης Χώρας. (lu)
Η περίπτωση αυτή του menu να καλεί ένα script (change_to_celsius).
Το script αυτό να ελέγχει αν τα πρώτα δύο πεδία είναι λέξεις (γράμματα) και τα πεδία 3 και 4 είναι αριθμοί και το πεδίο 5 λέξη (γράμματα).
Σε αντίθετες περιπτώσεις να βγάζει μηνύματα λάθους.
Τέλος το script αυτό να αλλάζει την βάση δεδομένων μετατρέποντας τις θερμοκρασίες σε βαθμούς Κελσίου όπου χρειάζεται αυτό.
Φυσικά θα πρέπει να ενημερώνετε και το τελευταίο πεδίο ότι άλλαξε το είδος βαθμών σε Κελσίου. (τύπος: c=(f-32)*0.5555)
Να καλεί ένα script που να διαβάζει από την βάση δεδομένων temperatures και να τυπώνει την μέση θερμοκρασία ανά χώρα και ανά Ήπειρο (mean_temperatures) μόνο όταν οι βαθμοί είναι Κελσίου και να αγνοεί τις υπόλοιπες εγγραφές. · Από τις περιπτώσεις του Menu ( Όνομα: menu) θα κάνετε την περίπτωση 1 την περίπτωση 5 και την περίπτωση 6.
Το script1 (Όνομα: add) θα προσθέτει εγγραφές στο αρχείο temperatures με τα πεδία όπως δίνονται στην εκφώνηση.
Το script5 (Όνομα: change_to_celsius) μετατρέπει τους βαθμούς σε Κελσίου όπου χρειάζεται αυτό όπως λέει στην εκφώνηση.
Το script 6 (mean_temperatures) τυπώνει τις μέσες θερμοκρασίες ανά έτος σε κάθε χώρα και σε κάθε Ήπειρο Τα άλλα script θα αντηχούν απλά το όνομά τους αρχείο change_to_celsius αρχείο mean_temperatures
Να αναπτυχθεί ένα πρόγραμμα που θα έχει την δυνατότητα να ελέγχει ένα κείμενο ως προς την ορθογραφία του με δυνατότητα διόρθωσης των εσφαλμένων λέξεων.
Ο έλεγχος ορθογραφίας θα γίνεται με βάση ένα δεύτερο αρχείο (λεξικό).
Το πρόγραμμα θα παίρνει σαν παραμέτρους το αρχείο κειμένου και το αρχείο του λεξικού.
Στη συνέχεια θα ελέγχει όλες τις λέξεις του αρχείου κειμένου.
Αν κάποια λέξη δεν βρεθεί μέσα στο λεξικό τότε θα ειδοποιεί τον χρήστη για το σφάλμα και θα τον ρωτάει αν θέλει να την αντικαταστήσει με την σωστή λέξη.
Αν ο χρήστης απαντήσει καταφατικά (y/Y) θα του ζητάει την σωστή λέξη και στη συνέχεια θα κάνει την αντικατάσταση μέσα στο κείμενο.
Να γίνονται έλεγχοι για τον αν οι παράμετροι είναι δύο και αν υπάρχουν τα αρχεία - παράμετροι. · Η αντικατάσταση να γίνεται μόνο στην γραμμή που είναι το σφάλμα και όχι σε όλο το κείμενο. · Το αρχείο κειμένου μπορεί να έχει απεριόριστο αριθμό γραμμών.
Να αναπτυχθεί ένα πρόγραμμα που θα έχει τις δυνατότητες ενός υπολογιστή τσέπης (Calculator).
Το πρόγραμμα θα έχει την δυνατότητα να εκτελεί τις πράξεις πρόσθεση (+), αφαίρεση (-), πολλαπλασιασμός (*), διαίρεση (/) και ακέραιο υπόλοιπο διαίρεσης (%).
Η χρήση του προγράμματος θα είναι ως εξής:
ο χρήστης θα δίνει τον πρώτο αριθμό το σύμβολο της πράξης και τον δεύτερο αριθμό και το πρόγραμμα θα εμφανίζει το αποτέλεσμα.
Η εισαγωγή της πράξης μπορεί να γίνεται είτε στην ίδια γραμμή π.χ. :
είτε σε διαφορετικές γραμμές π.χ. : ανάλογα με το πως βολεύει προγραμματιστικά.
Το πρόγραμμα θα ζητά επαναληπτικά από τον χρήστη αριθμούς και τελεστές και θα κάνει τις πράξεις.
Θα τερματίζει δε όταν δοθεί αντί για πρώτο αριθμό η λέξη “END”.
Το πρόγραμμα θα πρέπει να έχει και δυνατότητα μνήμης.
Έτσι, αν δεν δίνεται από τον χρήστη πρώτος αριθμός αλλά μόνο ο τελεστής της πράξης και ο δεύτερος (π.χ. + 2.1) θα πρέπει να λαμβάνεται ως πρώτος αριθμός το αποτέλεσμα της προηγούμενης πράξης (μνήμη).
Για παράδειγμα αν αρχικά δώσουμε :
προφανώς πρέπει να βγάλει αποτέλεσμα 23.1.
Αν στη συνέχεια δώσουμε: θα πρέπει να βγάλει αποτέλεσμα 25.2 (23.1+2.1).
Αν βέβαια μετά δώσουμε: θα πρέπει να αγνοήσει τη μνήμη και να βγάλει αποτέλεσμα 34.7-10.7=24.0. · H expr κάνει πράξεις μόνο με ακεραίους ενώ η AWK και με δεκαδικούς.
Να αναπτυχθεί ένα πρόγραμμα με όνομα cheat_control που θα έχει την δυνατότητα παρακολούθησης ύποπτων διεργασιών κατά την διαδικασία εξετάσεων του εργαστηρίου Unix.
Το πρόγραμμά σας θα θεωρεί ύποπτες όλες οι διεργασίες τις οποίες μπορεί κάποιος να χρησιμοποιήσει για να κλέψει.
Το πρόγραμμα θα πρέπει κατά τακτά χρονικά διαστήματα (π.χ. κάθε 5 δευτερόλεπτα) να ελέγχει όλες τις διεργασίες που τρέχουν εκείνη την στιγμή, από τους χρήστες που βρίσκονται στην αίθουσα εξετάσεων.
Οι «ύποπτες» διεργασίες θα περιέχονται σε ξεχωριστό αρχείο με όνομα “susp_com”.
Κάθε φορά που ανιχνεύεται μία ύποπτη διεργασία το περιστατικό να καταχωρείται με πλήρη στοιχεία (εκτός από τον χρόνο εκτέλεσης της και την διάρκεια της) και μόνο μία φορά για κάθε διεργασία σε ένα log file με όνομα suspect.log.
Τέλος το πρόγραμμα να δέχεται μία παράμετρο χρόνου (σε δευτερόλεπτα) κατά τον οποίο θα είναι ενεργό, και μετά την πάροδο αυτού του χρόνου να τερματίζει μόνο του.
Αν δεν δοθεί παράμετρος να εκτελείται συνέχεια. · Για να βρούμε ποιοι βρίσκονται στην αίθουσα εξετάσεων ελέγχουμε την εντολή last και συγκεκριμένα τις γραμμές που έχουν “still logged in” μόνο.
Από αυτές κρατάμε μόνο όσες γραμμές αναφέρονται σε χρήστες που βρίσκονται σε έναν από τους terminal servers του εργαστηρίου, δηλαδή τους paris menelaos και eleni. (τρίτο πεδίο).
Τέλος από αυτά τα στοιχεία κρατάμε ΜΟΝΟ το login name.
Το αρχείο με τους users θα το ονομάσετε students.exam · Ύποπτη διεργασία θεωρείτε ακόμα και ο vi αν αναφέρεται σε αρχείο εκτός από τα cheat_control και susp_com, suspect.log και students.exam όπως επίσης και το mail ή το pine.
Γενικά θεωρείστε ότι οι εξεταζόμενοι μπορούν να δουλεύουν μόνο με τα αρχεία των εξετάσεων και την εντολή man. · Αν υποτεθεί ότι κάποιος από έξω γράφει κάποιο αρχείο στον κατάλογο κάποιου εξεταζόμενου να προβλεφτεί ότι δεν θα γίνει χρήση εντολών mv κλπ πάνω στα αρχεία των εξετάσεων χωρίς αυτές οι εντολές να καταχωρηθούν στο αρχείο suspect.log.
Αυτό σημαίνει ότι ελέγχετε και εντολές σαν την mv που αναφέρονται στα αρχεία cheat_control και susp_com και students.exam.
Επομένως εντολές σαν την mv θα ελέγχονται ξεχωριστά από όποιον χρήστη και αν προέρχονται εφόσον γίνονται πάνω στα κρίσιμα αρχεία.
Δημιουργήστε με τον vi ένα αρχείο που περιέχει γραμμές με πεδία το όνομα και το επώνυμο του φοιτητή το τμήμα του και βαθμό του μαθήματος (Τέσσερα πεδία).
Λίγες γραμμές είναι αρκετές για την δοκιμή.
Χρησιμοποιήστε αυτό το αρχείο ως αρχείο εισόδου για ένα πρόγραμμα που θα βγάζει τον μέσο όρο βαθμολογίας του κάθε τμήματος καθώς και πόσοι πέρασαν και πόσοι κόπηκαν σε κάθε τμήμα.
Θα γίνεται και έλεγχος ότι το όνομα είναι «λέξη» ο βαθμός αριθμός και το τμήμα μια από τις επιλογές Τ1 ή Τ2 ή Τ3.
Το πρόγραμμα να δέχεται σαν παράμετρο το όνομα του αρχείου εισόδου και το όνομα του αρχείου εξόδου.
Να βγαίνουν μηνύματα λάθους αν οι παράμετροι δεν είναι δύο και αν το αρχείο εισόδου δεν υπάρχει, και το πρόγραμμα να τερματίζεται.
Αν σε μια σειρά του αρχείου εισόδου το όνομα ή ο βαθμός ή το τμήμα δεν είναι ο σωστός τύπος δεδομένων απλά τυπώστε στο αρχείο εξόδου τον τύπο του σφάλματος.
Το αρχείο εξόδου σε κανονική εκτέλεση πρέπει να είναι της μορφής:
Σε περίπτωση λάθους να έχουμε και την εκτύπωση του λάθους και του τύπου του λάθους στο ίδιο αρχείο εξόδου ώστε να καταλάβουμε ότι οι υπολογισμοί δεν γίνανε σωστά, άσχετα αν έχουν βγει κάποια αποτελέσματα.
Πχ.
ERROR: t3rm1nat0r is NOT a name line: 4 Πχ ERROR: @ is NOT a number line: 5 Πχ.
ERROR: T5 does NOT exist line: 6 Το πρόγραμμά μας να έχει δυνατότητα να ελέγχει το αρχείο εξόδου ώστε να πάρει τις απαραίτητες πληροφορίες για τα λάθη, να ζητάει από σας να διορθώσετε το αρχείο εισόδου μέσα από το πρόγραμμα, και όταν το αρχείο εισόδου δεν έχει άλλα λάθη να βγάζει τα ΣΩΣΤΑ αποτελέσματα.
Ορίζεται μια νέα πράξη με τελεστή το σύμβολο underscore (_).
Η πράξη είναι ως εξής: Δίνεται ένας αριθμός, ο τελεστής και ο δεύτερος αριθμός.
Ακόμα δίνεται η πράξη με σύμβολο το κάγκελο (#):
Να αναπτυχθεί ένα πρόγραμμα που θα έχει τις δυνατότητες ενός υπολογιστή τσέπης (Calculator) για αυτές τις πράξεις.
Η χρήση του προγράμματος θα είναι ως εξής:
Το πρόγραμμα θα πρέπει να έχει και δυνατότητα μνήμης.
Έτσι, αν δεν δίνεται από τον χρήστη πρώτος αριθμός αλλά μόνο ο τελεστής της πράξης και ο δεύτερος (π.χ. #3) θα πρέπει να λαμβάνεται ως πρώτος αριθμός το αποτέλεσμα της προηγούμενης πράξης (μνήμη).
Για παράδειγμα αν αρχικά δώσουμε :
προφανώς πρέπει να βγάλει αποτέλεσμα (1+2+3+4+5) modulo 4= 15 modulo 4 = 3.
Αν στη συνέχεια δώσουμε: θα πρέπει να βγάλει αποτέλεσμα (3#3=3!/33=(1x2x3)/27=6/27=0.2222222).
Αν βέβαια μετά δώσουμε: θα πρέπει να αγνοήσει τη μνήμη και να βγάλει αποτέλεσμα 4!/42=(1x2x3x4)/16=24/16=1.5 Να γίνουν ακόμα όλοι οι απαραίτητοι έλεγχοι. · Προσοχή οι πράξεις αυτές είναι πράξεις θετικών ακεραίων, το αποτέλεσμα όμως της δεύτερης πράξης μπορεί να είναι και θετικός δεκαδικός αριθμός. · H expr κάνει πράξεις μόνο με ακεραίους ενώ η AWK και με δεκαδικούς και υπολογίζει και το modulo (%).
Να γραφεί πρόγραμμα εντολών (shell script) με τίτλο “is_numeric”, το οποίο δέχεται μία παράμετρο, ελέγχει αν είναι αριθμός και εμφανίζει ανάλογο μήνυμα.
Προσοχή να ελέγχεται αν η παράμετρος υπάρχει και είναι μόνο μία.
Να γραφεί πρόγραμμα εντολών (shell script) με τίτλο “same_words”, το οποίο δέχεται σαν παραμέτρους τρεις λέξεις και ελέγχει εάν είναι ίδιες.
Εάν οι παράμετροι είναι λιγότερες από τρεις, διαβάζει τις υπόλοιπες μέσα στο πρόγραμμα.
Εάν είναι περισσότερες από τρεις, εμφανίζει κατάλληλο μήνυμα και επεξεργάζεται μόνο τις τρεις πρώτες, αγνοώντας τις υπόλοιπες.
Προσοχή να γίνει έλεγχος και ομοιότητας ανά δύο.
Άσκηση vi_users_space Να αναπτυχθεί πρόγραμμα κελύφους (shell script) που να βρίσκει πόσο χώρο καταλαμβάνουν τα αρχεία που βρίσκονται στον βασικό κατάλογο (το home directory) του κάθε χρήστη που τρέχει vi αυτή την στιγμή, στο δίσκο.
Σαν αποτέλεσμα το πρόγραμμα να εμφανίζει το όνομα κάθε χρήστη και δίπλα τον χώρο των αντίστοιχων αρχείων σε Kilobytes.
Να αναπτυχθεί ένα πρόγραμμα που θα παίρνει σαν παράμετρο το “login” ενός χρήστη και θα βρίσκει και θα εμφανίζει τα αρχεία και τους υποκαταλόγους που βρίσκονται στον κατάλογο του χρήστη και έχουν πάνω από έναν σκληρούς συνδέσμους (hard links) το μέγεθος του καθενός καθώς και το συνολικό χώρο που καταλαμβάνουν.
Το πρόγραμμα να ελέγχει αν η παράμετρος είναι μία και άν ο χρήστης υπάρχει, διαφορετικά να εμφανίζει κατάλληλα μηνύματα.
Το αποτέλεσμα του προγράμματος να έχει την παρακάτω μορφή :
Να αναπτυχθεί πρόγραμμα κελύφους (shell script) που να βρίσκει πόσο χώρο καταλαμβάνουν στο δίσκο τα αρχεία που βρίσκονται στον κατάλογο του κάθε χρήστη που ανήκει σε ένα group που δίνεται στο πρόγραμμα σαν παράμετρος.
Σαν αποτέλεσμα το πρόγραμμα να εμφανίζει τον συνολικό χώρο των αρχείων σε bytes.
Επίσης να ελέγχει άν η παράμετρος είναι μία και αν το group υπάρχει. ή χωρίς χρήση awk –v
Να γραφεί το πρόγραμμα εντολών UNIX (Shell script) το οποίο θα υλοποιεί την παρακάτω λίστα επιλογών:
΄Άθροισμα μεγέθους αρχείων που αρχίζουν με "G" και περιέχουν τους χαρακτήρες "a" ή "e"
Σε περίπτωση λάθους επιλογής εμφανίζεται ανάλογο μήνυμα και ζητάει νέα επιλογή.
Το πρόγραμμα τελειώνει μόνο όταν ο χρήστης δώσει την επιλογή 9.
Στην πρώτη επιλογή, ζητάει το όνομα του αρχείου και τα νέα δικαιώματα που θα του αντιστοιχίσει.
Εάν το αρχείο υπάρχει, αποδίδει στο αρχείο τα νέα δικαιώματα.
Στην επιλογή 2, ζητάει το όνομα του αρχείου προς διαγραφή και εάν το αρχείο υπάρχει, ρωτάει τον χρήστη πριν το διαγράψει.
Εάν δεν υπάρχει εμφανίζει κατάλληλο μήνυμα.
Στην επιλογή 3 ελέγχει αν εργάζονται στο σύστημα χρήστες των οποίων το "login name" τελειώνει σε "s".
Στην επιλογή 4, υπολογίζει το άθροισμα του μεγέθους των αρχείων των οποίων το όνομα αρχίζει από "G" και περιέχει τους χαρακτήρες "a" ή "e".
Να γραφεί πρόγραμμα εντολών (shell script) με τίτλο “rev_lines”, το οποίο δέχεται σαν παράμετρο το όνομα ενός αρχείου.
Ελέγχει εάν το αρχείο υπάρχει ή όχι.
Εάν δεν υπάρχει τερματίζει με κατάλληλο μήνυμα.
Εάν υπάρχει τότε εμφανίζει με ανάποδη σειρά τις γραμμές του αρχείου στην οθόνη ξεκινώντας από την τελευταία γραμμή και τελειώνοντας με την πρώτη.
Προσοχή να ελέγχεται αν η παράμετρος υπάρχει και είναι μόνο μία.
Να γραφεί πρόγραμμα εντολών (shell script) με τίτλο “rm_lines”, το οποίο δέχεται σαν παράμετρο το όνομα ενός αρχείου.
Ελέγχει εάν το αρχείο υπάρχει ή όχι.
Εάν δεν υπάρχει τερματίζει με κατάλληλο μήνυμα.
Εάν υπάρχει τότε διαγράφει όσες γραμμές του αρχείου είναι κενές ή περιέχουν μόνο λευκούς χαρακτήρες (κενά και tabs).
Να γραφεί πρόγραμμα εντολών (shell script) με τίτλο “add_params”, το οποίο προσθέτει αριθμητικά τις παραμέτρους τις οποίες δέχεται και εμφανίζει το άθροισμά τους.
Εάν δεν δοθεί τουλάχιστον μία παράμετρος το πρόγραμμα τελειώνει.
Γράψτε ένα πρόγραμμα με τίτλο "user_data" το οποίο θα εμφανίζει τα στοιχεία του αρχείου "/etc/passwd" με την μορφή user 101 502 /home/dir /bin/csh Ονοματεπώνυμο κλπ Να γραφτεί ένα script που κάνει τους βαθμούς Fahrenheit σε Κελσίου και αντιστρόφως.
Ακόμα να ελέγχετε αν η πρώτη παράμετρος είναι αριθμός και αν οι παράμετροι είναι μόνο δύο.
Αριθμός και βαθμός F ή C.Σε αντίθετες περιπτώσεις να βγαίνουν μηνύματα λάθους. 1 F =(1C*9/5)+32
Να γραφτεί ένα script που να βγάζει το μέσο όρο των βαθμών 5 μαθημάτων για φοιτητές.
Να ελέγχεται αν οι παράμετροι 2-6 είναι αριθμοί και αν οι παράμετροι είναι 6 (Πρώτα το όνομα μετά 5 βαθμοί μαθημάτων) Αλλιώς να βγάζει μηνύματα λάθους.
Να γραφτεί ένα script που βρίσκει το παραγοντικό ενός αριθμού Πχ. 5!=1x2x3x4x5 Να ελέγχεται αν η παράμετρος είναι αριθμός και αν είναι μία.
Αλλιώς να βγαίνει μήνυμα λάθους.
Γράψτε ένα script με sed που διπλασιάζει τα κενά μεταξύ των λέξεων.
Να γραφεί το πρόγραμμα εντολών UNIX (shell script) με όνομα “add_user” το οποίο θα προσθέτει χρήστες σε ένα σύστημα UNIX.
Συγκεκριμένα το πρόγραμμα: · Δέχεται σαν παράμετρο το login του χρήστη ο οποίος θα προστεθεί.
Εάν δεν δοθεί παράμετρος το πρόγραμμα ζητάει το login από τον διαχειριστή. · Ελέγχει εάν υπάρχει ήδη χρήστης με το login που δόθηκε.
Εάν υπάρχει τότε ενημερώνει τον διαχειριστή και ζητάει νέο login χρήστη μέχρι να δοθεί κατάλληλο login ή να επιλέξει ο διαχειριστής τον τερματισμό του προγράμματος. · Το πεδίο που αντιστοιχεί στο συνθηματικό (password) μένει κενό. · Υπολογίζει τον αριθμό του χρήστη (uid), ο οποίος είναι +1 από τον αριθμό του τελευταίου χρήστη. · Ζητάει τα υπόλοιπα πεδία, και καταχωρεί όλα τα στοιχεία του χρήστη. · Δημιουργεί τον οικείο κατάλογο (home directory) του χρήστη σύμφωνα με αυτό που καταχωρήθηκε νωρίτερα. · Δίνει στον χρήστη τα κατάλληλα δικαιώματα πρόσβασης στον κατάλογό του. · Αλλάζει το group του χρήστη σε αυτό που καταχωρήθηκε νωρίτερα.
Να γραφεί το πρόγραμμα εντολών UNIX (shell script) με όνομα “rm_user” το οποίο θα διαγράφει χρήστες από ένα σύστημα UNIX.
Συγκεκριμένα το πρόγραμμα: · Δέχεται σαν παράμετρο το login του χρήστη ο οποίος θα διαγραφεί.
Εάν δεν δοθεί παράμετρος το πρόγραμμα ζητάει το login από τον διαχειριστή. · Ελέγχει εάν υπάρχει χρήστης με το login που δόθηκε.
Εάν υπάρχει τότε διαγράφει τον χρήστη.
Εάν δεν υπάρχει ενημερώνει τον διαχειριστή και ρωτάει εάν θέλει να συνεχίσει ή να τελειώσει.
Γράψτε ένα πρόγραμμα κελύφους (shell script) με όνομα "cmpdir" το οποίο δέχεται δύο ορίσματα τα οποία αντιστοιχούν σε δύο καταλόγους.
Το πρόγραμμα συγκρίνει τα αρχεία των δύο καταλόγων και εμφανίζει τα αρχεία τα οποία είναι διαφορετικά στους δύο καταλόγους.
Το πρόγραμμα εμφανίζει τρεις διαφορετικές λίστες: · Αρχεία τα οποία υπάρχουν μόνο στον πρώτο κατάλογο · Αρχεία τα οποία υπάρχουν μόνο στον δεύτερο κατάλογο · Αρχεία τα οποία υπάρχουν και στους δύο καταλόγους αλλά δεν είναι ίδια
Γράψτε ένα πρόγραμμα κελύφους (shell script) με όνομα "compdate" το οποίο δέχεται μία παράμετρο με την μορφή ημερομηνίας (dd/mm/yyyy).
To πρόγραμμα υπολογίζει το πλήθος των ημερών που πέρασαν ή θα περάσουν από την συγκεκριμένη ημερομηνία.
Να ελέγχεται το πλήθος των παραμέτρων και η σωστή μορφή της παραμέτρου.
Γράψτε ένα πρόγραμμα κελύφους (shell script) το οποίο υλοποιεί ένα "menu" με τις εξής επιλογές:
Πρόσθεση νέου φορολογούμενου
Μεταβολή στοιχείων φορολογούμενου
Εμφάνιση στοιχείων φορολογούμενου
Για κάθε φορολογούμενο κρατάμε τα εξής στοιχεία: · Αριθμός φορολογικού μητρώου
Η προθεσμία μπορεί να έχει μόνο μία από τις τιμές: εντός ή εκτός.
Ο φόρος υπολογίζεται πολλαπλασιάζοντας το μισθό επί την φορολογική κλίμακα και διαιρώντας με το 100.
Σε αυτό προσθέτουμε πρόστιμο 10% αν δεν έχει πληρωθεί εντός προθεσμίας.
Πρόσθεση νέου εργαζόμενου
Μεταβολή στοιχείων εργαζόμενου
Εμφάνιση στοιχείων εργαζόμενου
Το πτυχίο μπορεί να έχει τις εξής τρεις τιμές: ΟΧΙ, Πτυχίο, Μεταπτυχιακό.
Ο Μισθός υπολογίζεται πολλαπλασιάζοντας το ωρομίσθιο επί τις ώρες εργασίας.
Σε αυτό προσθέτουμε 10% για πτυχίο και 20% για μεταπτυχιακό.
Πρόσθεση νέου ασφαλισμένου
Μεταβολή στοιχείων ασφαλισμένου
Εμφάνιση στοιχείων ασφαλισμένου
Η ασφάλεια υπολογίζεται πολλαπλασιάζοντας τον αριθμό των ατυχημάτων επί χίλια.
Το ποσό αυτό διπλασιάζεται για τα αυτοκίνητα με κυβισμό μεγαλύτερο των 2000 κυβικών.
Σε αυτό προσθέτουμε 20000 δρχ. που είναι η ασφάλεια χωρίς ατυχήματα.
Γράψτε ένα πρόγραμμα κελύφους (shell script) με όνομα “AsciiBytes” το οποίο εμφανίζει το μέγεθος σε Κbytes όλων των αρχείων κειμένου (text files) τα οποία δίνονται ως παράμετροι στην γραμμή εντολών.
Υπόδειξη: Χρησιμοποιείστε την εντολή “file”
Γράψτε ένα πρόγραμμα κελύφους (shell script) με όνομα “waitfor” το οποίο ελέγχει κάθε Ν λεπτά εάν κάποιος χρήστης έχει κάνει login.
Μόλις ο ζητούμενος χρήστης κάνει login, το πρόγραμμα ενημερώνει τον χρήστη του προγράμματος και σταματάει την εκτέλεσή του.
Το login του χρήστη δίνεται ως πρώτη παράμετρος και τα λεπτά ως δεύτερη.
Το πρόγραμμα ελέγχει το πλήθος των παραμέτρων και την ύπαρξη χρήστη με το login που δίνεται.
Κατάσταση Εισαγωγής Κειμένου
Δείκτες σε data blocks
Τριπλά Έμμεσο Μπλόκ
